syntax = "proto3";

// Package ctrl.v1 provides the Cluster service for multi-cluster deployment orchestration.
//
// The Cluster service enables a central control plane to coordinate deployments and sentinels
// across multiple Kubernetes clusters. Each cluster runs an agent (such as krane) that establishes
// a long-lived watch connection to receive deployment and sentinel configuration events.
//
// This design follows the Kubernetes watch pattern where agents (like kubelet) maintain
// a streaming connection to receive incremental updates, enabling real-time deployment
// orchestration across distributed clusters.
package ctrl.v1;

option go_package = "github.com/unkeyed/unkey/gen/proto/ctrl/v1;ctrlv1";

// Health represents the health state of a resource (sentinel, deployment instance, etc.)
enum Health {
  HEALTH_UNSPECIFIED = 0;
  HEALTH_HEALTHY = 1;
  HEALTH_UNHEALTHY = 2;
  HEALTH_PAUSED = 3;
}

// ClusterService coordinates deployment and sentinel configurations across multiple clusters.
//
// Agents in each cluster establish watch streams to receive configuration events
// from the control plane. The service provides separate streams for deployments and
// sentinels, each with independent version cursors. This allows the two control loops
// to operate independently with isolated failure domains.
//
// The watch connections are designed to be long-lived with automatic reconnection on failure.
// When an agent reconnects, it should resume from its last seen version for that resource type.
service ClusterService {
  // WatchDeployments streams deployment state changes from the control plane to agents.
  // Each deployment controller maintains its own version cursor for resumable streaming.
  // The agent applies received state to Kubernetes to converge actual state toward desired state.
  rpc WatchDeployments(WatchDeploymentsRequest) returns (stream DeploymentState);

  // WatchSentinels streams sentinel state changes from the control plane to agents.
  // Each sentinel controller maintains its own version cursor for resumable streaming.
  // The agent applies received state to Kubernetes to converge actual state toward desired state.
  rpc WatchSentinels(WatchSentinelsRequest) returns (stream SentinelState);

  // GetDesiredSentinelState returns the current desired state for a single sentinel.
  // Used by the resync loop to verify consistency for existing resources.
  rpc GetDesiredSentinelState(GetDesiredSentinelStateRequest) returns (SentinelState);

  // ReportSentinelStatus reports actual sentinel state from the agent to the control plane.
  // Called when K8s watch events indicate sentinel Deployment changes.
  rpc ReportSentinelStatus(ReportSentinelStatusRequest) returns (ReportSentinelStatusResponse);

  // GetDesiredDeploymentState returns the current desired state for a single deployment.
  // Used by the resync loop to verify consistency for existing resources.
  rpc GetDesiredDeploymentState(GetDesiredDeploymentStateRequest) returns (DeploymentState);

  // ReportDeploymentStatus reports actual deployment state from the agent to the control plane.
  // Called when K8s watch events indicate ReplicaSet changes.
  rpc ReportDeploymentStatus(ReportDeploymentStatusRequest) returns (ReportDeploymentStatusResponse);

  // WatchCiliumNetworkPolicies streams Cilium network policy state changes from the control plane.
  // Each cilium controller maintains its own version cursor for resumable streaming.
  rpc WatchCiliumNetworkPolicies(WatchCiliumNetworkPoliciesRequest) returns (stream CiliumNetworkPolicyState);

  // GetDesiredCiliumNetworkPolicyState returns the current desired state for a single Cilium policy.
  // Used by the resync loop to verify consistency for existing resources.
  rpc GetDesiredCiliumNetworkPolicyState(GetDesiredCiliumNetworkPolicyStateRequest) returns (CiliumNetworkPolicyState);
}

message WatchCiliumNetworkPoliciesRequest {
  string region = 1;
  uint64 version_last_seen = 2;
}

message ApplyCiliumNetworkPolicy {
  string k8s_namespace = 1;
  string k8s_name = 2;
  string cilium_network_policy_id = 3;
  bytes policy = 4;
}

message DeleteCiliumNetworkPolicy {
  string k8s_namespace = 1;
  string k8s_name = 2;
}
message CiliumNetworkPolicyState {
  uint64 version = 3;

  oneof state {
    ApplyCiliumNetworkPolicy apply = 1;

    DeleteCiliumNetworkPolicy delete = 2;
  }
}
message GetDesiredCiliumNetworkPolicyStateRequest {
  string cilium_network_policy_id = 1;
}

message GetDesiredSentinelStateRequest {
  string sentinel_id = 1;
}

message GetDesiredDeploymentStateRequest {
  string deployment_id = 1;
}

// ReportDeploymentStatusRequest reports the actual state of a deployment from the agent.
// Used by runActualStateReportLoop to inform the control plane of K8s cluster state.
message ReportDeploymentStatusRequest {
  message Update {
    message Instance {
      enum Status {
        STATUS_UNSPECIFIED = 0;
        STATUS_PENDING = 1; // Deployment request accepted, container/pod creation in progress
        STATUS_RUNNING = 2; // Container/pod is running and healthy
        STATUS_FAILED = 3; // Container/pod failed to start
      }
      string k8s_name = 1;
      string address = 2;
      int64 cpu_millicores = 3;
      int64 memory_mib = 4;
      Status status = 5;
    }

    string k8s_name = 1;
    repeated Instance instances = 2;
  }
  message Delete {
    string k8s_name = 1;
  }

  oneof change {
    Update update = 1;
    Delete delete = 2;
  }
}

message ReportDeploymentStatusResponse {}

// ReportSentinelStatusRequest reports the actual state of a sentinel from the agent.
// Used by runActualStateReportLoop to inform the control plane of K8s cluster state.
message ReportSentinelStatusRequest {
  string k8s_name = 1;
  int32 available_replicas = 2;
  Health health = 3;
}

message ReportSentinelStatusResponse {}

// WatchDeploymentsRequest initiates a stream of deployment state changes.
// The version_last_seen enables resumable streaming - the server will only send
// events newer than this version. Independent of the sentinel stream version.
message WatchDeploymentsRequest {
  string region = 1;
  uint64 version_last_seen = 2;
}

// WatchSentinelsRequest initiates a stream of sentinel state changes.
// The version_last_seen enables resumable streaming - the server will only send
// events newer than this version. Independent of the deployment stream version.
message WatchSentinelsRequest {
  string region = 1;
  uint64 version_last_seen = 2;
}

// SentinelState represents a lifecycle event for an API sentinel configuration.
//
// Sentinels are frontline points for services, typically handling routing, load balancing,
// and API management. The event follows a declarative model where the cluster agent ensures
// the cluster state matches the desired configuration.
message SentinelState {
  // version is the sentinel-specific resource version for this state update.
  // Clients should track the max version seen and use it when reconnecting to
  // the WatchSentinels stream to resume from the correct position.
  // When returned from GetDesiredSentinelState, this field is not set.
  uint64 version = 3;

  // state contains the specific sentinel operation to perform.
  // Only one state type is set per message, determining the action the agent should take.
  oneof state {
    // apply indicates the sentinel should exist with this configuration.
    // The agent will create the sentinel if it doesn't exist or update it if it does.
    // This follows the same semantics as "kubectl apply" - declare desired state
    // and let the agent determine the appropriate action.
    ApplySentinel apply = 1;

    // delete indicates the sentinel should be removed from the cluster.
    DeleteSentinel delete = 2;
  }
}

// DeploymentState represents a lifecycle event for an application deployment.
//
// Deployments are the primary workload type, representing stateless applications
// that can be scaled horizontally. The event follows a declarative model where
// the cluster agent ensures the cluster state matches the desired configuration.
message DeploymentState {
  // version is the deployment-specific resource version for this state update.
  // Clients should track the max version seen and use it when reconnecting to
  // the WatchDeployments stream to resume from the correct position.
  // When returned from GetDesiredDeploymentState, this field is not set.
  uint64 version = 3;

  // state contains the specific deployment operation to perform.
  // Only one state type is set per message, determining the action the agent should take.
  oneof state {
    // apply indicates the deployment should exist with this configuration.
    // The agent will create the deployment if it doesn't exist or update it if it does.
    // This follows the same semantics as "kubectl apply" - declare desired state
    // and let the agent determine the appropriate action.
    ApplyDeployment apply = 1;

    // delete indicates the deployment should be removed from the cluster.
    DeleteDeployment delete = 2;
  }
}

// ApplySentinel contains the desired configuration for a sentinel.
//
// The cluster agent will ensure a sentinel exists with this exact configuration, creating it if
// it doesn't exist or updating it if it does. All fields except namespace are required.
// The control plane ensures that sentinel_id is unique within the namespace.
message ApplySentinel {
  string k8s_name = 1;
  // workspace_id identifies the workspace that owns this sentinel.
  string workspace_id = 2;

  // project_id identifies the project within the workspace.
  string project_id = 3;

  // environment_id in which the sentinel should exist.
  string environment_id = 4;

  // sentinel_id is the unique identifier for this sentinel globally
  string sentinel_id = 5;

  string image = 6;
  int32 replicas = 7;
  int64 cpu_millicores = 8;
  int64 memory_mib = 9;
}

// DeleteSentinel identifies a sentinel to remove from the cluster.
//
// The sentinel and all its resources (pods, services, frontline) will be deleted.
// In-flight requests may be disrupted unless proper connection draining is configured.
message DeleteSentinel {
  string k8s_name = 1;
}

// ApplyDeployment contains the desired configuration for a deployment.
//
// The cluster agent will ensure a deployment exists with this exact configuration, creating it if
// it doesn't exist or updating it if it does. All fields except namespace are required.
// The control plane ensures that deployment_id is unique within the namespace.
message ApplyDeployment {
  // namespace is the Kubernetes namespace in which the deployment should exist.
  string k8s_namespace = 1;

  string k8s_name = 2;
  // workspace_id identifies the workspace that owns this deployment.
  // Used for multi-tenancy and access control.
  string workspace_id = 3;

  // project_id identifies the project within the workspace.
  // Deployments are scoped to projects for organizational purposes.
  string project_id = 4;

  // environment_id specifies the environment .
  // Used for environment-specific configuration and isolation.
  string environment_id = 5;

  // deployment_id is the unique identifier for this deployment within the namespace.
  string deployment_id = 6;

  // image is the container image to deploy.
  // Must be a valid container registry URL accessible by the cluster.
  // Example: "gcr.io/myproject/app:v2.1.0"
  string image = 7;

  // replicas is the desired number of pod instances.
  // Must be at least 1. Set higher for increased availability and load distribution.
  int32 replicas = 8;

  // cpu_millicores is the CPU request/limit in millicores (1000 = 1 CPU core).
  // This ensures each pod has sufficient CPU resources.
  // Example: 250 = 0.25 CPU cores
  int64 cpu_millicores = 9;

  // memory_mib is the memory request/limit in mebibytes.
  // This ensures each pod has sufficient memory.
  // Example: 256 = 256 MiB
  int64 memory_mib = 10;

  optional string build_id = 11;
  bytes encrypted_environment_variables = 12;

  // command is the container command override (e.g., ["./app", "serve"]).
  // If empty, the container's default entrypoint/cmd from the Dockerfile is used.
  repeated string command = 13;

  // port is the container port the application listens on.
  int32 port = 14;

  // restart_policy controls pod restart behavior: "always", "on-failure", or "never".
  string restart_policy = 15;

  // shutdown_signal is the signal sent to the container for graceful shutdown.
  // "SIGTERM", "SIGINT", "SIGQUIT", or "SIGKILL".
  string shutdown_signal = 16;

  // healthcheck is a JSON-encoded Healthcheck struct for configuring liveness/readiness probes.
  // If empty, no probes are configured.
  optional bytes healthcheck = 17;
}

// DeleteDeployment identifies a deployment to remove from the cluster.
//
// The deployment and all its pods will be terminated gracefully according to
// the configured termination grace period. All associated resources (services,
// configmaps specific to this deployment) will also be cleaned up.
message DeleteDeployment {
  string k8s_namespace = 1;
  string k8s_name = 2;
}
