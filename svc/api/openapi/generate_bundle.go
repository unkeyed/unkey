//go:build ignore

// generate_bundle.go bundles a split OpenAPI specification into a single file.
//
// This tool resolves all $ref references and inlines them into a single YAML file.
// It handles both file-based $refs (e.g., "./paths/keys.yaml") and internal $refs
// (e.g., "#/components/schemas/Key").
//
// Usage:
//
//	go run generate_bundle.go -input openapi-split.yaml -output openapi-generated.yaml
package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

var (
	input  = flag.String("input", "openapi-split.yaml", "Input OpenAPI file")
	output = flag.String("output", "openapi-generated.yaml", "Output bundled OpenAPI file")
)

func main() {
	flag.Parse()

	bundledSpec, err := bundleSpec(*input)
	if err != nil {
		log.Fatalf("Failed to bundle spec: %v", err)
	}

	header := fmt.Sprintf(`# Code generated by generate_bundle.go; DO NOT EDIT.
# Source: %s

`, *input)

	bundledYAML, err := yaml.Marshal(bundledSpec)
	if err != nil {
		log.Fatalf("Failed to marshal bundled spec: %v", err)
	}

	finalContent := append([]byte(header), bundledYAML...)

	if err := os.WriteFile(*output, finalContent, 0644); err != nil {
		log.Fatalf("Failed to write output file %s: %v", *output, err)
	}

	fmt.Printf("Successfully bundled OpenAPI spec to %s\n", *output)
}

// bundleSpec reads and bundles the OpenAPI specification
func bundleSpec(inputFile string) (map[string]any, error) {
	baseDir := filepath.Dir(inputFile)

	data, err := os.ReadFile(inputFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read input file: %w", err)
	}

	var spec map[string]any
	if err := yaml.Unmarshal(data, &spec); err != nil {
		return nil, fmt.Errorf("failed to parse yaml: %w", err)
	}

	// Resolve all file-based $refs recursively
	resolved, err := resolveRefs(spec, baseDir, make(map[string]bool))
	if err != nil {
		return nil, fmt.Errorf("failed to resolve refs: %w", err)
	}

	resolvedMap, ok := resolved.(map[string]any)
	if !ok {
		return nil, fmt.Errorf("expected map at root level")
	}

	return resolvedMap, nil
}

// resolveRefs recursively resolves all file-based $ref in the data structure
func resolveRefs(data any, baseDir string, visited map[string]bool) (any, error) {
	switch v := data.(type) {
	case map[string]any:
		// Check if this is a $ref to an external file
		if ref, ok := v["$ref"].(string); ok {
			if !strings.HasPrefix(ref, "#/") && !strings.HasPrefix(ref, "http") {
				// This is a file reference
				return resolveFileRef(ref, baseDir, visited)
			}
		}

		// Recursively process all values
		result := make(map[string]any)
		for key, value := range v {
			resolved, err := resolveRefs(value, baseDir, visited)
			if err != nil {
				return nil, err
			}
			result[key] = resolved
		}
		return result, nil

	case []any:
		result := make([]any, len(v))
		for i, item := range v {
			resolved, err := resolveRefs(item, baseDir, visited)
			if err != nil {
				return nil, err
			}
			result[i] = resolved
		}
		return result, nil

	default:
		return v, nil
	}
}

// resolveFileRef loads and resolves a file-based $ref
func resolveFileRef(ref, baseDir string, visited map[string]bool) (any, error) {
	// Construct full path
	fullPath := filepath.Join(baseDir, ref)
	fullPath = filepath.Clean(fullPath)

	// Check for circular references
	if visited[fullPath] {
		return nil, fmt.Errorf("circular reference detected: %s", fullPath)
	}
	visited[fullPath] = true
	defer delete(visited, fullPath)

	// Read the referenced file
	data, err := os.ReadFile(fullPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read ref %s: %w", ref, err)
	}

	var content any
	if err := yaml.Unmarshal(data, &content); err != nil {
		return nil, fmt.Errorf("failed to parse ref %s: %w", ref, err)
	}

	// Resolve any nested refs relative to the referenced file's directory
	refDir := filepath.Dir(fullPath)
	resolved, err := resolveRefs(content, refDir, visited)
	if err != nil {
		return nil, fmt.Errorf("failed to resolve nested refs in %s: %w", ref, err)
	}

	return resolved, nil
}
