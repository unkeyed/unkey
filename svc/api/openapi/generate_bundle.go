//go:build ignore

// generate_bundle.go bundles a split OpenAPI specification into a single file.
//
// This tool performs a single-pass traversal of the reference graph, following
// $ref chains from the entry point and only loading files that are actually referenced.
// It produces a bundled specification with all schemas collected in components/schemas/.
//
// Performance characteristics:
// - O(n) where n = number of referenced files (not total files)
// - Single pass through the reference graph
// - Lazy loading - files only loaded when referenced
// - Path cache - each file loaded at most once
// - No filesystem walks - follows refs only
//
// Usage:
//   go run generate_bundle.go -input openapi-split.yaml -output openapi-generated.yaml

package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

var (
	input  = flag.String("input", "openapi-split.yaml", "Input OpenAPI file")
	output = flag.String("output", "openapi-generated.yaml", "Output bundled OpenAPI file")
)

// Bundler handles the bundling of split OpenAPI specifications
type Bundler struct {
	baseDir    string
	schemas    map[string]any    // schemaName -> resolved schema
	pathToName map[string]string // absolute path -> schemaName (cache)
}

// NewBundler creates a new Bundler instance
func NewBundler(baseDir string) *Bundler {
	return &Bundler{
		baseDir:    baseDir,
		schemas:    make(map[string]any),
		pathToName: make(map[string]string),
	}
}

func main() {
	flag.Parse()

	baseDir := filepath.Dir(*input)
	bundler := NewBundler(baseDir)

	spec, err := bundler.bundle(*input)
	if err != nil {
		log.Fatalf("Failed to bundle: %v", err)
	}

	// Marshal to YAML
	bundledBytes, err := yaml.Marshal(spec)
	if err != nil {
		log.Fatalf("Failed to marshal bundled spec: %v", err)
	}

	// Add auto-generated comment header
	header := fmt.Sprintf(`# Code generated by generate_bundle.go; DO NOT EDIT.
# Source: %s

`, *input)

	// Prepend header to bundled content
	finalContent := append([]byte(header), bundledBytes...)

	err = os.WriteFile(*output, finalContent, 0644)
	if err != nil {
		log.Fatalf("Failed to write output file %s: %v", *output, err)
	}

	fmt.Printf("Successfully bundled OpenAPI spec to %s\n", *output)
	fmt.Printf("Collected %d schemas\n", len(bundler.schemas))
}

// bundle loads the entry spec and bundles all references
func (b *Bundler) bundle(inputFile string) (map[string]any, error) {
	// Load entry spec
	spec, err := loadYAML(inputFile)
	if err != nil {
		return nil, fmt.Errorf("failed to load entry spec: %w", err)
	}

	// Get the directory of the input file for resolving relative refs
	inputDir := filepath.Dir(inputFile)

	// Process paths - inline path refs, collect schema refs
	if paths, ok := spec["paths"].(map[string]any); ok {
		newPaths := make(map[string]any)
		for pathKey, pathVal := range paths {
			if pathMap, ok := pathVal.(map[string]any); ok {
				if ref, ok := pathMap["$ref"].(string); ok && len(pathMap) == 1 {
					// This is a path-level $ref - inline it
					resolved := b.resolveRef(ref, inputDir)
					newPaths[pathKey] = resolved
				} else {
					// No $ref or has other properties - resolve nested refs
					newPaths[pathKey] = b.resolveRefs(pathVal, inputDir)
				}
			} else {
				newPaths[pathKey] = b.resolveRefs(pathVal, inputDir)
			}
		}
		spec["paths"] = newPaths
	}

	// Build components with collected schemas
	components, ok := spec["components"].(map[string]any)
	if !ok {
		components = make(map[string]any)
		spec["components"] = components
	}

	// Add collected schemas to components
	if len(b.schemas) > 0 {
		components["schemas"] = b.schemas
	}

	return spec, nil
}

// resolveRef loads a file ref and processes it
// - For schema files: add to b.schemas, return internal $ref
// - For path files (index.yaml): inline content with resolved refs
func (b *Bundler) resolveRef(ref string, fromDir string) any {
	// Already an internal ref - return as-is
	if strings.HasPrefix(ref, "#/") {
		return map[string]any{"$ref": ref}
	}

	// Build absolute path
	absPath := filepath.Join(fromDir, ref)
	absPath = filepath.Clean(absPath)

	// Cache hit - return internal ref
	if name, ok := b.pathToName[absPath]; ok {
		return map[string]any{"$ref": "#/components/schemas/" + name}
	}

	// Load the file
	content, err := loadYAML(absPath)
	if err != nil {
		log.Printf("Warning: failed to load ref %s: %v", ref, err)
		return map[string]any{"$ref": ref}
	}

	// Determine if this is a schema file (not an index.yaml path file)
	if isSchemaFile(absPath) {
		name := schemaNameFromPath(absPath)
		b.pathToName[absPath] = name

		// Recursively resolve nested $refs in schema
		resolved := b.resolveRefs(content, filepath.Dir(absPath))
		b.schemas[name] = resolved

		return map[string]any{"$ref": "#/components/schemas/" + name}
	}

	// Path file (index.yaml) - inline with resolved refs
	return b.resolveRefs(content, filepath.Dir(absPath))
}

// resolveRefs recursively processes a data structure, resolving all $refs
func (b *Bundler) resolveRefs(data any, fromDir string) any {
	switch v := data.(type) {
	case map[string]any:
		// Check if this map contains a $ref
		if ref, ok := v["$ref"].(string); ok {
			if len(v) == 1 {
				// Pure $ref - resolve and return
				return b.resolveRef(ref, fromDir)
			}

			// $ref with siblings (OpenAPI 3.1 allows this)
			// Resolve the $ref and keep siblings
			result := make(map[string]any, len(v))
			for k, val := range v {
				if k == "$ref" {
					// Resolve this ref
					resolved := b.resolveRef(ref, fromDir)
					if resolvedMap, ok := resolved.(map[string]any); ok {
						if newRef, ok := resolvedMap["$ref"].(string); ok {
							result["$ref"] = newRef
						}
					}
				} else {
					// Process siblings recursively
					result[k] = b.resolveRefs(val, fromDir)
				}
			}
			return result
		}

		// No $ref - process all keys recursively
		result := make(map[string]any, len(v))
		for k, val := range v {
			result[k] = b.resolveRefs(val, fromDir)
		}
		return result

	case []any:
		result := make([]any, len(v))
		for i, item := range v {
			result[i] = b.resolveRefs(item, fromDir)
		}
		return result

	default:
		return v
	}
}

// loadYAML loads and parses a YAML file
func loadYAML(path string) (map[string]any, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var result map[string]any
	if err := yaml.Unmarshal(data, &result); err != nil {
		return nil, err
	}

	return result, nil
}

// isSchemaFile returns true if the file is a schema file (not index.yaml)
func isSchemaFile(path string) bool {
	return filepath.Base(path) != "index.yaml"
}

// schemaNameFromPath extracts the schema name from a file path
func schemaNameFromPath(path string) string {
	return strings.TrimSuffix(filepath.Base(path), ".yaml")
}
