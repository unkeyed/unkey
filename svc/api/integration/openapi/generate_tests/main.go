//go:generate go run main.go

package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

// TestEndpoint represents an endpoint to generate a test for
type TestEndpoint struct {
	Path         string // e.g., "/v2/apis.createApi"
	Method       string // e.g., "POST"
	OperationID  string // e.g., "createApi"
	PackageName  string // e.g., "apis_createApi"
	TestName     string // e.g., "TestOpenAPI_ApisCreateApi"
	RoutePackage string // e.g., "//svc/api/routes/v2_apis_create_api"
}

// OpenAPISpec represents the structure we need from the spec
type OpenAPISpec struct {
	Paths map[string]map[string]struct {
		OperationID string `yaml:"operationId"`
	} `yaml:"paths"`
}

const testTemplate = `// Code generated by go generate; DO NOT EDIT.
package {{ .PackageName }}

import (
	"testing"

	run "github.com/unkeyed/unkey/svc/api/integration/openapi"
)

func {{ .TestName }}(t *testing.T) {
	run.RunSchemathesis(t, "{{ .Path }}")
}
`

// BUILD template uses data attribute instead of deps for route dependency.
// The # keep comment prevents gazelle from removing the route dependency.
// The unkey binary is included as a runtime dependency for subprocess execution.
const buildTemplate = `load("@rules_go//go:def.bzl", "go_test")

go_test(
    name = "{{ .PackageName }}_test",
    srcs = ["generated_test.go"],
    tags = ["docker"],
    data = [
        "//:unkey",  # Unkey binary for subprocess execution (runs: unkey run api)
        "{{ .RoutePackage }}",  # keep - Route handler dependency for Bazel invalidation
    ],
    deps = ["//svc/api/integration/openapi"],
)
`

func main() {
	// Find and parse the OpenAPI spec
	specPath := findSpecPath()
	endpoints, err := parseOpenAPISpec(specPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to parse OpenAPI spec: %v\n", err)
		os.Exit(1)
	}

	// Create base directory for generated tests
	baseDir := "../generated"
	if err := os.RemoveAll(baseDir); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to clean generated directory: %v\n", err)
		os.Exit(1)
	}
	if err := os.MkdirAll(baseDir, 0o755); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create generated directory: %v\n", err)
		os.Exit(1)
	}

	// Parse templates
	testTmpl, err := template.New("test").Parse(testTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to parse test template: %v\n", err)
		os.Exit(1)
	}

	buildTmpl, err := template.New("build").Parse(buildTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to parse build template: %v\n", err)
		os.Exit(1)
	}

	// Generate test files for each endpoint
	for _, endpoint := range endpoints {
		packageDir := filepath.Join(baseDir, endpoint.PackageName)
		if err := os.MkdirAll(packageDir, 0o755); err != nil {
			fmt.Fprintf(os.Stderr, "Failed to create package directory %s: %v\n", packageDir, err)
			os.Exit(1)
		}

		// Generate test file
		testFile := filepath.Join(packageDir, "generated_test.go")
		if err := writeTemplate(testFile, testTmpl, endpoint); err != nil {
			fmt.Fprintf(os.Stderr, "Failed to write test file %s: %v\n", testFile, err)
			os.Exit(1)
		}

		// Generate BUILD.bazel
		buildFile := filepath.Join(packageDir, "BUILD.bazel")
		if err := writeTemplate(buildFile, buildTmpl, endpoint); err != nil {
			fmt.Fprintf(os.Stderr, "Failed to write BUILD file %s: %v\n", buildFile, err)
			os.Exit(1)
		}
	}

	fmt.Printf("Generated %d OpenAPI endpoint tests\n", len(endpoints))
}

func writeTemplate(filePath string, tmpl *template.Template, data any) error {
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, data)
}

func findSpecPath() string {
	// Try different relative paths
	paths := []string{
		"../../../openapi/openapi-generated.yaml",
		"../../../../svc/api/openapi/openapi-generated.yaml",
		"svc/api/openapi/openapi-generated.yaml",
	}

	for _, p := range paths {
		if _, err := os.Stat(p); err == nil {
			return p
		}
	}

	// Default to workspace-relative path
	return "../../../openapi/openapi-generated.yaml"
}

func parseOpenAPISpec(specPath string) ([]TestEndpoint, error) {
	data, err := os.ReadFile(specPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read spec file: %w", err)
	}

	var spec OpenAPISpec
	if err := yaml.Unmarshal(data, &spec); err != nil {
		return nil, fmt.Errorf("failed to parse YAML: %w", err)
	}

	var endpoints []TestEndpoint

	for path, methods := range spec.Paths {
		// Skip internal endpoints
		if strings.HasPrefix(path, "/_internal") {
			continue
		}

		for method, opInfo := range methods {
			// Skip non-HTTP methods (like parameters, servers, etc.)
			method = strings.ToUpper(method)
			if method != "GET" && method != "POST" && method != "PUT" &&
				method != "DELETE" && method != "PATCH" && method != "HEAD" && method != "OPTIONS" {
				continue
			}

			operationID := opInfo.OperationID
			if operationID == "" {
				// Generate from path
				operationID = strings.ReplaceAll(strings.TrimPrefix(path, "/v2/"), ".", "_")
			}

			packageName := generatePackageName(path)
			testName := generateTestName(path)
			routePackage := generateRoutePackage(path)

			endpoints = append(endpoints, TestEndpoint{
				Path:         path,
				Method:       method,
				OperationID:  operationID,
				PackageName:  packageName,
				TestName:     testName,
				RoutePackage: routePackage,
			})
		}
	}

	return endpoints, nil
}

func generatePackageName(path string) string {
	// /v2/apis.createApi -> apis_createApi
	name := strings.TrimPrefix(path, "/v2/")
	name = strings.ReplaceAll(name, ".", "_")
	name = strings.ReplaceAll(name, "/", "_")
	return name
}

func generateTestName(path string) string {
	// /v2/apis.createApi -> TestOpenAPI_ApisCreateApi
	name := strings.TrimPrefix(path, "/v2/")
	name = strings.ReplaceAll(name, ".", "_")
	name = strings.ReplaceAll(name, "/", "_")

	// Convert to PascalCase
	parts := strings.Split(name, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}

	return "TestOpenAPI_" + strings.Join(parts, "")
}

func generateRoutePackage(path string) string {
	// /v2/apis.createApi -> //svc/api/routes/v2_apis_create_api
	// /v2/liveness -> //svc/api/routes/v2_liveness

	// Remove leading slash
	name := strings.TrimPrefix(path, "/")

	// Replace dots with underscores: v2/apis.createApi -> v2/apis_createApi
	name = strings.ReplaceAll(name, ".", "_")

	// Replace slashes with underscores: v2/apis_createApi -> v2_apis_createApi
	name = strings.ReplaceAll(name, "/", "_")

	// Convert camelCase to snake_case
	name = camelToSnake(name)

	return "//svc/api/routes/" + name
}

func camelToSnake(s string) string {
	var result strings.Builder
	for i, r := range s {
		if r >= 'A' && r <= 'Z' {
			// Don't add underscore at the start or after an underscore
			if i > 0 && s[i-1] != '_' {
				result.WriteByte('_')
			}
			result.WriteRune(r + 32) // Convert to lowercase
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}
