// Package fuzz provides utilities for consuming fuzzer-generated byte slices
// and converting them into typed Go values.
//
// This package is designed for use with Go's native fuzzing (testing.F) to simplify
// the process of generating structured test data from raw fuzzer input. Instead of
// manually slicing bytes and handling bounds checks, you can extract typed values
// directly.
//
// The package automatically calls t.Skip() when the fuzzer-provided input is
// exhausted, ensuring that all generated values are derived from fuzzer-controlled
// bytes. This maintains the integrity of coverage-guided fuzzing - the fuzzer
// retains full control over all randomness.
//
// # Key Types
//
// The main entry point is [Consumer], created via [New]. Extraction methods are
// called on the Consumer: c.String(), c.Int(), c.Bytes(), etc. Generic functions
// [Slice] and [Struct] are also available for typed slices and struct population.
//
// # Usage
//
// Basic value extraction:
//
//	func FuzzMyFunction(f *testing.F) {
//	    fuzz.Seed(f) // Add deterministic seed corpus
//
//	    f.Fuzz(func(t *testing.T, data []byte) {
//	        c := fuzz.New(t, data)
//
//	        name := c.String()
//	        count := c.Int()
//	        flags := fuzz.Slice[bool](c)
//
//	        // If we reach here, all values are valid
//	        MyFunction(name, count, flags)
//	    })
//	}
//
// Struct generation:
//
//	type Config struct {
//	    Name    string
//	    Timeout int
//	    Enabled bool
//	}
//
//	func FuzzWithConfig(f *testing.F) {
//	    fuzz.Seed(f)
//
//	    f.Fuzz(func(t *testing.T, data []byte) {
//	        c := fuzz.New(t, data)
//	        cfg := fuzz.Struct[Config](c)
//
//	        // Test with fully populated struct
//	        Process(cfg)
//	    })
//	}
//
// # Design Rationale
//
// The package skips tests when input is exhausted rather than falling back to
// a PRNG. While this means short inputs produce no test coverage, it ensures
// that the fuzzer can discover all interesting values through input mutation.
// A PRNG fallback would make some values "invisible" to the coverage-guided
// fuzzer, potentially missing bugs that only trigger on specific values.
package fuzz
