// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cluster_state_versions.sql

package db

import (
	"context"
)

const listClusterStateVersions = `-- name: ListClusterStateVersions :many
SELECT combined.version, combined.kind FROM (
    SELECT dt.version, 'deployment' AS kind
    FROM ` + "`" + `deployment_topology` + "`" + ` dt
    WHERE dt.region = ?
        AND dt.version > ?
    UNION ALL
    SELECT s.version, 'sentinel' AS kind
    FROM ` + "`" + `sentinels` + "`" + ` s
    WHERE s.region = ?
        AND s.version > ?
) AS combined
ORDER BY combined.version ASC
LIMIT ?
`

type ListClusterStateVersionsParams struct {
	Region       string `db:"region"`
	AfterVersion uint64 `db:"after_version"`
	Limit        int32  `db:"limit"`
}

type ListClusterStateVersionsRow struct {
	Version uint64 `db:"version"`
	Kind    string `db:"kind"`
}

// ListClusterStateVersions returns the next N (version, kind) pairs in global version order.
// Used to determine which resources to fetch for sync, without loading full row data.
// The 'kind' discriminator is 'deployment' or 'sentinel'.
//
//	SELECT combined.version, combined.kind FROM (
//	    SELECT dt.version, 'deployment' AS kind
//	    FROM `deployment_topology` dt
//	    WHERE dt.region = ?
//	        AND dt.version > ?
//	    UNION ALL
//	    SELECT s.version, 'sentinel' AS kind
//	    FROM `sentinels` s
//	    WHERE s.region = ?
//	        AND s.version > ?
//	) AS combined
//	ORDER BY combined.version ASC
//	LIMIT ?
func (q *Queries) ListClusterStateVersions(ctx context.Context, db DBTX, arg ListClusterStateVersionsParams) ([]ListClusterStateVersionsRow, error) {
	rows, err := db.QueryContext(ctx, listClusterStateVersions,
		arg.Region,
		arg.AfterVersion,
		arg.Region,
		arg.AfterVersion,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListClusterStateVersionsRow
	for rows.Next() {
		var i ListClusterStateVersionsRow
		if err := rows.Scan(&i.Version, &i.Kind); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
