// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: deployment_topology_find_by_versions.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const findDeploymentTopologyByVersions = `-- name: FindDeploymentTopologyByVersions :many
SELECT
    dt.pk, dt.workspace_id, dt.deployment_id, dt.region, dt.desired_replicas, dt.version, dt.desired_status, dt.created_at, dt.updated_at,
    d.pk, d.id, d.k8s_name, d.workspace_id, d.project_id, d.environment_id, d.image, d.build_id, d.git_commit_sha, d.git_branch, d.git_commit_message, d.git_commit_author_handle, d.git_commit_author_avatar_url, d.git_commit_timestamp, d.sentinel_config, d.openapi_spec, d.cpu_millicores, d.memory_mib, d.desired_state, d.encrypted_environment_variables, d.status, d.created_at, d.updated_at,
    w.k8s_namespace
FROM ` + "`" + `deployment_topology` + "`" + ` dt
INNER JOIN ` + "`" + `deployments` + "`" + ` d ON dt.deployment_id = d.id
INNER JOIN ` + "`" + `workspaces` + "`" + ` w ON d.workspace_id = w.id
WHERE dt.version IN (/*SLICE:versions*/?)
`

type FindDeploymentTopologyByVersionsRow struct {
	DeploymentTopology DeploymentTopology `db:"deployment_topology"`
	Deployment         Deployment         `db:"deployment"`
	K8sNamespace       sql.NullString     `db:"k8s_namespace"`
}

// FindDeploymentTopologyByVersions returns deployment topologies for specific versions.
// Used after ListClusterStateVersions to hydrate the full deployment data.
//
//	SELECT
//	    dt.pk, dt.workspace_id, dt.deployment_id, dt.region, dt.desired_replicas, dt.version, dt.desired_status, dt.created_at, dt.updated_at,
//	    d.pk, d.id, d.k8s_name, d.workspace_id, d.project_id, d.environment_id, d.image, d.build_id, d.git_commit_sha, d.git_branch, d.git_commit_message, d.git_commit_author_handle, d.git_commit_author_avatar_url, d.git_commit_timestamp, d.sentinel_config, d.openapi_spec, d.cpu_millicores, d.memory_mib, d.desired_state, d.encrypted_environment_variables, d.status, d.created_at, d.updated_at,
//	    w.k8s_namespace
//	FROM `deployment_topology` dt
//	INNER JOIN `deployments` d ON dt.deployment_id = d.id
//	INNER JOIN `workspaces` w ON d.workspace_id = w.id
//	WHERE dt.version IN (/*SLICE:versions*/?)
func (q *Queries) FindDeploymentTopologyByVersions(ctx context.Context, db DBTX, versions []uint64) ([]FindDeploymentTopologyByVersionsRow, error) {
	query := findDeploymentTopologyByVersions
	var queryParams []interface{}
	if len(versions) > 0 {
		for _, v := range versions {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:versions*/?", strings.Repeat(",?", len(versions))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:versions*/?", "NULL", 1)
	}
	rows, err := db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindDeploymentTopologyByVersionsRow
	for rows.Next() {
		var i FindDeploymentTopologyByVersionsRow
		if err := rows.Scan(
			&i.DeploymentTopology.Pk,
			&i.DeploymentTopology.WorkspaceID,
			&i.DeploymentTopology.DeploymentID,
			&i.DeploymentTopology.Region,
			&i.DeploymentTopology.DesiredReplicas,
			&i.DeploymentTopology.Version,
			&i.DeploymentTopology.DesiredStatus,
			&i.DeploymentTopology.CreatedAt,
			&i.DeploymentTopology.UpdatedAt,
			&i.Deployment.Pk,
			&i.Deployment.ID,
			&i.Deployment.K8sName,
			&i.Deployment.WorkspaceID,
			&i.Deployment.ProjectID,
			&i.Deployment.EnvironmentID,
			&i.Deployment.Image,
			&i.Deployment.BuildID,
			&i.Deployment.GitCommitSha,
			&i.Deployment.GitBranch,
			&i.Deployment.GitCommitMessage,
			&i.Deployment.GitCommitAuthorHandle,
			&i.Deployment.GitCommitAuthorAvatarUrl,
			&i.Deployment.GitCommitTimestamp,
			&i.Deployment.SentinelConfig,
			&i.Deployment.OpenapiSpec,
			&i.Deployment.CpuMillicores,
			&i.Deployment.MemoryMib,
			&i.Deployment.DesiredState,
			&i.Deployment.EncryptedEnvironmentVariables,
			&i.Deployment.Status,
			&i.Deployment.CreatedAt,
			&i.Deployment.UpdatedAt,
			&i.K8sNamespace,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
