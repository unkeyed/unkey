// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: deployment_topology_find_by_versions.sql

package db

import (
	"context"
	"database/sql"
)

const listDeploymentTopologyByRegion = `-- name: ListDeploymentTopologyByRegion :many
SELECT
    dt.pk, dt.workspace_id, dt.deployment_id, dt.region, dt.desired_replicas, dt.version, dt.desired_status, dt.created_at, dt.updated_at,
    d.pk, d.id, d.k8s_name, d.workspace_id, d.project_id, d.environment_id, d.image, d.build_id, d.git_commit_sha, d.git_branch, d.git_commit_message, d.git_commit_author_handle, d.git_commit_author_avatar_url, d.git_commit_timestamp, d.sentinel_config, d.openapi_spec, d.cpu_millicores, d.memory_mib, d.desired_state, d.encrypted_environment_variables, d.command, d.status, d.created_at, d.updated_at,
    w.k8s_namespace
FROM ` + "`" + `deployment_topology` + "`" + ` dt
INNER JOIN ` + "`" + `deployments` + "`" + ` d ON dt.deployment_id = d.id
INNER JOIN ` + "`" + `workspaces` + "`" + ` w ON d.workspace_id = w.id
WHERE dt.region = ? AND dt.version > ?
ORDER BY dt.version ASC
LIMIT ?
`

type ListDeploymentTopologyByRegionParams struct {
	Region       string `db:"region"`
	Afterversion uint64 `db:"afterversion"`
	Limit        int32  `db:"limit"`
}

type ListDeploymentTopologyByRegionRow struct {
	DeploymentTopology DeploymentTopology `db:"deployment_topology"`
	Deployment         Deployment         `db:"deployment"`
	K8sNamespace       sql.NullString     `db:"k8s_namespace"`
}

// ListDeploymentTopologyByRegion returns deployment topologies for a region with version > after_version.
// Used by WatchDeployments to stream deployment state changes to krane agents.
//
//	SELECT
//	    dt.pk, dt.workspace_id, dt.deployment_id, dt.region, dt.desired_replicas, dt.version, dt.desired_status, dt.created_at, dt.updated_at,
//	    d.pk, d.id, d.k8s_name, d.workspace_id, d.project_id, d.environment_id, d.image, d.build_id, d.git_commit_sha, d.git_branch, d.git_commit_message, d.git_commit_author_handle, d.git_commit_author_avatar_url, d.git_commit_timestamp, d.sentinel_config, d.openapi_spec, d.cpu_millicores, d.memory_mib, d.desired_state, d.encrypted_environment_variables, d.command, d.status, d.created_at, d.updated_at,
//	    w.k8s_namespace
//	FROM `deployment_topology` dt
//	INNER JOIN `deployments` d ON dt.deployment_id = d.id
//	INNER JOIN `workspaces` w ON d.workspace_id = w.id
//	WHERE dt.region = ? AND dt.version > ?
//	ORDER BY dt.version ASC
//	LIMIT ?
func (q *Queries) ListDeploymentTopologyByRegion(ctx context.Context, db DBTX, arg ListDeploymentTopologyByRegionParams) ([]ListDeploymentTopologyByRegionRow, error) {
	rows, err := db.QueryContext(ctx, listDeploymentTopologyByRegion, arg.Region, arg.Afterversion, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeploymentTopologyByRegionRow
	for rows.Next() {
		var i ListDeploymentTopologyByRegionRow
		if err := rows.Scan(
			&i.DeploymentTopology.Pk,
			&i.DeploymentTopology.WorkspaceID,
			&i.DeploymentTopology.DeploymentID,
			&i.DeploymentTopology.Region,
			&i.DeploymentTopology.DesiredReplicas,
			&i.DeploymentTopology.Version,
			&i.DeploymentTopology.DesiredStatus,
			&i.DeploymentTopology.CreatedAt,
			&i.DeploymentTopology.UpdatedAt,
			&i.Deployment.Pk,
			&i.Deployment.ID,
			&i.Deployment.K8sName,
			&i.Deployment.WorkspaceID,
			&i.Deployment.ProjectID,
			&i.Deployment.EnvironmentID,
			&i.Deployment.Image,
			&i.Deployment.BuildID,
			&i.Deployment.GitCommitSha,
			&i.Deployment.GitBranch,
			&i.Deployment.GitCommitMessage,
			&i.Deployment.GitCommitAuthorHandle,
			&i.Deployment.GitCommitAuthorAvatarUrl,
			&i.Deployment.GitCommitTimestamp,
			&i.Deployment.SentinelConfig,
			&i.Deployment.OpenapiSpec,
			&i.Deployment.CpuMillicores,
			&i.Deployment.MemoryMib,
			&i.Deployment.DesiredState,
			&i.Deployment.EncryptedEnvironmentVariables,
			&i.Deployment.Command,
			&i.Deployment.Status,
			&i.Deployment.CreatedAt,
			&i.Deployment.UpdatedAt,
			&i.K8sNamespace,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
