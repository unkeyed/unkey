// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: state_change_find_by_region_after_sequence.sql

package db

import (
	"context"
)

const listStateChanges = `-- name: ListStateChanges :many
SELECT sequence, resource_type, resource_id, op
FROM ` + "`" + `state_changes` + "`" + `
WHERE region = ?
  AND sequence > ?
  AND created_at < (UNIX_TIMESTAMP() * 1000) - 1000
ORDER BY sequence ASC
LIMIT ?
`

type ListStateChangesParams struct {
	Region        string `db:"region"`
	AfterSequence uint64 `db:"after_sequence"`
	Limit         int32  `db:"limit"`
}

type ListStateChangesRow struct {
	Sequence     uint64                   `db:"sequence"`
	ResourceType StateChangesResourceType `db:"resource_type"`
	ResourceID   string                   `db:"resource_id"`
	Op           StateChangesOp           `db:"op"`
}

// Returns state changes for watch loop. Includes 1-second visibility delay
// to handle AUTO_INCREMENT gaps where sequence N+1 commits before N.
// Clients filter by their region when fetching the actual resource.
//
//	SELECT sequence, resource_type, resource_id, op
//	FROM `state_changes`
//	WHERE region = ?
//	  AND sequence > ?
//	  AND created_at < (UNIX_TIMESTAMP() * 1000) - 1000
//	ORDER BY sequence ASC
//	LIMIT ?
func (q *Queries) ListStateChanges(ctx context.Context, db DBTX, arg ListStateChangesParams) ([]ListStateChangesRow, error) {
	rows, err := db.QueryContext(ctx, listStateChanges, arg.Region, arg.AfterSequence, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListStateChangesRow
	for rows.Next() {
		var i ListStateChangesRow
		if err := rows.Scan(
			&i.Sequence,
			&i.ResourceType,
			&i.ResourceID,
			&i.Op,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
