// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: billing.sql

package db

import (
	"context"
	"database/sql"
)

const billingEndUserFindByExternalId = `-- name: BillingEndUserFindByExternalId :one
SELECT id, workspace_id, external_id, pricing_model_id, stripe_customer_id, stripe_subscription_id, email, name, metadata, created_at_m, updated_at_m, deleted_at_m FROM billing_end_users
WHERE workspace_id = ? AND external_id = ? AND deleted_at_m IS NULL
LIMIT 1
`

type BillingEndUserFindByExternalIdParams struct {
	WorkspaceID string `db:"workspace_id"`
	ExternalID  string `db:"external_id"`
}

// BillingEndUserFindByExternalId
//
//	SELECT id, workspace_id, external_id, pricing_model_id, stripe_customer_id, stripe_subscription_id, email, name, metadata, created_at_m, updated_at_m, deleted_at_m FROM billing_end_users
//	WHERE workspace_id = ? AND external_id = ? AND deleted_at_m IS NULL
//	LIMIT 1
func (q *Queries) BillingEndUserFindByExternalId(ctx context.Context, db DBTX, arg BillingEndUserFindByExternalIdParams) (BillingEndUser, error) {
	row := db.QueryRowContext(ctx, billingEndUserFindByExternalId, arg.WorkspaceID, arg.ExternalID)
	var i BillingEndUser
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ExternalID,
		&i.PricingModelID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.Email,
		&i.Name,
		&i.Metadata,
		&i.CreatedAtM,
		&i.UpdatedAtM,
		&i.DeletedAtM,
	)
	return i, err
}

const billingEndUserFindById = `-- name: BillingEndUserFindById :one
SELECT id, workspace_id, external_id, pricing_model_id, stripe_customer_id, stripe_subscription_id, email, name, metadata, created_at_m, updated_at_m, deleted_at_m FROM billing_end_users
WHERE id = ? AND deleted_at_m IS NULL
LIMIT 1
`

// BillingEndUserFindById
//
//	SELECT id, workspace_id, external_id, pricing_model_id, stripe_customer_id, stripe_subscription_id, email, name, metadata, created_at_m, updated_at_m, deleted_at_m FROM billing_end_users
//	WHERE id = ? AND deleted_at_m IS NULL
//	LIMIT 1
func (q *Queries) BillingEndUserFindById(ctx context.Context, db DBTX, id string) (BillingEndUser, error) {
	row := db.QueryRowContext(ctx, billingEndUserFindById, id)
	var i BillingEndUser
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ExternalID,
		&i.PricingModelID,
		&i.StripeCustomerID,
		&i.StripeSubscriptionID,
		&i.Email,
		&i.Name,
		&i.Metadata,
		&i.CreatedAtM,
		&i.UpdatedAtM,
		&i.DeletedAtM,
	)
	return i, err
}

const billingEndUserInsert = `-- name: BillingEndUserInsert :exec
INSERT INTO billing_end_users (
  id,
  workspace_id,
  external_id,
  pricing_model_id,
  stripe_customer_id,
  stripe_subscription_id,
  email,
  name,
  metadata,
  created_at_m
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type BillingEndUserInsertParams struct {
	ID                   string         `db:"id"`
	WorkspaceID          string         `db:"workspace_id"`
	ExternalID           string         `db:"external_id"`
	PricingModelID       string         `db:"pricing_model_id"`
	StripeCustomerID     string         `db:"stripe_customer_id"`
	StripeSubscriptionID sql.NullString `db:"stripe_subscription_id"`
	Email                sql.NullString `db:"email"`
	Name                 sql.NullString `db:"name"`
	Metadata             []byte         `db:"metadata"`
	CreatedAtM           int64          `db:"created_at_m"`
}

// BillingEndUserInsert
//
//	INSERT INTO billing_end_users (
//	  id,
//	  workspace_id,
//	  external_id,
//	  pricing_model_id,
//	  stripe_customer_id,
//	  stripe_subscription_id,
//	  email,
//	  name,
//	  metadata,
//	  created_at_m
//	) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
func (q *Queries) BillingEndUserInsert(ctx context.Context, db DBTX, arg BillingEndUserInsertParams) error {
	_, err := db.ExecContext(ctx, billingEndUserInsert,
		arg.ID,
		arg.WorkspaceID,
		arg.ExternalID,
		arg.PricingModelID,
		arg.StripeCustomerID,
		arg.StripeSubscriptionID,
		arg.Email,
		arg.Name,
		arg.Metadata,
		arg.CreatedAtM,
	)
	return err
}

const billingEndUserListByWorkspaceId = `-- name: BillingEndUserListByWorkspaceId :many
SELECT id, workspace_id, external_id, pricing_model_id, stripe_customer_id, stripe_subscription_id, email, name, metadata, created_at_m, updated_at_m, deleted_at_m FROM billing_end_users
WHERE workspace_id = ? AND deleted_at_m IS NULL
ORDER BY created_at_m DESC
`

// BillingEndUserListByWorkspaceId
//
//	SELECT id, workspace_id, external_id, pricing_model_id, stripe_customer_id, stripe_subscription_id, email, name, metadata, created_at_m, updated_at_m, deleted_at_m FROM billing_end_users
//	WHERE workspace_id = ? AND deleted_at_m IS NULL
//	ORDER BY created_at_m DESC
func (q *Queries) BillingEndUserListByWorkspaceId(ctx context.Context, db DBTX, workspaceID string) ([]BillingEndUser, error) {
	rows, err := db.QueryContext(ctx, billingEndUserListByWorkspaceId, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingEndUser
	for rows.Next() {
		var i BillingEndUser
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ExternalID,
			&i.PricingModelID,
			&i.StripeCustomerID,
			&i.StripeSubscriptionID,
			&i.Email,
			&i.Name,
			&i.Metadata,
			&i.CreatedAtM,
			&i.UpdatedAtM,
			&i.DeletedAtM,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingEndUserUpdate = `-- name: BillingEndUserUpdate :exec
UPDATE billing_end_users
SET 
  pricing_model_id = ?,
  stripe_subscription_id = ?,
  email = ?,
  name = ?,
  metadata = ?,
  updated_at_m = ?
WHERE id = ?
`

type BillingEndUserUpdateParams struct {
	PricingModelID       string         `db:"pricing_model_id"`
	StripeSubscriptionID sql.NullString `db:"stripe_subscription_id"`
	Email                sql.NullString `db:"email"`
	Name                 sql.NullString `db:"name"`
	Metadata             []byte         `db:"metadata"`
	UpdatedAtM           sql.NullInt64  `db:"updated_at_m"`
	ID                   string         `db:"id"`
}

// BillingEndUserUpdate
//
//	UPDATE billing_end_users
//	SET
//	  pricing_model_id = ?,
//	  stripe_subscription_id = ?,
//	  email = ?,
//	  name = ?,
//	  metadata = ?,
//	  updated_at_m = ?
//	WHERE id = ?
func (q *Queries) BillingEndUserUpdate(ctx context.Context, db DBTX, arg BillingEndUserUpdateParams) error {
	_, err := db.ExecContext(ctx, billingEndUserUpdate,
		arg.PricingModelID,
		arg.StripeSubscriptionID,
		arg.Email,
		arg.Name,
		arg.Metadata,
		arg.UpdatedAtM,
		arg.ID,
	)
	return err
}

const billingInvoiceFindById = `-- name: BillingInvoiceFindById :one
SELECT id, workspace_id, end_user_id, stripe_invoice_id, billing_period_start, billing_period_end, verification_count, ratelimit_count, key_access_count, credits_used, total_amount, currency, status, created_at_m, updated_at_m, deleted_at_m FROM billing_invoices
WHERE id = ?
LIMIT 1
`

// BillingInvoiceFindById
//
//	SELECT id, workspace_id, end_user_id, stripe_invoice_id, billing_period_start, billing_period_end, verification_count, ratelimit_count, key_access_count, credits_used, total_amount, currency, status, created_at_m, updated_at_m, deleted_at_m FROM billing_invoices
//	WHERE id = ?
//	LIMIT 1
func (q *Queries) BillingInvoiceFindById(ctx context.Context, db DBTX, id string) (BillingInvoice, error) {
	row := db.QueryRowContext(ctx, billingInvoiceFindById, id)
	var i BillingInvoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.EndUserID,
		&i.StripeInvoiceID,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.VerificationCount,
		&i.RatelimitCount,
		&i.KeyAccessCount,
		&i.CreditsUsed,
		&i.TotalAmount,
		&i.Currency,
		&i.Status,
		&i.CreatedAtM,
		&i.UpdatedAtM,
		&i.DeletedAtM,
	)
	return i, err
}

const billingInvoiceFindByStripeInvoiceId = `-- name: BillingInvoiceFindByStripeInvoiceId :one
SELECT id, workspace_id, end_user_id, stripe_invoice_id, billing_period_start, billing_period_end, verification_count, ratelimit_count, key_access_count, credits_used, total_amount, currency, status, created_at_m, updated_at_m, deleted_at_m FROM billing_invoices
WHERE stripe_invoice_id = ?
LIMIT 1
`

// BillingInvoiceFindByStripeInvoiceId
//
//	SELECT id, workspace_id, end_user_id, stripe_invoice_id, billing_period_start, billing_period_end, verification_count, ratelimit_count, key_access_count, credits_used, total_amount, currency, status, created_at_m, updated_at_m, deleted_at_m FROM billing_invoices
//	WHERE stripe_invoice_id = ?
//	LIMIT 1
func (q *Queries) BillingInvoiceFindByStripeInvoiceId(ctx context.Context, db DBTX, stripeInvoiceID string) (BillingInvoice, error) {
	row := db.QueryRowContext(ctx, billingInvoiceFindByStripeInvoiceId, stripeInvoiceID)
	var i BillingInvoice
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.EndUserID,
		&i.StripeInvoiceID,
		&i.BillingPeriodStart,
		&i.BillingPeriodEnd,
		&i.VerificationCount,
		&i.RatelimitCount,
		&i.KeyAccessCount,
		&i.CreditsUsed,
		&i.TotalAmount,
		&i.Currency,
		&i.Status,
		&i.CreatedAtM,
		&i.UpdatedAtM,
		&i.DeletedAtM,
	)
	return i, err
}

const billingInvoiceInsert = `-- name: BillingInvoiceInsert :exec
INSERT INTO billing_invoices (
  id,
  workspace_id,
  end_user_id,
  stripe_invoice_id,
  billing_period_start,
  billing_period_end,
  verification_count,
  key_access_count,
  credits_used,
  total_amount,
  currency,
  status,
  created_at_m
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type BillingInvoiceInsertParams struct {
	ID                 string `db:"id"`
	WorkspaceID        string `db:"workspace_id"`
	EndUserID          string `db:"end_user_id"`
	StripeInvoiceID    string `db:"stripe_invoice_id"`
	BillingPeriodStart int64  `db:"billing_period_start"`
	BillingPeriodEnd   int64  `db:"billing_period_end"`
	VerificationCount  int64  `db:"verification_count"`
	KeyAccessCount     int64  `db:"key_access_count"`
	CreditsUsed        int64  `db:"credits_used"`
	TotalAmount        int64  `db:"total_amount"`
	Currency           string `db:"currency"`
	Status             string `db:"status"`
	CreatedAtM         int64  `db:"created_at_m"`
}

// BillingInvoiceInsert
//
//	INSERT INTO billing_invoices (
//	  id,
//	  workspace_id,
//	  end_user_id,
//	  stripe_invoice_id,
//	  billing_period_start,
//	  billing_period_end,
//	  verification_count,
//	  key_access_count,
//	  credits_used,
//	  total_amount,
//	  currency,
//	  status,
//	  created_at_m
//	) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
func (q *Queries) BillingInvoiceInsert(ctx context.Context, db DBTX, arg BillingInvoiceInsertParams) error {
	_, err := db.ExecContext(ctx, billingInvoiceInsert,
		arg.ID,
		arg.WorkspaceID,
		arg.EndUserID,
		arg.StripeInvoiceID,
		arg.BillingPeriodStart,
		arg.BillingPeriodEnd,
		arg.VerificationCount,
		arg.KeyAccessCount,
		arg.CreditsUsed,
		arg.TotalAmount,
		arg.Currency,
		arg.Status,
		arg.CreatedAtM,
	)
	return err
}

const billingInvoiceListByEndUserId = `-- name: BillingInvoiceListByEndUserId :many
SELECT id, workspace_id, end_user_id, stripe_invoice_id, billing_period_start, billing_period_end, verification_count, ratelimit_count, key_access_count, credits_used, total_amount, currency, status, created_at_m, updated_at_m, deleted_at_m FROM billing_invoices
WHERE end_user_id = ?
ORDER BY created_at_m DESC
`

// BillingInvoiceListByEndUserId
//
//	SELECT id, workspace_id, end_user_id, stripe_invoice_id, billing_period_start, billing_period_end, verification_count, ratelimit_count, key_access_count, credits_used, total_amount, currency, status, created_at_m, updated_at_m, deleted_at_m FROM billing_invoices
//	WHERE end_user_id = ?
//	ORDER BY created_at_m DESC
func (q *Queries) BillingInvoiceListByEndUserId(ctx context.Context, db DBTX, endUserID string) ([]BillingInvoice, error) {
	rows, err := db.QueryContext(ctx, billingInvoiceListByEndUserId, endUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingInvoice
	for rows.Next() {
		var i BillingInvoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.EndUserID,
			&i.StripeInvoiceID,
			&i.BillingPeriodStart,
			&i.BillingPeriodEnd,
			&i.VerificationCount,
			&i.RatelimitCount,
			&i.KeyAccessCount,
			&i.CreditsUsed,
			&i.TotalAmount,
			&i.Currency,
			&i.Status,
			&i.CreatedAtM,
			&i.UpdatedAtM,
			&i.DeletedAtM,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingInvoiceListByWorkspaceId = `-- name: BillingInvoiceListByWorkspaceId :many
SELECT id, workspace_id, end_user_id, stripe_invoice_id, billing_period_start, billing_period_end, verification_count, ratelimit_count, key_access_count, credits_used, total_amount, currency, status, created_at_m, updated_at_m, deleted_at_m FROM billing_invoices
WHERE workspace_id = ?
ORDER BY created_at_m DESC
LIMIT ? OFFSET ?
`

type BillingInvoiceListByWorkspaceIdParams struct {
	WorkspaceID string `db:"workspace_id"`
	Limit       int32  `db:"limit"`
	Offset      int32  `db:"offset"`
}

// BillingInvoiceListByWorkspaceId
//
//	SELECT id, workspace_id, end_user_id, stripe_invoice_id, billing_period_start, billing_period_end, verification_count, ratelimit_count, key_access_count, credits_used, total_amount, currency, status, created_at_m, updated_at_m, deleted_at_m FROM billing_invoices
//	WHERE workspace_id = ?
//	ORDER BY created_at_m DESC
//	LIMIT ? OFFSET ?
func (q *Queries) BillingInvoiceListByWorkspaceId(ctx context.Context, db DBTX, arg BillingInvoiceListByWorkspaceIdParams) ([]BillingInvoice, error) {
	rows, err := db.QueryContext(ctx, billingInvoiceListByWorkspaceId, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingInvoice
	for rows.Next() {
		var i BillingInvoice
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.EndUserID,
			&i.StripeInvoiceID,
			&i.BillingPeriodStart,
			&i.BillingPeriodEnd,
			&i.VerificationCount,
			&i.RatelimitCount,
			&i.KeyAccessCount,
			&i.CreditsUsed,
			&i.TotalAmount,
			&i.Currency,
			&i.Status,
			&i.CreatedAtM,
			&i.UpdatedAtM,
			&i.DeletedAtM,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingInvoiceUpdateStatus = `-- name: BillingInvoiceUpdateStatus :exec
UPDATE billing_invoices
SET status = ?, updated_at_m = ?
WHERE id = ?
`

type BillingInvoiceUpdateStatusParams struct {
	Status     string        `db:"status"`
	UpdatedAtM sql.NullInt64 `db:"updated_at_m"`
	ID         string        `db:"id"`
}

// BillingInvoiceUpdateStatus
//
//	UPDATE billing_invoices
//	SET status = ?, updated_at_m = ?
//	WHERE id = ?
func (q *Queries) BillingInvoiceUpdateStatus(ctx context.Context, db DBTX, arg BillingInvoiceUpdateStatusParams) error {
	_, err := db.ExecContext(ctx, billingInvoiceUpdateStatus, arg.Status, arg.UpdatedAtM, arg.ID)
	return err
}

const billingTransactionInsert = `-- name: BillingTransactionInsert :exec
INSERT INTO billing_transactions (
  id,
  invoice_id,
  stripe_payment_intent_id,
  amount,
  currency,
  status,
  failure_reason,
  created_at_m
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type BillingTransactionInsertParams struct {
	ID                    string         `db:"id"`
	InvoiceID             string         `db:"invoice_id"`
	StripePaymentIntentID sql.NullString `db:"stripe_payment_intent_id"`
	Amount                int64          `db:"amount"`
	Currency              string         `db:"currency"`
	Status                string         `db:"status"`
	FailureReason         sql.NullString `db:"failure_reason"`
	CreatedAtM            int64          `db:"created_at_m"`
}

// BillingTransactionInsert
//
//	INSERT INTO billing_transactions (
//	  id,
//	  invoice_id,
//	  stripe_payment_intent_id,
//	  amount,
//	  currency,
//	  status,
//	  failure_reason,
//	  created_at_m
//	) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
func (q *Queries) BillingTransactionInsert(ctx context.Context, db DBTX, arg BillingTransactionInsertParams) error {
	_, err := db.ExecContext(ctx, billingTransactionInsert,
		arg.ID,
		arg.InvoiceID,
		arg.StripePaymentIntentID,
		arg.Amount,
		arg.Currency,
		arg.Status,
		arg.FailureReason,
		arg.CreatedAtM,
	)
	return err
}

const billingTransactionListByInvoiceId = `-- name: BillingTransactionListByInvoiceId :many
SELECT id, invoice_id, stripe_payment_intent_id, amount, currency, status, failure_reason, created_at_m FROM billing_transactions
WHERE invoice_id = ?
ORDER BY created_at_m DESC
`

// BillingTransactionListByInvoiceId
//
//	SELECT id, invoice_id, stripe_payment_intent_id, amount, currency, status, failure_reason, created_at_m FROM billing_transactions
//	WHERE invoice_id = ?
//	ORDER BY created_at_m DESC
func (q *Queries) BillingTransactionListByInvoiceId(ctx context.Context, db DBTX, invoiceID string) ([]BillingTransaction, error) {
	rows, err := db.QueryContext(ctx, billingTransactionListByInvoiceId, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BillingTransaction
	for rows.Next() {
		var i BillingTransaction
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.StripePaymentIntentID,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.FailureReason,
			&i.CreatedAtM,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const billingTransactionUpdateStatus = `-- name: BillingTransactionUpdateStatus :exec
UPDATE billing_transactions
SET status = ?, failure_reason = ?
WHERE id = ?
`

type BillingTransactionUpdateStatusParams struct {
	Status        string         `db:"status"`
	FailureReason sql.NullString `db:"failure_reason"`
	ID            string         `db:"id"`
}

// BillingTransactionUpdateStatus
//
//	UPDATE billing_transactions
//	SET status = ?, failure_reason = ?
//	WHERE id = ?
func (q *Queries) BillingTransactionUpdateStatus(ctx context.Context, db DBTX, arg BillingTransactionUpdateStatusParams) error {
	_, err := db.ExecContext(ctx, billingTransactionUpdateStatus, arg.Status, arg.FailureReason, arg.ID)
	return err
}

const pricingModelCountEndUsers = `-- name: PricingModelCountEndUsers :one
SELECT COUNT(*) as count FROM billing_end_users
WHERE pricing_model_id = ?
`

// PricingModelCountEndUsers
//
//	SELECT COUNT(*) as count FROM billing_end_users
//	WHERE pricing_model_id = ?
func (q *Queries) PricingModelCountEndUsers(ctx context.Context, db DBTX, pricingModelID string) (int64, error) {
	row := db.QueryRowContext(ctx, pricingModelCountEndUsers, pricingModelID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const pricingModelFindById = `-- name: PricingModelFindById :one
SELECT id, workspace_id, name, currency, verification_unit_price, key_access_unit_price, credit_unit_price, tiered_pricing, version, active, created_at_m, updated_at_m, deleted_at_m FROM pricing_models
WHERE id = ? AND deleted_at_m IS NULL
LIMIT 1
`

// PricingModelFindById
//
//	SELECT id, workspace_id, name, currency, verification_unit_price, key_access_unit_price, credit_unit_price, tiered_pricing, version, active, created_at_m, updated_at_m, deleted_at_m FROM pricing_models
//	WHERE id = ? AND deleted_at_m IS NULL
//	LIMIT 1
func (q *Queries) PricingModelFindById(ctx context.Context, db DBTX, id string) (PricingModel, error) {
	row := db.QueryRowContext(ctx, pricingModelFindById, id)
	var i PricingModel
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.Name,
		&i.Currency,
		&i.VerificationUnitPrice,
		&i.KeyAccessUnitPrice,
		&i.CreditUnitPrice,
		&i.TieredPricing,
		&i.Version,
		&i.Active,
		&i.CreatedAtM,
		&i.UpdatedAtM,
		&i.DeletedAtM,
	)
	return i, err
}

const pricingModelFindWorkspaceCurrency = `-- name: PricingModelFindWorkspaceCurrency :one
SELECT currency FROM pricing_models
WHERE workspace_id = ? AND deleted_at_m IS NULL
LIMIT 1
`

// PricingModelFindWorkspaceCurrency
//
//	SELECT currency FROM pricing_models
//	WHERE workspace_id = ? AND deleted_at_m IS NULL
//	LIMIT 1
func (q *Queries) PricingModelFindWorkspaceCurrency(ctx context.Context, db DBTX, workspaceID string) (string, error) {
	row := db.QueryRowContext(ctx, pricingModelFindWorkspaceCurrency, workspaceID)
	var currency string
	err := row.Scan(&currency)
	return currency, err
}

const pricingModelInsert = `-- name: PricingModelInsert :exec
INSERT INTO pricing_models (
  id,
  workspace_id,
  name,
  currency,
  verification_unit_price,
  key_access_unit_price,
  credit_unit_price,
  tiered_pricing,
  version,
  active,
  created_at_m
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type PricingModelInsertParams struct {
	ID                    string `db:"id"`
	WorkspaceID           string `db:"workspace_id"`
	Name                  string `db:"name"`
	Currency              string `db:"currency"`
	VerificationUnitPrice string `db:"verification_unit_price"`
	KeyAccessUnitPrice    string `db:"key_access_unit_price"`
	CreditUnitPrice       string `db:"credit_unit_price"`
	TieredPricing         []byte `db:"tiered_pricing"`
	Version               int32  `db:"version"`
	Active                bool   `db:"active"`
	CreatedAtM            int64  `db:"created_at_m"`
}

// PricingModelInsert
//
//	INSERT INTO pricing_models (
//	  id,
//	  workspace_id,
//	  name,
//	  currency,
//	  verification_unit_price,
//	  key_access_unit_price,
//	  credit_unit_price,
//	  tiered_pricing,
//	  version,
//	  active,
//	  created_at_m
//	) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
func (q *Queries) PricingModelInsert(ctx context.Context, db DBTX, arg PricingModelInsertParams) error {
	_, err := db.ExecContext(ctx, pricingModelInsert,
		arg.ID,
		arg.WorkspaceID,
		arg.Name,
		arg.Currency,
		arg.VerificationUnitPrice,
		arg.KeyAccessUnitPrice,
		arg.CreditUnitPrice,
		arg.TieredPricing,
		arg.Version,
		arg.Active,
		arg.CreatedAtM,
	)
	return err
}

const pricingModelListByWorkspaceId = `-- name: PricingModelListByWorkspaceId :many
SELECT id, workspace_id, name, currency, verification_unit_price, key_access_unit_price, credit_unit_price, tiered_pricing, version, active, created_at_m, updated_at_m, deleted_at_m FROM pricing_models
WHERE workspace_id = ? AND deleted_at_m IS NULL
ORDER BY created_at_m DESC
`

// PricingModelListByWorkspaceId
//
//	SELECT id, workspace_id, name, currency, verification_unit_price, key_access_unit_price, credit_unit_price, tiered_pricing, version, active, created_at_m, updated_at_m, deleted_at_m FROM pricing_models
//	WHERE workspace_id = ? AND deleted_at_m IS NULL
//	ORDER BY created_at_m DESC
func (q *Queries) PricingModelListByWorkspaceId(ctx context.Context, db DBTX, workspaceID string) ([]PricingModel, error) {
	rows, err := db.QueryContext(ctx, pricingModelListByWorkspaceId, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PricingModel
	for rows.Next() {
		var i PricingModel
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.Name,
			&i.Currency,
			&i.VerificationUnitPrice,
			&i.KeyAccessUnitPrice,
			&i.CreditUnitPrice,
			&i.TieredPricing,
			&i.Version,
			&i.Active,
			&i.CreatedAtM,
			&i.UpdatedAtM,
			&i.DeletedAtM,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pricingModelSoftDelete = `-- name: PricingModelSoftDelete :exec
UPDATE pricing_models
SET deleted_at_m = ?, active = false, updated_at_m = ?
WHERE id = ?
`

type PricingModelSoftDeleteParams struct {
	DeletedAtM sql.NullInt64 `db:"deleted_at_m"`
	UpdatedAtM sql.NullInt64 `db:"updated_at_m"`
	ID         string        `db:"id"`
}

// PricingModelSoftDelete
//
//	UPDATE pricing_models
//	SET deleted_at_m = ?, active = false, updated_at_m = ?
//	WHERE id = ?
func (q *Queries) PricingModelSoftDelete(ctx context.Context, db DBTX, arg PricingModelSoftDeleteParams) error {
	_, err := db.ExecContext(ctx, pricingModelSoftDelete, arg.DeletedAtM, arg.UpdatedAtM, arg.ID)
	return err
}

const pricingModelUpdate = `-- name: PricingModelUpdate :exec
UPDATE pricing_models
SET 
  name = ?,
  verification_unit_price = ?,
  key_access_unit_price = ?,
  credit_unit_price = ?,
  tiered_pricing = ?,
  version = ?,
  updated_at_m = ?
WHERE id = ?
`

type PricingModelUpdateParams struct {
	Name                  string        `db:"name"`
	VerificationUnitPrice string        `db:"verification_unit_price"`
	KeyAccessUnitPrice    string        `db:"key_access_unit_price"`
	CreditUnitPrice       string        `db:"credit_unit_price"`
	TieredPricing         []byte        `db:"tiered_pricing"`
	Version               int32         `db:"version"`
	UpdatedAtM            sql.NullInt64 `db:"updated_at_m"`
	ID                    string        `db:"id"`
}

// PricingModelUpdate
//
//	UPDATE pricing_models
//	SET
//	  name = ?,
//	  verification_unit_price = ?,
//	  key_access_unit_price = ?,
//	  credit_unit_price = ?,
//	  tiered_pricing = ?,
//	  version = ?,
//	  updated_at_m = ?
//	WHERE id = ?
func (q *Queries) PricingModelUpdate(ctx context.Context, db DBTX, arg PricingModelUpdateParams) error {
	_, err := db.ExecContext(ctx, pricingModelUpdate,
		arg.Name,
		arg.VerificationUnitPrice,
		arg.KeyAccessUnitPrice,
		arg.CreditUnitPrice,
		arg.TieredPricing,
		arg.Version,
		arg.UpdatedAtM,
		arg.ID,
	)
	return err
}

const stripeConnectedAccountDisconnect = `-- name: StripeConnectedAccountDisconnect :exec
UPDATE stripe_connected_accounts
SET disconnected_at = ?, updated_at_m = ?
WHERE workspace_id = ?
`

type StripeConnectedAccountDisconnectParams struct {
	DisconnectedAt sql.NullInt64 `db:"disconnected_at"`
	UpdatedAtM     sql.NullInt64 `db:"updated_at_m"`
	WorkspaceID    string        `db:"workspace_id"`
}

// StripeConnectedAccountDisconnect
//
//	UPDATE stripe_connected_accounts
//	SET disconnected_at = ?, updated_at_m = ?
//	WHERE workspace_id = ?
func (q *Queries) StripeConnectedAccountDisconnect(ctx context.Context, db DBTX, arg StripeConnectedAccountDisconnectParams) error {
	_, err := db.ExecContext(ctx, stripeConnectedAccountDisconnect, arg.DisconnectedAt, arg.UpdatedAtM, arg.WorkspaceID)
	return err
}

const stripeConnectedAccountFindByWorkspaceId = `-- name: StripeConnectedAccountFindByWorkspaceId :one
SELECT id, workspace_id, stripe_account_id, access_token_encrypted, refresh_token_encrypted, scope, connected_at, disconnected_at, created_at_m, updated_at_m, deleted_at_m FROM stripe_connected_accounts
WHERE workspace_id = ? AND disconnected_at IS NULL
LIMIT 1
`

// StripeConnectedAccountFindByWorkspaceId
//
//	SELECT id, workspace_id, stripe_account_id, access_token_encrypted, refresh_token_encrypted, scope, connected_at, disconnected_at, created_at_m, updated_at_m, deleted_at_m FROM stripe_connected_accounts
//	WHERE workspace_id = ? AND disconnected_at IS NULL
//	LIMIT 1
func (q *Queries) StripeConnectedAccountFindByWorkspaceId(ctx context.Context, db DBTX, workspaceID string) (StripeConnectedAccount, error) {
	row := db.QueryRowContext(ctx, stripeConnectedAccountFindByWorkspaceId, workspaceID)
	var i StripeConnectedAccount
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.StripeAccountID,
		&i.AccessTokenEncrypted,
		&i.RefreshTokenEncrypted,
		&i.Scope,
		&i.ConnectedAt,
		&i.DisconnectedAt,
		&i.CreatedAtM,
		&i.UpdatedAtM,
		&i.DeletedAtM,
	)
	return i, err
}

const stripeConnectedAccountInsert = `-- name: StripeConnectedAccountInsert :exec
INSERT INTO stripe_connected_accounts (
  id,
  workspace_id,
  stripe_account_id,
  access_token_encrypted,
  refresh_token_encrypted,
  scope,
  connected_at,
  created_at_m
) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type StripeConnectedAccountInsertParams struct {
	ID                    string `db:"id"`
	WorkspaceID           string `db:"workspace_id"`
	StripeAccountID       string `db:"stripe_account_id"`
	AccessTokenEncrypted  string `db:"access_token_encrypted"`
	RefreshTokenEncrypted string `db:"refresh_token_encrypted"`
	Scope                 string `db:"scope"`
	ConnectedAt           int64  `db:"connected_at"`
	CreatedAtM            int64  `db:"created_at_m"`
}

// StripeConnectedAccountInsert
//
//	INSERT INTO stripe_connected_accounts (
//	  id,
//	  workspace_id,
//	  stripe_account_id,
//	  access_token_encrypted,
//	  refresh_token_encrypted,
//	  scope,
//	  connected_at,
//	  created_at_m
//	) VALUES (?, ?, ?, ?, ?, ?, ?, ?)
func (q *Queries) StripeConnectedAccountInsert(ctx context.Context, db DBTX, arg StripeConnectedAccountInsertParams) error {
	_, err := db.ExecContext(ctx, stripeConnectedAccountInsert,
		arg.ID,
		arg.WorkspaceID,
		arg.StripeAccountID,
		arg.AccessTokenEncrypted,
		arg.RefreshTokenEncrypted,
		arg.Scope,
		arg.ConnectedAt,
		arg.CreatedAtM,
	)
	return err
}

const stripeConnectedAccountListActive = `-- name: StripeConnectedAccountListActive :many
SELECT id, workspace_id, stripe_account_id, access_token_encrypted, refresh_token_encrypted, scope, connected_at, disconnected_at, created_at_m, updated_at_m, deleted_at_m FROM stripe_connected_accounts
WHERE disconnected_at IS NULL AND deleted_at_m IS NULL
ORDER BY created_at_m DESC
`

// StripeConnectedAccountListActive
//
//	SELECT id, workspace_id, stripe_account_id, access_token_encrypted, refresh_token_encrypted, scope, connected_at, disconnected_at, created_at_m, updated_at_m, deleted_at_m FROM stripe_connected_accounts
//	WHERE disconnected_at IS NULL AND deleted_at_m IS NULL
//	ORDER BY created_at_m DESC
func (q *Queries) StripeConnectedAccountListActive(ctx context.Context, db DBTX) ([]StripeConnectedAccount, error) {
	rows, err := db.QueryContext(ctx, stripeConnectedAccountListActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StripeConnectedAccount
	for rows.Next() {
		var i StripeConnectedAccount
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.StripeAccountID,
			&i.AccessTokenEncrypted,
			&i.RefreshTokenEncrypted,
			&i.Scope,
			&i.ConnectedAt,
			&i.DisconnectedAt,
			&i.CreatedAtM,
			&i.UpdatedAtM,
			&i.DeletedAtM,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
