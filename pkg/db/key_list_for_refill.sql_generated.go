// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: key_list_for_refill.sql

package db

import (
	"context"
	"database/sql"
)

const listKeysForRefill = `-- name: ListKeysForRefill :many
SELECT k.pk, k.id, k.workspace_id, k.refill_amount, k.remaining_requests, k.name
FROM ` + "`" + `keys` + "`" + ` k
INNER JOIN (
    SELECT ki.pk
    FROM ` + "`" + `keys` + "`" + ` ki
    WHERE ki.refill_amount IS NOT NULL
      AND ki.deleted_at_m IS NULL
      AND (ki.remaining_requests IS NULL OR ki.refill_amount > ki.remaining_requests)
      AND (
          ki.refill_day IS NULL
          OR ki.refill_day = ?
          OR (? = 1 AND ki.refill_day > ?)
      )
      AND ki.pk > ?
    ORDER BY pk
    LIMIT ?
) AS batch ON batch.pk = k.pk
`

type ListKeysForRefillParams struct {
	TodayDay         sql.NullInt16 `db:"today_day"`
	IsLastDayOfMonth interface{}   `db:"is_last_day_of_month"`
	AfterPk          uint64        `db:"after_pk"`
	Limit            int32         `db:"limit"`
}

type ListKeysForRefillRow struct {
	Pk                uint64         `db:"pk"`
	ID                string         `db:"id"`
	WorkspaceID       string         `db:"workspace_id"`
	RefillAmount      sql.NullInt32  `db:"refill_amount"`
	RemainingRequests sql.NullInt32  `db:"remaining_requests"`
	Name              sql.NullString `db:"name"`
}

// ListKeysForRefill returns keys that need their remaining_requests refilled.
// Uses a deferred join on pk for stable cursor-based pagination that avoids
// OFFSET drift when rows are mutated between batches.
// Keys are selected if:
//   - refill_day is NULL (daily refill)
//   - refill_day matches today's day of month
//   - refill_day > today's day AND today is the last day of month (catch-up for short months)
//
// Keys are skipped if remaining_requests >= refill_amount (already full).
//
//	SELECT k.pk, k.id, k.workspace_id, k.refill_amount, k.remaining_requests, k.name
//	FROM `keys` k
//	INNER JOIN (
//	    SELECT ki.pk
//	    FROM `keys` ki
//	    WHERE ki.refill_amount IS NOT NULL
//	      AND ki.deleted_at_m IS NULL
//	      AND (ki.remaining_requests IS NULL OR ki.refill_amount > ki.remaining_requests)
//	      AND (
//	          ki.refill_day IS NULL
//	          OR ki.refill_day = ?
//	          OR (? = 1 AND ki.refill_day > ?)
//	      )
//	      AND ki.pk > ?
//	    ORDER BY pk
//	    LIMIT ?
//	) AS batch ON batch.pk = k.pk
func (q *Queries) ListKeysForRefill(ctx context.Context, db DBTX, arg ListKeysForRefillParams) ([]ListKeysForRefillRow, error) {
	rows, err := db.QueryContext(ctx, listKeysForRefill,
		arg.TodayDay,
		arg.IsLastDayOfMonth,
		arg.TodayDay,
		arg.AfterPk,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeysForRefillRow
	for rows.Next() {
		var i ListKeysForRefillRow
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.WorkspaceID,
			&i.RefillAmount,
			&i.RemainingRequests,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
