// Code generated by sqlc bulk insert plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"fmt"
	"strings"
)

// {{.BulkQueryConstant}} is the base query for bulk insert
const {{.BulkQueryConstant}} = `{{.InsertPart}} VALUES %s{{if .OnDuplicateKeyUpdate}} {{.OnDuplicateKeyUpdate}}{{end}}`

// {{.BulkFunctionName}} performs bulk insert in a single query
{{if .EmitMethodsWithDBArgument -}}
func (q *BulkQueries) {{.BulkFunctionName}}(ctx context.Context, db DBTX, args []{{.ParamsStructName}}) error {
{{else }}
func (q *BulkQueries) {{.BulkFunctionName}}(ctx context.Context, args []{{.ParamsStructName}}) error {
{{end}}
	if len(args) == 0 {
		return nil
	}

	// Build the bulk insert query
	valueClauses := make([]string, len(args))
	for i := range args {
		valueClauses[i] = "{{.ValuesPart}}"
	}

	bulkQuery := fmt.Sprintf({{.BulkQueryConstant}}, strings.Join(valueClauses, ", "))

	// Collect all arguments
	var allArgs []any
	for _, arg := range args {
		{{- range .ValuesFields}}
		allArgs = append(allArgs, arg.{{.}})
		{{- end}}
	}
	{{- if .UpdateFields}}

	// Add ON DUPLICATE KEY UPDATE parameters (only once, not per row)
	if len(args) > 0 {
		{{- range .UpdateFields}}
		allArgs = append(allArgs, args[0].{{.}})
		{{- end}}
	}
	{{- end}}

	// Execute the bulk insert
    {{if .EmitMethodsWithDBArgument -}}
    _, err := db.ExecContext(ctx, bulkQuery, allArgs...)
    {{else -}}
    _, err := q.db.ExecContext(ctx, bulkQuery, allArgs...)
    {{end -}}

	return err
}
