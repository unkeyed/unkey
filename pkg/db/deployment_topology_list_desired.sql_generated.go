// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: deployment_topology_list_desired.sql

package db

import (
	"context"
	"database/sql"
)

const listDesiredDeploymentTopology = `-- name: ListDesiredDeploymentTopology :many
SELECT
    dt.pk, dt.workspace_id, dt.deployment_id, dt.region, dt.desired_replicas, dt.desired_status, dt.created_at, dt.updated_at,
    d.pk, d.id, d.k8s_name, d.workspace_id, d.project_id, d.environment_id, d.image, d.build_id, d.git_commit_sha, d.git_branch, d.git_commit_message, d.git_commit_author_handle, d.git_commit_author_avatar_url, d.git_commit_timestamp, d.sentinel_config, d.openapi_spec, d.cpu_millicores, d.memory_mib, d.desired_state, d.encrypted_environment_variables, d.status, d.created_at, d.updated_at,
    w.k8s_namespace
FROM ` + "`" + `deployment_topology` + "`" + ` dt
INNER JOIN ` + "`" + `deployments` + "`" + ` d ON dt.deployment_id = d.id
INNER JOIN ` + "`" + `workspaces` + "`" + ` w ON d.workspace_id = w.id
WHERE (? = '' OR dt.region = ?)
    AND d.desired_state = ?
    AND dt.deployment_id > ?
ORDER BY dt.deployment_id ASC
LIMIT ?
`

type ListDesiredDeploymentTopologyParams struct {
	Region           string                  `db:"region"`
	DesiredState     DeploymentsDesiredState `db:"desired_state"`
	PaginationCursor string                  `db:"pagination_cursor"`
	Limit            int32                   `db:"limit"`
}

type ListDesiredDeploymentTopologyRow struct {
	DeploymentTopology DeploymentTopology `db:"deployment_topology"`
	Deployment         Deployment         `db:"deployment"`
	K8sNamespace       sql.NullString     `db:"k8s_namespace"`
}

// ListDesiredDeploymentTopology returns all deployment topologies matching the desired state for a region.
// Used during bootstrap to stream all running deployments to krane.
// The version parameter is deprecated and ignored (kept for backwards compatibility).
//
//	SELECT
//	    dt.pk, dt.workspace_id, dt.deployment_id, dt.region, dt.desired_replicas, dt.desired_status, dt.created_at, dt.updated_at,
//	    d.pk, d.id, d.k8s_name, d.workspace_id, d.project_id, d.environment_id, d.image, d.build_id, d.git_commit_sha, d.git_branch, d.git_commit_message, d.git_commit_author_handle, d.git_commit_author_avatar_url, d.git_commit_timestamp, d.sentinel_config, d.openapi_spec, d.cpu_millicores, d.memory_mib, d.desired_state, d.encrypted_environment_variables, d.status, d.created_at, d.updated_at,
//	    w.k8s_namespace
//	FROM `deployment_topology` dt
//	INNER JOIN `deployments` d ON dt.deployment_id = d.id
//	INNER JOIN `workspaces` w ON d.workspace_id = w.id
//	WHERE (? = '' OR dt.region = ?)
//	    AND d.desired_state = ?
//	    AND dt.deployment_id > ?
//	ORDER BY dt.deployment_id ASC
//	LIMIT ?
func (q *Queries) ListDesiredDeploymentTopology(ctx context.Context, db DBTX, arg ListDesiredDeploymentTopologyParams) ([]ListDesiredDeploymentTopologyRow, error) {
	rows, err := db.QueryContext(ctx, listDesiredDeploymentTopology,
		arg.Region,
		arg.Region,
		arg.DesiredState,
		arg.PaginationCursor,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDesiredDeploymentTopologyRow
	for rows.Next() {
		var i ListDesiredDeploymentTopologyRow
		if err := rows.Scan(
			&i.DeploymentTopology.Pk,
			&i.DeploymentTopology.WorkspaceID,
			&i.DeploymentTopology.DeploymentID,
			&i.DeploymentTopology.Region,
			&i.DeploymentTopology.DesiredReplicas,
			&i.DeploymentTopology.DesiredStatus,
			&i.DeploymentTopology.CreatedAt,
			&i.DeploymentTopology.UpdatedAt,
			&i.Deployment.Pk,
			&i.Deployment.ID,
			&i.Deployment.K8sName,
			&i.Deployment.WorkspaceID,
			&i.Deployment.ProjectID,
			&i.Deployment.EnvironmentID,
			&i.Deployment.Image,
			&i.Deployment.BuildID,
			&i.Deployment.GitCommitSha,
			&i.Deployment.GitBranch,
			&i.Deployment.GitCommitMessage,
			&i.Deployment.GitCommitAuthorHandle,
			&i.Deployment.GitCommitAuthorAvatarUrl,
			&i.Deployment.GitCommitTimestamp,
			&i.Deployment.SentinelConfig,
			&i.Deployment.OpenapiSpec,
			&i.Deployment.CpuMillicores,
			&i.Deployment.MemoryMib,
			&i.Deployment.DesiredState,
			&i.Deployment.EncryptedEnvironmentVariables,
			&i.Deployment.Status,
			&i.Deployment.CreatedAt,
			&i.Deployment.UpdatedAt,
			&i.K8sNamespace,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
