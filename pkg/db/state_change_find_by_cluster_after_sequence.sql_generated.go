// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: state_change_find_by_cluster_after_sequence.sql

package db

import (
	"context"
)

const findStateChangesByClusterAfterSequence = `-- name: FindStateChangesByClusterAfterSequence :many
SELECT sequence, resource_type, state, cluster_id, created_at
FROM ` + "`" + `state_changes` + "`" + `
WHERE cluster_id = ?
  AND sequence > ?
ORDER BY sequence ASC
`

type FindStateChangesByClusterAfterSequenceParams struct {
	ClusterID     string `db:"cluster_id"`
	AfterSequence uint64 `db:"after_sequence"`
}

// FindStateChangesByClusterAfterSequence
//
//	SELECT sequence, resource_type, state, cluster_id, created_at
//	FROM `state_changes`
//	WHERE cluster_id = ?
//	  AND sequence > ?
//	ORDER BY sequence ASC
func (q *Queries) FindStateChangesByClusterAfterSequence(ctx context.Context, db DBTX, arg FindStateChangesByClusterAfterSequenceParams) ([]StateChange, error) {
	rows, err := db.QueryContext(ctx, findStateChangesByClusterAfterSequence, arg.ClusterID, arg.AfterSequence)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StateChange
	for rows.Next() {
		var i StateChange
		if err := rows.Scan(
			&i.Sequence,
			&i.ResourceType,
			&i.State,
			&i.ClusterID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
