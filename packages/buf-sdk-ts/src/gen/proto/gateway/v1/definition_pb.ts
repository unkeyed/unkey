// @generated by protoc-gen-es v1.2.1 with parameter "target=ts"
// @generated from file proto/gateway/v1/definition.proto (package v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * @generated from enum v1.AuthorizerType
 */
export enum AuthorizerType {
  /**
   * @generated from enum value: AUTHORIZER_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: AUTHORIZER_TYPE_KEY = 1;
   */
  KEY = 1,

  /**
   * @generated from enum value: AUTHORIZER_TYPE_JWT = 2;
   */
  JWT = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AuthorizerType)
proto3.util.setEnumType(AuthorizerType, "v1.AuthorizerType", [
  { no: 0, name: "AUTHORIZER_TYPE_UNSPECIFIED" },
  { no: 1, name: "AUTHORIZER_TYPE_KEY" },
  { no: 2, name: "AUTHORIZER_TYPE_JWT" },
]);

/**
 * @generated from message v1.Authorizer
 */
export class Authorizer extends Message<Authorizer> {
  /**
   * @generated from field: v1.AuthorizerType type = 1;
   */
  type = AuthorizerType.UNSPECIFIED;

  /**
   * @generated from field: string id = 2;
   */
  id = "";

  constructor(data?: PartialMessage<Authorizer>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.Authorizer";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "enum", T: proto3.getEnumType(AuthorizerType) },
    { no: 2, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Authorizer {
    return new Authorizer().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Authorizer {
    return new Authorizer().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Authorizer {
    return new Authorizer().fromJsonString(jsonString, options);
  }

  static equals(a: Authorizer | PlainMessage<Authorizer> | undefined, b: Authorizer | PlainMessage<Authorizer> | undefined): boolean {
    return proto3.util.equals(Authorizer, a, b);
  }
}

/**
 * @generated from message v1.OriginWeight
 */
export class OriginWeight extends Message<OriginWeight> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: int32 weight = 2;
   */
  weight = 0;

  constructor(data?: PartialMessage<OriginWeight>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.OriginWeight";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "weight", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OriginWeight {
    return new OriginWeight().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OriginWeight {
    return new OriginWeight().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OriginWeight {
    return new OriginWeight().fromJsonString(jsonString, options);
  }

  static equals(a: OriginWeight | PlainMessage<OriginWeight> | undefined, b: OriginWeight | PlainMessage<OriginWeight> | undefined): boolean {
    return proto3.util.equals(OriginWeight, a, b);
  }
}

/**
 * @generated from message v1.RouteRule
 */
export class RouteRule extends Message<RouteRule> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: int32 version = 2;
   */
  version = 0;

  /**
   * method or `ANY` to match all
   * we automatically capitalize
   *
   * @generated from field: string method = 3;
   */
  method = "";

  /**
   * Path match in the shape of `/v1/*` or `/v*\/hello`
   *
   * @generated from field: string path = 4;
   */
  path = "";

  /**
   * @generated from field: optional v1.Authorizer authorizer = 5;
   */
  authorizer?: Authorizer;

  /**
   * @generated from field: repeated v1.OriginWeight origins = 6;
   */
  origins: OriginWeight[] = [];

  constructor(data?: PartialMessage<RouteRule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.RouteRule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "version", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "method", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "authorizer", kind: "message", T: Authorizer, opt: true },
    { no: 6, name: "origins", kind: "message", T: OriginWeight, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RouteRule {
    return new RouteRule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RouteRule {
    return new RouteRule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RouteRule {
    return new RouteRule().fromJsonString(jsonString, options);
  }

  static equals(a: RouteRule | PlainMessage<RouteRule> | undefined, b: RouteRule | PlainMessage<RouteRule> | undefined): boolean {
    return proto3.util.equals(RouteRule, a, b);
  }
}

/**
 * @generated from message v1.Definition
 */
export class Definition extends Message<Definition> {
  /**
   * We use UnixMilli as the version
   * This way there's always a clear "latest" configuration
   *
   * @generated from field: int64 updated_at = 1;
   */
  updatedAt = protoInt64.zero;

  /**
   * @generated from field: repeated v1.RouteRule route_rules = 2;
   */
  routeRules: RouteRule[] = [];

  constructor(data?: PartialMessage<Definition>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "v1.Definition";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "updated_at", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "route_rules", kind: "message", T: RouteRule, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Definition {
    return new Definition().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Definition {
    return new Definition().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Definition {
    return new Definition().fromJsonString(jsonString, options);
  }

  static equals(a: Definition | PlainMessage<Definition> | undefined, b: Definition | PlainMessage<Definition> | undefined): boolean {
    return proto3.util.equals(Definition, a, b);
  }
}

