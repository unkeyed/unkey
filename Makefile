


# Detect OS and set GOMAXPROCS accordingly
UNAME_S := $(shell uname -s)
ifeq ($(UNAME_S),Linux)
    DETECTED_PROCS := $(shell nproc)
else ifeq ($(UNAME_S),Darwin)
    DETECTED_PROCS := $(shell sysctl -n hw.ncpu)
else
    DETECTED_PROCS := 4
endif

GOMAXPROCS_VAL := $(or $(GOMAXPROCS),$(DETECTED_PROCS))
PARALLEL_PROCS := $(shell if [ $(GOMAXPROCS_VAL) -gt 1 ]; then expr $(GOMAXPROCS_VAL) / 2; else echo 1; fi)


.PHONY: help
help: ## Display this help.
	@awk 'BEGIN {FS = ":.*##"; printf "\nUsage:\n  make \033[36m<target>\033[0m\n"} /^[a-zA-Z_0-9-]+:.*?##/ { printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2 } /^##@/ { printf "\n\033[1m%s\033[0m\n", substr($$0, 5) } ' $(MAKEFILE_LIST)


.PHONY: install
install: ## Install Go modules and pnpm dependencies
	@[ -f go.work ] || go work init . tools

	go mod download
	pnpm --dir=web install



.PHONY: generate-sql
generate-sql: ## Generate SQL schema from Drizzle definitions
	@rm -f ./pkg/db/schema.sql || true
	@touch ./pkg/db/schema.sql
	@echo "-- Code generated by Makefile. DO NOT EDIT." >> ./pkg/db/schema.sql
	@echo "--" >> ./pkg/db/schema.sql
	@echo "-- Source: web/internal/db/src/schema" >> ./pkg/db/schema.sql
	@rm -rf ./web/internal/db/out
	@cd web/internal/db && pnpm drizzle-kit generate --schema=src/schema/index.ts --dialect=mysql --out=out --name=init --breakpoints=false
	@echo "\n" >> ./web/internal/db/out/0000_init.sql
	@cat ./web/internal/db/out/0000_init.sql >> ./pkg/db/schema.sql

	@rm -rf ./web/internal/db/out


.PHONY: nuke-docker
nuke-docker: ## Stop all containers and clean up Docker system
	docker stop $$(docker ps -aq)
	docker system prune -af
	docker volume prune --all -f



.PHONY: fmt
fmt: ## Format code and run linters
	go fmt ./...
	go tool buf format -w
	go tool golangci-lint run

	pnpm --dir=web fmt

.PHONY: pull
pull: ## Pull latest Docker images for services
	@docker compose -f ../deployment/docker-compose.yaml pull

.PHONY: up
up: pull ## Start all infrastructure services
	@docker compose -f ../deployment/docker-compose.yaml up -d planetscale mysql redis clickhouse s3 otel kafka restate --wait

.PHONY: clean
clean: ## Stop and remove all services with volumes
	@docker compose -f ../deployment/docker-compose.yaml down --volumes

.PHONY: build
build: install ## Build all artifacts
	go build -o bin/unkey .

	pnpm --dir=web build

.PHONY: generate
generate: ## Generate code from protobuf and other sources
	rm ./pkg/db/*_generated.go || true
	go tool buf generate --template ./buf.gen.connect.yaml --clean --path "./proto/ctrl" --path "./proto/krane" --path "./proto/vault" --path "./proto/cache" --path "./proto/gateway"
	go tool buf generate --template ./buf.gen.restate.yaml --path "./proto/hydra"
	go generate ./...
	go fmt ./...
	pnpm --dir=web fmt

.PHONY: talos
talos: ## Create Talos testing cluster
	talosctl cluster create --name=testing


.PHONY: test-k8s
test-k8s: talos ## Run Kubernetes cluster tests
	go test ./apps/krane/pkg/k8s/test_cluster/... -v

.PHONY: test
test: test-unit ## Run unit tests (alias)

.PHONY: test-unit
test-unit: up ## Run unit tests with infrastructure
	@echo "Running tests w/$(PARALLEL_PROCS) parallel test processes"
	@go test -json -failfast -timeout=15m -parallel=$(PARALLEL_PROCS) ./... | go run github.com/mfridman/tparse@ba2512e7be150bfcbd6f6220d517d3741f8f2f75 -all -smallscreen

.PHONY: test-stress
test-stress: export INTEGRATION_TEST=true
test-stress: export SIMULATION_TEST=false
test-stress: up ## Run stress tests
	@echo "Running stress tests w/$(PARALLEL_PROCS) parallel test processes"
	@go test -tags=stress,integration,integration_long -json -failfast -timeout=15m -parallel=$(PARALLEL_PROCS) ./... | go run github.com/mfridman/tparse@ba2512e7be150bfcbd6f6220d517d3741f8f2f75 -all -smallscreen

.PHONY: test-integration-long
test-integration-long: export INTEGRATION_TEST=true
test-integration-long: export SIMULATION_TEST=false
test-integration-long: up ## Run long integration tests
	@echo "Running long-ish integration tests w/$(PARALLEL_PROCS) parallel test processes"
	@go test -tags=integration,integration_long -json -failfast -timeout=15m -parallel=$(PARALLEL_PROCS) ./... | go run github.com/mfridman/tparse@ba2512e7be150bfcbd6f6220d517d3741f8f2f75 -all -smallscreen

.PHONY: test-integration
test-integration: export INTEGRATION_TEST=true
test-integration: export SIMULATION_TEST=false
test-integration: up ## Run integration tests
	@echo "Running integration tests w/$(PARALLEL_PROCS) parallel test processes"
	@go test -tags=integration -json -failfast -timeout=15m -parallel=$(PARALLEL_PROCS) ./... | go run github.com/mfridman/tparse@ba2512e7be150bfcbd6f6220d517d3741f8f2f75 -smallscreen

# ============================================================================
# Kubernetes Development Commands
# ============================================================================

.PHONY: k8s-check
k8s-check: ## Check if kubectl is available and cluster is running
	@command -v kubectl >/dev/null 2>&1 || { echo "ERROR: kubectl not found. Install from: https://kubernetes.io/docs/tasks/tools/"; exit 1; }
	@kubectl cluster-info >/dev/null 2>&1 || { echo "ERROR: Kubernetes cluster not available. Enable Kubernetes in Docker Desktop/OrbStack"; exit 1; }
	@echo "Kubernetes cluster is available"

.PHONY: k8s-up
k8s-up: k8s-check ## Deploy all services to current Kubernetes cluster
	@echo "Building Docker images..."
	@docker build -t unkey/mysql:local -f ../deployment/Dockerfile.mysql ../
	@docker build -t unkey/clickhouse:local -f ../deployment/Dockerfile.clickhouse ../
	@docker build -t unkey:local .
	@echo "Creating namespace..."
	@kubectl apply -f k8s/manifests/namespace.yaml
	@echo "Applying Kubernetes manifests..."
	@kubectl apply -f k8s/manifests/
	@echo "Waiting for services to be ready..."
	@kubectl wait --for=condition=ready pod -l app=mysql -n unkey --timeout=180s
	@kubectl wait --for=condition=ready pod -l app=clickhouse -n unkey --timeout=180s
	@kubectl wait --for=condition=ready pod -l app=s3 -n unkey --timeout=180s
	@kubectl wait --for=condition=ready pod -l app=restate -n unkey --timeout=180s
	@kubectl wait --for=condition=ready pod -l app=api -n unkey --timeout=180s
	@kubectl wait --for=condition=ready pod -l app=gw -n unkey --timeout=180s
	@kubectl wait --for=condition=ready pod -l app=ctrl -n unkey --timeout=180s
	@kubectl wait --for=condition=ready pod -l app=krane -n unkey --timeout=180s
	@kubectl wait --for=condition=ready pod -l app=dashboard -n unkey --timeout=180s
	@echo "Kubernetes environment is ready!"
	@echo ""
	@echo "Services accessible via NodePort on localhost - check actual ports with:"
	@echo ""
	@echo "Check NodePort assignments: make k8s-ports"
	@make k8s-status

.PHONY: k8s-stop
k8s-stop: ## Stop all pods (scale deployments to 0)
	@echo "Stopping all pods..."
	@kubectl scale deployment --all --replicas=0 -n unkey
	@echo "All pods stopped"

.PHONY: k8s-down
k8s-down: ## Delete all services from current Kubernetes cluster
	@echo "Deleting all services..."
	@kubectl delete namespace unkey --ignore-not-found=true
	@echo "Services deleted"

.PHONY: k8s-reset
k8s-reset: k8s-down k8s-up ## Reset the entire Kubernetes environment

# Helper function to deploy a service
define deploy-service
	@echo "Starting $(2)..."
	$(if $(3),@docker build -t $(3) $(4))
	@kubectl apply -f k8s/manifests/namespace.yaml
	@kubectl apply -f k8s/manifests/$(1).yaml
	@kubectl wait --for=condition=ready pod -l app=$(1) -n unkey --timeout=180s
	$(if $(5),@kubectl wait --for=condition=ready pod -l app=$(5) -n unkey --timeout=180s)
	@echo "$(2) is ready!"
endef

.PHONY: start-mysql
start-mysql: k8s-check ## Deploy only MySQL
	$(call deploy-service,mysql,MySQL,unkey/mysql:local,-f ../deployment/Dockerfile.mysql ../)

.PHONY: start-clickhouse
start-clickhouse: k8s-check ## Deploy only ClickHouse
	@docker build -t unkey/clickhouse:local -f ../deployment/Dockerfile.clickhouse ../
	$(call deploy-service,clickhouse,ClickHouse)

.PHONY: start-redis
start-redis: k8s-check ## Deploy only Redis
	$(call deploy-service,redis,Redis)

.PHONY: start-s3
start-s3: k8s-check ## Deploy only S3 (MinIO)
	$(call deploy-service,s3,S3 (MinIO))

.PHONY: start-planetscale
start-planetscale: k8s-check ## Deploy only PlanetScale HTTP driver
	$(call deploy-service,planetscale,PlanetScale HTTP driver)

.PHONY: start-observability
start-observability: k8s-check ## Deploy only Observability stack
	$(call deploy-service,observability,Observability stack,,,otel-collector)

.PHONY: start-restate
start-restate: k8s-check ## Deploy only Restate
	$(call deploy-service,restate,Restate)

.PHONY: start-api
start-api: k8s-check ## Deploy only API service (3 replicas)
	$(call deploy-service,api,API,unkey:local,.)


.PHONY: start-ctrl
start-ctrl: k8s-check ## Deploy only ctrl service
	$(call deploy-service,ctrl,Control Plane,unkey:local,.)

.PHONY: start-dashboard
start-dashboard: k8s-check ## Deploy only dashboard service
	$(call deploy-service,dashboard,Dashboard,unkey/dashboard:latest,-f ../apps/dashboard/Dockerfile ../)

.PHONY: start-unkey-services
start-unkey-services: start-api start-ctrl start-dashboard ## Deploy all Unkey services

.PHONY: start-dependencies
start-dependencies: start-mysql start-clickhouse start-redis start-s3 start-planetscale start-observability start-restate ## Deploy all dependency services

.PHONY: start-all
start-all: start-dependencies start-unkey-services ## Deploy all services individually


.PHONY: image
image: ## Build Docker image for development
	docker build -t unkey/dev:latest .
	# minikube image load unkey/dev:latest

.PHONY: cluster
cluster: ## Create Kubernetes cluster using ctlptl
	ctlptl apply -f cluster.yaml

	#minikube start \
	#  --driver=docker \
	#	--container-runtime=containerd \
	#	--docker-opt="containerd=/var/run/containerd/containerd.sock" \
	#	--cpus=no-limit \
	#	--memory=no-limit \
	#	--disk-size=50gb \
	#	--addons=metrics-server,dashboard,gvisor

.PHONY: dev
dev: image ## Start with Tilt (if available) or fallback to k8s-up
	@if command -v tilt >/dev/null 2>&1; then \
		echo "Starting with Tilt..."; \
		tilt up; \
	else \
		echo "Tilt not found, using k8s-up instead"; \
		echo "Install Tilt from: https://docs.tilt.dev/install.html"; \
		make k8s-up; \
	fi



.PHONY: local
local: ## Run local development setup
	@go run . dev local
