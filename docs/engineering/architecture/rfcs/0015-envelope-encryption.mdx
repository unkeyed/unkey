---
title: 0015 Envelope Encryption
description: Replace the preflight/inject/krane/vault secret injection chain with deploy-time envelope encryption and local-only decryption at pod startup.
date: 2026-02-25
authors:
    - Flo
---

The current secret injection pipeline is a 4-service chain: preflight webhook, inject binary, Krane SecretsService, Vault. Every pod startup requires all 4 services to be healthy. This RFC replaces that with envelope encryption — secrets are sealed at deploy time and decrypted locally at pod startup. Zero network calls. Zero runtime service dependencies.

## Summary

Move all secret resolution to deploy time. At deploy time, ctrl-worker decrypts secrets from Vault, seals them into an encrypted envelope using a per-deployment DEK wrapped by a cluster-wide KEK. At pod startup, the inject binary decrypts secrets locally using the KEK distributed to nodes via a DaemonSet. No runtime services need to be available for pods to start.

## Motivation

**Reliability**: Any of the 4 services (preflight, inject, Krane SecretsService, Vault) going down means pods can't start. Even scaling an existing deployment fails because new pods need to fetch secrets at startup.

**Complexity**: TLS cert management for the preflight webhook. Debugging a secret injection failure requires tracing through 4 services. The `MutatingWebhookConfiguration` with `failurePolicy: Fail` means webhook issues block all pod creation cluster-wide.
TL;DR if anything is down boy it will all break.

**Depot pull tokens**: The webhook creates pull secrets with deterministic names (`preflight-pull-<sha256(image)[:8]>`) and reuses them across pods with the same image until they expire. But every pod creation still flows through the webhook to check/create the secret — the webhook remains a SPOF for pod admission even when the actual Depot API call is cached.

## Detailed Design

### Envelope Encryption

Two keys:

- **KEK (Key Encryption Key)** — A long-lived cluster-wide master key. Distributed to nodes via a DaemonSet. Used to wrap/unwrap DEKs.
- **DEK (Data Encryption Key)** — A random per-deployment key. Generated at deploy time. Used to encrypt the actual secrets.

The sealed envelope stored in the pod spec as `UNKEY_SEALED_ENV`:

```
┌─────────────────────────────────┐
│ version: 1                      │
│ kek_id: "kek-2026-02"          │  ← which KEK wrapped the DEK
│ wrapped_dek: <AES-GCM>         │  ← DEK encrypted with KEK
│ encrypted_payload: <AES-GCM>   │  ← env vars encrypted with DEK
│ deployment_id: "dpl_xxx"        │  ← for audit/debugging
│ created_at: 1740000000000       │
└─────────────────────────────────┘
```

**Security property**: The sealed envelope is useless without the KEK. The KEK is useless without sealed envelopes. Neither alone reveals any secret.

### Deploy Time (ctrl-worker)

When a deployment is created in `svc/ctrl/services/deployment/create_deployment.go`:

1. Fetch `{key: vault-encrypted-value}` pairs from DB via `FindEnvironmentVariablesByEnvironmentId` — this is how env vars are stored today (keys plaintext, values individually Vault-encrypted)
2. Call `vault.DecryptBulk(keyring=environmentID)` to get plaintext values — **this is the only time Vault is ever called**
3. Generate a random 32-byte DEK
4. Encrypt the plaintext `{key: value}` map with the DEK (AES-256-GCM)
5. Wrap the DEK with the cluster KEK (AES-256-GCM)
6. Serialize as protobuf, base64-encode, store in the deployment row's `encrypted_environment_variables` column

Currently, `create_deployment.go` builds a `SecretsConfig` proto with the raw (vault-encrypted) values and stores it as JSON. The new path replaces this with a sealed envelope.

### Pod Startup (inject binary)

The inject binary at `cmd/inject/` gets rewritten with two modes: `decrypt` (init container) and the default run mode (main container). The krane-vault provider is removed.

**Init container** (`inject decrypt`):
1. Read `UNKEY_SEALED_ENV` from env var
2. Read KEK from `/var/run/unkey/kek/kek.json` (local file, no network)
3. Find the KEK matching the envelope's `kek_id`
4. Unwrap DEK → decrypt payload → get `{key: value}` map
5. Write plaintext env vars as JSON to `/env-shared/env.json`
6. Exit. KEK is never accessible again after this point.

**Main container** (`inject` wraps the customer process):
1. Read `/env-shared/env.json`
2. Set env vars
3. Delete `/env-shared/env.json` — plaintext secrets gone from disk before customer code runs
4. `syscall.Exec()` the customer process — inject is gone, customer code just sees normal env vars
5. **Zero network calls. Zero files left behind. Zero crypto keys. Customer code has no idea any of this happened.**

### KEK Storage

The KEK is stored encrypted at rest in an object store (S3, GCS, MinIO — any S3-compatible API). A **root key** encrypts the KEK before it's written to the bucket. This gives us two independent security barriers: bucket access alone is useless without the root key, and the root key alone is useless without bucket access.

```
┌─────────────────────────────────────────────────┐
│ Object store (S3 / GCS / MinIO)                 │
│                                                 │
│   kek.json.enc                                  │
│   ┌───────────────────────────────────────────┐ │
│   │ AES-256-GCM encrypted with root key       │ │
│   │ Plaintext is the KEK key file (see below) │ │
│   └───────────────────────────────────────────┘ │
└─────────────────────────────────────────────────┘
```

Three layers of envelope encryption total: root key wraps KEK, KEK wraps DEK, DEK wraps secrets. Compromise requires breaking multiple independent systems.

The root key is the one true secret. It's a 32-byte value stored in AWS Secrets Manager and provided to kek-agent as an env var. The root key never touches the object store. The KEK never touches Secrets Manager. Separation of concerns.

This design is deliberately cloud-agnostic. No dependency on AWS KMS, GCP Cloud KMS, or any provider-specific key management. The encryption is AES-256-GCM done by us. The object store is just dumb storage. Switching from AWS to GCP or bare metal means pointing kek-agent at a different bucket — the crypto doesn't change.

### KEK Distribution (kek-agent DaemonSet)

A DaemonSet running on every node. Its only job: fetch the encrypted KEK from the object store, decrypt it with the root key, and put the plaintext on the node's tmpfs.

1. At startup: fetch encrypted KEK from object store, decrypt with root key (AES-256-GCM)
2. Write plaintext KEK to host tmpfs at `/var/run/unkey/kek/kek.json`
3. Serve a health endpoint
4. Periodically re-fetch from object store (picks up rotations without DaemonSet redeploy)
5. Sleep forever

Pods mount `/var/run/unkey/kek` as a read-only `hostPath` volume. The DaemonSet runs with `priorityClassName: system-node-critical` so it starts before user pods on node boot.

The plaintext KEK file on tmpfs supports multiple keys for rotation:

```json
[
    { "id": "kek-2026-02", "key": "<base64-32-bytes>" },
    { "id": "kek-2026-01", "key": "<base64-32-bytes>" }
]
```

tmpfs means the plaintext KEK only ever lives in memory — never written to disk, never in etcd, never in the object store. Node reboot wipes it. kek-agent rewrites it on startup.

### Pod Spec Construction

Currently, Krane (`svc/krane/internal/deployment/apply.go`) builds the ReplicaSet with just the user container. Preflight (`svc/preflight/internal/services/mutator/mutator.go`) then patches in the inject init container at admission time via `MutatingWebhookConfiguration`.

In the new system, Krane builds the complete spec directly when `sealed_envelope` is present in the `ApplyDeployment` proto.

**The KEK is only accessible to the init container, never the main container.** The init container decrypts secrets and writes plaintext env vars to a shared emptyDir file. The main container reads that file — it never sees the KEK. This is critical because the main container runs customer code.

It would look something like this:
```yaml
spec:
    initContainers:
        - name: decrypt-env
          image: ghcr.io/unkeyed/inject:latest
          command: ["/ko-app/inject", "decrypt"]
          env:
              - name: UNKEY_SEALED_ENV
                value: <base64-sealed-envelope>
              - name: UNKEY_KEK_PATH
                value: /var/run/unkey/kek/kek.json
              - name: UNKEY_ENV_FILE
                value: /env-shared/env.json
          volumeMounts:
              - name: kek                    # KEK only here — never in main container
                mountPath: /var/run/unkey/kek
                readOnly: true
              - name: env-shared
                mountPath: /env-shared

    containers:
        - name: deployment
          image: <user-image>
          command: ["/inject-bin/inject"]
          args: ["--", <resolved-entrypoint>]
          env:
              - name: UNKEY_ENV_FILE
                value: /env-shared/env.json
              - name: UNKEY_DEPLOYMENT_ID
                value: <deployment-id>
          volumeMounts:
              - name: inject-bin
                mountPath: /inject-bin
                readOnly: true
              - name: env-shared             # plaintext env vars, no KEK
                mountPath: /env-shared
                readOnly: true

    volumes:
        - name: inject-bin
          emptyDir:
              medium: Memory
        - name: env-shared                   # decrypted env vars passed between init and main
          emptyDir:
              medium: Memory
        - name: kek                          # only mounted in init container
          hostPath:
              path: /var/run/unkey/kek
              type: Directory

    imagePullSecrets:
        - name: <depot-pull-secret>
```

The inject image serves double duty: in the init container it decrypts and writes the env file, in the main container it reads the env file, sets env vars, and exec's the customer process. The KEK volume is only mounted on the init container — the main container (and therefore customer code) can never access it.

### Image Entrypoint Resolution

When a user deploys an image without specifying a command, the container's ENTRYPOINT/CMD must be resolved. Currently preflight does this by querying the registry. In the new system, ctrl-worker resolves the entrypoint at deploy time (it already builds images via Depot and has registry access). The resolved command is passed to Krane via a new `resolved_command` field on `ApplyDeployment`.

### Depot Pull Tokens

**Current problem**: Preflight webhook fetches per-pod Depot pull tokens (55-min TTL) via `GetPullToken(projectID, buildID)`. Per-pod fetching is fragile and wasteful.

**New approach**: Per-deployment tokens, created at deploy time by ctrl-worker.

At deploy time (after building the image):

1. ctrl-worker calls `GetPullToken(projectID, buildID)` — once per deployment, not once per pod
2. Creates a K8s `imagePullSecret` in the workspace namespace
3. Passes the secret name to Krane via a new `image_pull_secret_name` field on `ApplyDeployment`
4. Krane sets `spec.imagePullSecrets` on the ReplicaSet

Token refresh via a Restate periodic handler in ctrl-worker (follows the existing `ScaleDownIdlePreviewDeployments` pattern):

1. Runs every 30 minutes
2. Lists active deployments with Depot images
3. For each deployment whose pull token expires within 15 minutes: fetch a fresh token and update the K8s Secret in-place

## Resilience

### Object store (S3) goes down

**Impact: None on running pods or new pods on existing nodes.** The KEK is already decrypted and on tmpfs. The object store is only needed when kek-agent starts on a fresh node or during KEK rotation. If S3 is down for hours, everything keeps working on existing nodes. New nodes joining the cluster would be blocked until S3 recovers.

### kek-agent DaemonSet pod dies

**Impact: None on running pods. New pods can still start.** The KEK file lives on the host's tmpfs, not inside the DaemonSet pod. The DaemonSet pod is only needed for initial KEK fetch/decrypt (once per node boot) and KEK rotation. If the DaemonSet pod is gone for hours, everything keeps working.

### Node reboots

**Impact: Brief, self-healing.** tmpfs is wiped on reboot. kek-agent runs with `system-node-critical` priority so it starts before user pods. If a user pod somehow starts first, the KEK file is missing, inject fails, K8s retries with backoff, kek-agent writes KEK, retry succeeds.

### Vault goes down

**Impact: Zero on running pods. New deployments blocked.** Vault is only called at deploy time. Running pods, pod restarts, and scaling up are all unaffected. This is a massive improvement over today, where Vault being down means pods can't start at all.

### ctrl-worker goes down

**Impact: Same as today.** No new deployments, but existing pods unaffected.

### Sealed envelope is corrupted or wrong KEK

**Impact: Specific deployment fails. Clear error.** The inject binary logs exactly what failed:

- "KEK file not found at /var/run/unkey/kek/kek.json" → kek-agent issue
- "No KEK found matching kek_id 'kek-2026-02'" → rotation issue, KEK removed too early
- "Failed to unwrap DEK: authentication failed" → wrong KEK or corrupted envelope
- "Failed to decrypt payload: authentication failed" → corrupted payload

One deployment's failure never affects another. Each deployment has its own DEK.

## KEK Rotation

Three steps:

1. **Add new KEK**: Upload a new encrypted KEK file to the object store containing both old and new keys. kek-agent's periodic re-fetch picks it up on all nodes automatically. Nothing breaks — old envelopes still decrypt with the old key.
2. **Force re-deploy everything**: Trigger a new deployment for all active deployments. ctrl-worker re-seals each with the new KEK. As pods roll, they start using envelopes sealed with the new key.
3. **Remove old KEK**: Once no active deployment uses the old `kek_id` (query the DB), upload a KEK file with only the new key.

At no point does any pod fail. Old pods keep using old KEK until they're replaced. New pods use new KEK. Both keys coexist in the file throughout the transition.

For emergency rotation (KEK compromised), same three steps but do step 2 immediately for all deployments rather than waiting for natural churn.

## Proto and Code Changes

### New proto

`proto/envelope/v1/sealed_envelope.proto` — `SealedEnvelope` message with fields: `version`, `kek_id`, `wrapped_dek`, `nonce_dek`, `encrypted_payload`, `nonce_payload`, `deployment_id`, `created_at`. Serialized and base64-encoded as the `UNKEY_SEALED_ENV` env var value.

### Modified proto

`svc/ctrl/proto/ctrl/v1/cluster.proto` — Add to `ApplyDeployment`:

- `bytes sealed_envelope = 18` — the sealed envelope (when present, Krane builds the full inject pod spec)
- `repeated string resolved_command = 19` — resolved container entrypoint for inject's `--` args
- `string image_pull_secret_name = 20` — K8s imagePullSecret name for Depot images

### New packages

| Package           | Path                               | Purpose                                                                                                            |
| ----------------- | ---------------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| envelope          | `pkg/envelope/`                    | `Seal(kek, kekID, payload) → SealedEnvelope` and `Open(keks, sealed) → payload`. AES-256-GCM. KEK file loading.    |
| envelope provider | `pkg/secrets/provider/envelope.go` | Implements `Provider` interface. Reads KEK from local file, calls `envelope.Open()`, returns env vars. No network. |
| kek-agent         | `svc/kek-agent/`                   | DaemonSet service. Fetches encrypted KEK from object store, decrypts with root key, writes to host tmpfs. Periodic re-fetch for rotation. Health endpoint. |

### Modified packages

| Package           | Path                                                 | Change                                                                                                                                                                                                             |
| ----------------- | ---------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| inject            | `cmd/inject/`                                        | Rewrite with two modes: `decrypt` (init container, reads KEK, writes env file) and default (main container, reads env file, exec's process). Remove krane-vault provider. |
| deployment create | `svc/ctrl/services/deployment/create_deployment.go`  | Call `vault.DecryptBulk` to get plaintext values, seal with `envelope.Seal()`, store sealed envelope in deployment row                                                                  |
| cluster service   | `svc/ctrl/services/cluster/rpc_watch_deployments.go` | Pass `sealed_envelope` field through from deployment row to `ApplyDeployment`                                                                                                                                      |
| krane apply       | `svc/krane/internal/deployment/apply.go`             | When `sealed_envelope` is present: add init container, volumes, inject command wrapper, envelope env vars                                                                                                          |

### New manifests

`dev/k8s/manifests/kek-agent.yaml` — DaemonSet with `system-node-critical` priority, hostPath volume mount to `/var/run/unkey/kek`, KEK source config.

## Migration

Clean cutover. Deploy everything, force re-deploy all active deployments, delete the old pipeline.

1. Deploy kek-agent DaemonSet — writes KEK to all nodes
2. Deploy new inject binary, updated Krane, updated ctrl-worker
3. Force re-deploy all active deployments — they get sealed envelopes and the new pod spec
4. Delete preflight `MutatingWebhookConfiguration`, preflight service, Krane SecretsService, old provider code

## What Gets Deleted (after full migration)

| Component            | Path                                  | Why                           |
| -------------------- | ------------------------------------- | ----------------------------- |
| Preflight service    | `svc/preflight/`                      | Webhook no longer needed      |
| Preflight manifest   | `dev/k8s/manifests/preflight.yaml`    | No more webhook               |
| Krane SecretsService | `svc/krane/secrets/`                  | No more runtime decryption    |
| KraneVault provider  | `pkg/secrets/provider/krane_vault.go` | Replaced by envelope provider |


## Security Model Comparison

| Property                       | Current                                  | New                                                                |
| ------------------------------ | ---------------------------------------- | ------------------------------------------------------------------ |
| Secrets at rest                | Vault-encrypted per-value in DB          | Same in DB + sealed in envelope in pod spec                        |
| Secrets in transit             | Over network: inject → Krane → Vault     | No transit — decrypted locally                                     |
| Secrets in memory              | inject process only (exec replaces)      | Same — inject process only                                         |
| KEK storage                    | N/A (Vault config file)                  | Encrypted in object store (root key), plaintext only on node tmpfs |
| SPOF at pod startup            | Preflight + Krane + Vault all must be up | None. Vault only at deploy time.                                   |
| Blast radius of key compromise | Vault master key = all secrets           | KEK = all secrets (same scope, but KEK in memory vs Vault on disk) |
| Authentication                 | K8s SA token validated by Krane          | Possession of KEK file (host-level, RBAC + node isolation)         |
| KEK exposure to customer code  | N/A                                      | None — KEK only in init container, never in main container         |

## Drawbacks

- **KEK is a cluster-wide secret**: A compromised KEK exposes all sealed envelopes. This is the same blast radius as the current Vault master key, but the KEK lives in memory on every node rather than in a single Vault instance. Mitigated by: three-layer encryption (root key → KEK → DEK → secrets), KEK encrypted at rest in object store, plaintext only on tmpfs (never on disk), RBAC on hostPath, gvisor isolation for user workloads, and the fact that an attacker also needs access to the pod specs (K8s API) to get the sealed envelopes.


## Alternatives

**Kubernetes Secrets with CSI driver**: Use K8s Secrets for env vars and mount via CSI. Rejected because it introduces a dependency on the K8s API server at pod startup (same class of problem we're solving) and doesn't leverage Vault's existing encryption.

**Vault Agent sidecar**: Run a Vault Agent sidecar in every pod to handle secret retrieval. Rejected because it adds resource overhead per pod, still requires Vault to be available at pod startup, and is more complex to operate than a static file on the node.

**Sealed Secrets (Bitnami)**: Encrypt secrets with a cluster-side controller. Rejected because it's designed for GitOps workflows (encrypted secrets in git), not runtime injection, and would require significant adaptation to fit the Unkey deployment model.

## Unresolved Questions

- **Per-environment KEKs**: Should there be separate KEKs per environment rather than a single cluster-wide KEK? This reduces blast radius but increases operational complexity (more keys to manage, rotate, distribute). The current design uses a single KEK for simplicity; per-environment KEKs can be added later by using the `kek_id` field to route to different keys.
