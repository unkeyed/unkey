---
title: "Unkey in 5 Minutes"
description: "From zero to production-ready API authentication in 5 minutes"
---

Get started with Unkey and protect your first API endpoint in under 5 minutes. No complex setup, no infrastructure to manage‚Äîjust secure API keys that work at any scale.

## What You'll Build

By the end of this guide, you'll have:
- ‚úÖ A Unkey workspace with an API
- ‚úÖ API key creation and verification
- ‚úÖ Rate limiting to prevent abuse
- ‚úÖ A protected endpoint in your language of choice

## Minute 1: Create Your Account

1. Go to [app.unkey.com](https://app.unkey.com) and sign up (free)
2. Create a new workspace
3. Create your first API at **APIs ‚Üí Create API**
4. Copy your **API ID** (looks like `api_xxxx`)

<Note>
No credit card required. The free tier includes 2,500 API keys and unlimited verifications.
</Note>

## Minute 2: Get Your Root Key

Your root key authenticates your backend to Unkey's API:

1. Go to **Settings ‚Üí Root Keys**
2. Click **Create New Root Key**
3. Name it "Production Backend"
4. Select these permissions:
   - `api_key.create`
   - `api_key.verify`
   - `ratelimit.limit`
5. **Copy the key immediately** ‚Äî you won't see it again

Store it as an environment variable:

```bash
export UNKEY_ROOT_KEY="unkey_xxxx"
```

<Warning>
Never expose your root key in client-side code or commit it to git. It has full access to your workspace.
</Warning>

## Minute 3: Install the SDK

Choose your language:

<CodeGroup>

```bash TypeScript
npm install @unkey/api
```

```bash Python
pip install unkey.py
```

```bash Go
go get github.com/unkeyed/sdks/api/go/v2@latest
```

</CodeGroup>

## Minute 4: Create and Verify a Key

Here's a complete example that creates a key and verifies it:

<CodeGroup>

```typescript TypeScript
import { Unkey } from "@unkey/api";

const unkey = new Unkey({ rootKey: process.env.UNKEY_ROOT_KEY });

// Create a key for a user
const { result: created } = await unkey.keys.create({
  apiId: "api_xxxx",  // Your API ID
  prefix: "sk_live",
  name: "User's Production Key",
  meta: {
    userId: "user_123",
    plan: "pro"
  },
  ratelimit: {
    limit: 1000,
    duration: 60000  // 1000 requests per minute
  }
});

console.log("Give this key to your user:", created.key);
// ‚ö†Ô∏è This is the only time you'll see the full key!

// Later, verify the key on an incoming request
const { result: verified } = await unkey.keys.verify({
  key: "sk_live_..."  // From request header
});

if (!verified.valid) {
  console.log("Access denied:", verified.code);
  // Codes: NOT_FOUND, RATE_LIMITED, EXPIRED, DISABLED
} else {
  console.log("Access granted! Key ID:", verified.keyId);
  console.log("Rate limit remaining:", verified.ratelimits?.[0]?.remaining);
}
```

```python Python
from unkey import Unkey

unkey = Unkey(root_key="unkey_xxxx")

# Create a key for a user
result = unkey.keys.create_key(
    api_id="api_xxxx",  # Your API ID
    prefix="sk_live",
    name="User's Production Key",
    meta={
        "userId": "user_123",
        "plan": "pro"
    },
    ratelimit={
        "limit": 1000,
        "duration": 60000  # 1000 requests per minute
    }
)

print("Give this key to your user:", result.key)
# ‚ö†Ô∏è This is the only time you'll see the full key!

# Later, verify the key on an incoming request
verified = unkey.keys.verify_key(key="sk_live_...")

if not verified.valid:
    print(f"Access denied: {verified.code}")
    # Codes: NOT_FOUND, RATE_LIMITED, EXPIRED, DISABLED
else:
    print(f"Access granted! Key ID: {verified.key_id}")
    if verified.ratelimits:
        print(f"Rate limit remaining: {verified.ratelimits[0].remaining}")
```

```go Go
package main

import (
    "context"
    "fmt"
    "os"

    unkey "github.com/unkeyed/sdks/api/go/v2"
    "github.com/unkeyed/sdks/api/go/v2/models/components"
)

func main() {
    client := unkey.New(
        unkey.WithSecurity(os.Getenv("UNKEY_ROOT_KEY")),
    )

    ctx := context.Background()

    // Create a key for a user
    created, _ := client.Keys.CreateKey(ctx, components.V2KeysCreateKeyRequestBody{
        APIID: "api_xxxx",  // Your API ID
        Prefix: stringPtr("sk_live"),
        Name: stringPtr("User's Production Key"),
        Meta: map[string]any{
            "userId": "user_123",
            "plan": "pro",
        },
        Ratelimit: &components.RatelimitData{
            Limit:     1000,
            Duration:  60000,  // 1000 requests per minute
        },
    })

    fmt.Println("Give this key to your user:", created.V2KeysCreateKeyResponseBody.Key)
    // ‚ö†Ô∏è This is the only time you'll see the full key!

    // Later, verify the key on an incoming request
    verified, _ := client.Keys.VerifyKey(ctx, components.V2KeysVerifyKeyRequestBody{
        Key: "sk_live_...",
    })

    if !verified.V2KeysVerifyKeyResponseBody.Valid {
        fmt.Println("Access denied:", *verified.V2KeysVerifyKeyResponseBody.Code)
        // Codes: NOT_FOUND, RATE_LIMITED, EXPIRED, DISABLED
    } else {
        fmt.Println("Access granted! Key ID:", verified.V2KeysVerifyKeyResponseBody.KeyID)
    }
}

func stringPtr(s string) *string { return &s }
```

</CodeGroup>

## Minute 5: Protect Your Endpoint

Add authentication to your API endpoint:

<CodeGroup>

```typescript Next.js
import { verifyKey } from "@unkey/api";
import { NextRequest, NextResponse } from "next/server";

export async function GET(req: NextRequest) {
  const key = req.headers.get("authorization")?.replace("Bearer ", "") ?? "";
  
  const { result } = await verifyKey({ key });
  
  if (!result.valid) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  
  return NextResponse.json({ 
    message: "Hello!",
    keyId: result.keyId 
  });
}
```

```python FastAPI
from fastapi import FastAPI, Header, HTTPException
from unkey import Unkey

app = FastAPI()
unkey = Unkey(root_key="unkey_xxxx")

@app.get("/api/hello")
async def hello(x_api_key: str = Header(..., alias="X-API-Key")):
    result = unkey.keys.verify_key(key=x_api_key)
    
    if not result.valid:
        raise HTTPException(status_code=401, detail=result.code)
    
    return {"message": "Hello!", "key_id": result.key_id}
```

```go Gin
package main

import (
    "net/http"
    "strings"

    "github.com/gin-gonic/gin"
    unkey "github.com/unkeyed/sdks/api/go/v2"
    "github.com/unkeyed/sdks/api/go/v2/models/components"
)

func main() {
    r := gin.Default()
    client := unkey.New(unkey.WithSecurity("unkey_xxxx"))
    
    r.GET("/api/hello", func(c *gin.Context) {
        auth := c.GetHeader("Authorization")
        key := strings.TrimPrefix(auth, "Bearer ")
        
        res, _ := client.Keys.VerifyKey(c, components.V2KeysVerifyKeyRequestBody{
            Key: key,
        })
        
        if !res.V2KeysVerifyKeyResponseBody.Valid {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
            return
        }
        
        c.JSON(http.StatusOK, gin.H{
            "message": "Hello!",
            "keyId": res.V2KeysVerifyKeyResponseBody.KeyID,
        })
    })
    
    r.Run(":8080")
}
```

</CodeGroup>

Test your protected endpoint:

```bash
curl -H "X-API-Key: YOUR_KEY" http://localhost:3000/api/hello
# {"message":"Hello!","keyId":"key_xxxx"}

curl -H "X-API-Key: invalid_key" http://localhost:3000/api/hello
# {"error":"Unauthorized"}
```

## üéâ You're Done!

You now have:
- ‚úÖ Secure API key authentication
- ‚úÖ Automatic rate limiting
- ‚úÖ Key metadata and permissions
- ‚úÖ Detailed analytics in your dashboard

## What's Next?

<CardGroup cols={2}>
  <Card title="Add Rate Limiting" icon="gauge-high" href="/ratelimiting/introduction">
    Protect your APIs from abuse with advanced rate limiting
  </Card>
  <Card title="Authorization" icon="user-shield" href="/apis/features/authorization/introduction">
    Add roles and permissions for fine-grained access control
  </Card>
  <Card title="Usage Analytics" icon="chart-line" href="/analytics/introduction">
    Monitor API usage and key activity
  </Card>
  <Card title="SDK Reference" icon="book" href="/libraries/ts/overview">
    Explore the full SDK capabilities
  </Card>
</CardGroup>

## Production Checklist

Before going live:

- [ ] Store `UNKEY_ROOT_KEY` securely (environment variable, secrets manager)
- [ ] Implement proper error handling for Unkey API failures
- [ ] Add retry logic for transient errors
- [ ] Set up monitoring for rate limit hits
- [ ] Configure key expiration for temporary access
- [ ] Add logging for security events

<Note>
Need help? Join our [Discord community](https://unkey.com/discord) or email support@unkey.dev
</Note>
