// @generated by protoc-gen-es v2.8.0 with parameter "target=ts"
// @generated from file policies/v1/keyauth.proto (package sentinel.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file policies/v1/keyauth.proto.
 */
export const file_policies_v1_keyauth: GenFile = /*@__PURE__*/
  fileDesc("Chlwb2xpY2llcy92MS9rZXlhdXRoLnByb3RvEgtzZW50aW5lbC52MSKBAQoHS2V5QXV0aBIVCg1rZXlfc3BhY2VfaWRzGAEgAygJEisKCWxvY2F0aW9ucxgCIAMoCzIYLnNlbnRpbmVsLnYxLktleUxvY2F0aW9uEh0KEHBlcm1pc3Npb25fcXVlcnkYBSABKAlIAIgBAUITChFfcGVybWlzc2lvbl9xdWVyeSK6AQoLS2V5TG9jYXRpb24SMgoGYmVhcmVyGAEgASgLMiAuc2VudGluZWwudjEuQmVhcmVyVG9rZW5Mb2NhdGlvbkgAEjAKBmhlYWRlchgCIAEoCzIeLnNlbnRpbmVsLnYxLkhlYWRlcktleUxvY2F0aW9uSAASOQoLcXVlcnlfcGFyYW0YAyABKAsyIi5zZW50aW5lbC52MS5RdWVyeVBhcmFtS2V5TG9jYXRpb25IAEIKCghsb2NhdGlvbiIVChNCZWFyZXJUb2tlbkxvY2F0aW9uIjcKEUhlYWRlcktleUxvY2F0aW9uEgwKBG5hbWUYASABKAkSFAoMc3RyaXBfcHJlZml4GAIgASgJIiUKFVF1ZXJ5UGFyYW1LZXlMb2NhdGlvbhIMCgRuYW1lGAEgASgJQqcBCg9jb20uc2VudGluZWwudjFCDEtleWF1dGhQcm90b1ABWjlnaXRodWIuY29tL3Vua2V5ZWQvdW5rZXkvZ2VuL3Byb3RvL3NlbnRpbmVsL3YxO3NlbnRpbmVsdjGiAgNTWFiqAgtTZW50aW5lbC5WMcoCC1NlbnRpbmVsXFYx4gIXU2VudGluZWxcVjFcR1BCTWV0YWRhdGHqAgxTZW50aW5lbDo6VjFiBnByb3RvMw");

/**
 * KeyAuth authenticates requests using Unkey API keys. This is the primary
 * authentication mechanism for sentinel because API key management is Unkey's
 * core product. When a request arrives, sentinel extracts the key from the
 * configured location, verifies it against the specified Unkey key space, and
 * on success produces a [Principal] with type PRINCIPAL_TYPE_API_KEY.
 *
 * The verification call to Unkey returns rich metadata about the key: its
 * owner identity, associated permissions, remaining quota, rate limit state,
 * and custom metadata. This information flows into the [Principal] and is
 * available to downstream policies. For example, a RateLimit policy can
 * throttle by the key's owner rather than by IP, and the permission_query
 * field lets you enforce Unkey RBAC permissions at the gateway without a
 * separate policy.
 *
 * KeyAuth pairs naturally with Unkey's key lifecycle features. Keys created
 * with expiration dates, remaining usage counts, or rate limits are enforced
 * at the gateway level without any application code. This turns sentinel
 * into a full API management layer for Unkey customers.
 *
 * @generated from message sentinel.v1.KeyAuth
 */
export type KeyAuth = Message<"sentinel.v1.KeyAuth"> & {
  /**
   * The Unkey key space (API) ID to authenticate against. Each key space
   * contains a set of API keys with shared configuration. This determines
   * which keys are valid for this policy.
   *
   * @generated from field: repeated string key_space_ids = 1;
   */
  keySpaceIds: string[];

  /**
   * Ordered list of locations to extract the API key from. Sentinel tries
   * each location in order and uses the first one that yields a non-empty
   * value. This allows APIs to support multiple key delivery mechanisms
   * simultaneously (e.g., Bearer token for programmatic clients and a query
   * parameter for browser-based debugging).
   *
   * If empty, defaults to extracting from the Authorization header as a
   * Bearer token, which is the most common convention for API authentication.
   *
   * @generated from field: repeated sentinel.v1.KeyLocation locations = 2;
   */
  locations: KeyLocation[];

  /**
   * Optional permission query evaluated against the key's permissions
   * returned by Unkey's verify API. Uses the same query language as
   * pkg/rbac.ParseQuery: AND and OR operators with parenthesized grouping,
   * where AND has higher precedence than OR.
   *
   * Permission names may contain alphanumeric characters, dots, underscores,
   * hyphens, colons, asterisks, and forward slashes. Asterisks are literal
   * characters, not wildcards.
   *
   * Examples:
   *
   *   "api.keys.create"
   *   "api.keys.read AND api.keys.update"
   *   "billing.read OR billing.admin"
   *   "(api.keys.read OR api.keys.list) AND billing.read"
   *
   * When set, sentinel rejects the request with 403 if the key lacks the
   * required permissions. When empty, no permission check is performed.
   *
   * Limits: maximum 1000 characters, maximum 100 permission terms.
   *
   * @generated from field: optional string permission_query = 5;
   */
  permissionQuery?: string;
};

/**
 * Describes the message sentinel.v1.KeyAuth.
 * Use `create(KeyAuthSchema)` to create a new message.
 */
export const KeyAuthSchema: GenMessage<KeyAuth> = /*@__PURE__*/
  messageDesc(file_policies_v1_keyauth, 0);

/**
 * KeyLocation specifies where in the HTTP request to look for an API key.
 * Multiple locations can be configured on a [KeyAuth] policy to support
 * different client conventions. Sentinel tries each location in order and
 * uses the first one that yields a non-empty value.
 *
 * @generated from message sentinel.v1.KeyLocation
 */
export type KeyLocation = Message<"sentinel.v1.KeyLocation"> & {
  /**
   * @generated from oneof sentinel.v1.KeyLocation.location
   */
  location: {
    /**
     * Extract from the standard Authorization: Bearer <token> header. This
     * is the most common API key delivery mechanism and the default when no
     * locations are configured.
     *
     * @generated from field: sentinel.v1.BearerTokenLocation bearer = 1;
     */
    value: BearerTokenLocation;
    case: "bearer";
  } | {
    /**
     * Extract from a custom request header. Useful for APIs that use
     * non-standard headers like X-API-Key or X-Auth-Token.
     *
     * @generated from field: sentinel.v1.HeaderKeyLocation header = 2;
     */
    value: HeaderKeyLocation;
    case: "header";
  } | {
    /**
     * Extract from a URL query parameter. Useful for webhook callbacks or
     * situations where headers cannot be set, but less secure since query
     * parameters appear in server logs and browser history.
     *
     * @generated from field: sentinel.v1.QueryParamKeyLocation query_param = 3;
     */
    value: QueryParamKeyLocation;
    case: "queryParam";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message sentinel.v1.KeyLocation.
 * Use `create(KeyLocationSchema)` to create a new message.
 */
export const KeyLocationSchema: GenMessage<KeyLocation> = /*@__PURE__*/
  messageDesc(file_policies_v1_keyauth, 1);

/**
 * BearerTokenLocation extracts the API key from the Authorization header
 * using the Bearer scheme (RFC 6750). Sentinel parses the header value,
 * strips the "Bearer " prefix, and uses the remainder as the API key.
 *
 * @generated from message sentinel.v1.BearerTokenLocation
 */
export type BearerTokenLocation = Message<"sentinel.v1.BearerTokenLocation"> & {
};

/**
 * Describes the message sentinel.v1.BearerTokenLocation.
 * Use `create(BearerTokenLocationSchema)` to create a new message.
 */
export const BearerTokenLocationSchema: GenMessage<BearerTokenLocation> = /*@__PURE__*/
  messageDesc(file_policies_v1_keyauth, 2);

/**
 * HeaderKeyLocation extracts the API key from a named request header. This
 * supports APIs that use custom authentication headers instead of the
 * standard Authorization header.
 *
 * @generated from message sentinel.v1.HeaderKeyLocation
 */
export type HeaderKeyLocation = Message<"sentinel.v1.HeaderKeyLocation"> & {
  /**
   * The header name to read, e.g. "X-API-Key". Matched case-insensitively
   * per HTTP semantics.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * If set, this prefix is stripped from the header value before the
   * remainder is used as the API key. For example, with name "Authorization"
   * and strip_prefix "ApiKey ", a header value "ApiKey sk_live_abc123"
   * yields key "sk_live_abc123".
   *
   * @generated from field: string strip_prefix = 2;
   */
  stripPrefix: string;
};

/**
 * Describes the message sentinel.v1.HeaderKeyLocation.
 * Use `create(HeaderKeyLocationSchema)` to create a new message.
 */
export const HeaderKeyLocationSchema: GenMessage<HeaderKeyLocation> = /*@__PURE__*/
  messageDesc(file_policies_v1_keyauth, 3);

/**
 * QueryParamKeyLocation extracts the API key from a URL query parameter.
 *
 * @generated from message sentinel.v1.QueryParamKeyLocation
 */
export type QueryParamKeyLocation = Message<"sentinel.v1.QueryParamKeyLocation"> & {
  /**
   * The query parameter name, e.g. "api_key" or "token".
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message sentinel.v1.QueryParamKeyLocation.
 * Use `create(QueryParamKeyLocationSchema)` to create a new message.
 */
export const QueryParamKeyLocationSchema: GenMessage<QueryParamKeyLocation> = /*@__PURE__*/
  messageDesc(file_policies_v1_keyauth, 4);

