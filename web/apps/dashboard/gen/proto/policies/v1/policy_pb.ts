// @generated by protoc-gen-es v2.8.0 with parameter "target=ts"
// @generated from file policies/v1/policy.proto (package sentinel.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { BasicAuth } from "./basicauth_pb";
import { file_policies_v1_basicauth } from "./basicauth_pb";
import type { IPRules } from "./iprules_pb";
import { file_policies_v1_iprules } from "./iprules_pb";
import type { JWTAuth } from "./jwtauth_pb";
import { file_policies_v1_jwtauth } from "./jwtauth_pb";
import type { KeyAuth } from "./keyauth_pb";
import { file_policies_v1_keyauth } from "./keyauth_pb";
import type { MatchExpr } from "./match_pb";
import { file_policies_v1_match } from "./match_pb";
import type { OpenApiRequestValidation } from "./openapi_pb";
import { file_policies_v1_openapi } from "./openapi_pb";
import type { RateLimit } from "./ratelimit_pb";
import { file_policies_v1_ratelimit } from "./ratelimit_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file policies/v1/policy.proto.
 */
export const file_policies_v1_policy: GenFile = /*@__PURE__*/
  fileDesc("Chhwb2xpY2llcy92MS9wb2xpY3kucHJvdG8SC3NlbnRpbmVsLnYxIvQCCgZQb2xpY3kSCgoCaWQYASABKAkSDAoEbmFtZRgCIAEoCRIPCgdlbmFibGVkGAMgASgIEiUKBW1hdGNoGAQgAygLMhYuc2VudGluZWwudjEuTWF0Y2hFeHByEicKB2tleWF1dGgYBSABKAsyFC5zZW50aW5lbC52MS5LZXlBdXRoSAASJwoHand0YXV0aBgGIAEoCzIULnNlbnRpbmVsLnYxLkpXVEF1dGhIABIrCgliYXNpY2F1dGgYByABKAsyFi5zZW50aW5lbC52MS5CYXNpY0F1dGhIABIrCglyYXRlbGltaXQYCCABKAsyFi5zZW50aW5lbC52MS5SYXRlTGltaXRIABIoCghpcF9ydWxlcxgJIAEoCzIULnNlbnRpbmVsLnYxLklQUnVsZXNIABI4CgdvcGVuYXBpGAogASgLMiUuc2VudGluZWwudjEuT3BlbkFwaVJlcXVlc3RWYWxpZGF0aW9uSABCCAoGY29uZmlnQqYBCg9jb20uc2VudGluZWwudjFCC1BvbGljeVByb3RvUAFaOWdpdGh1Yi5jb20vdW5rZXllZC91bmtleS9nZW4vcHJvdG8vc2VudGluZWwvdjE7c2VudGluZWx2MaICA1NYWKoCC1NlbnRpbmVsLlYxygILU2VudGluZWxcVjHiAhdTZW50aW5lbFxWMVxHUEJNZXRhZGF0YeoCDFNlbnRpbmVsOjpWMWIGcHJvdG8z", [file_policies_v1_basicauth, file_policies_v1_iprules, file_policies_v1_jwtauth, file_policies_v1_keyauth, file_policies_v1_match, file_policies_v1_openapi, file_policies_v1_ratelimit]);

/**
 * Policy is a single middleware layer in a deployment's configuration. Each policy
 * combines a match expression (which requests does it apply to?) with a
 * configuration (what does it do?). This separation is what makes the system
 * composable: the same rate limiter config can be scoped to POST /api/*
 * without the rate limiter needing to know anything about path matching.
 *
 * Policies carry a stable id for correlation across logs, metrics, and
 * debugging. The disabled flag allows operators to disable a policy without
 * removing it from config, which is critical for incident response — you can
 * turn off a misbehaving policy and re-enable it once the issue is resolved,
 * without losing the configuration or triggering a full redeploy.
 *
 * @generated from message sentinel.v1.Policy
 */
export type Policy = Message<"sentinel.v1.Policy"> & {
  /**
   * Stable identifier for this policy, used in log entries, metrics labels,
   * and error messages. Should be unique within a deployment's Middleware
   * config. Typically a UUID or a slug like "api-ratelimit".
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Human-friendly label displayed in the dashboard and audit logs.
   * Does not affect policy behavior.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * When false, sentinel skips this policy entirely during evaluation.
   * This allows operators to toggle policies on and off without modifying
   * or removing the underlying configuration, which is useful during
   * incidents, gradual rollouts, and debugging.
   *
   * @generated from field: bool enabled = 3;
   */
  enabled: boolean;

  /**
   * Match conditions that determine which requests this policy applies to.
   * All entries must match for the policy to run (implicit AND). An empty
   * list matches all requests — this is the common case for global policies
   * like IP allowlists or rate limiting.
   *
   * For OR semantics, create separate policies with the same config and
   * different match lists.
   *
   * @generated from field: repeated sentinel.v1.MatchExpr match = 4;
   */
  match: MatchExpr[];

  /**
   * The policy configuration. Exactly one must be set.
   *
   * @generated from oneof sentinel.v1.Policy.config
   */
  config: {
    /**
     * @generated from field: sentinel.v1.KeyAuth keyauth = 5;
     */
    value: KeyAuth;
    case: "keyauth";
  } | {
    /**
     * @generated from field: sentinel.v1.JWTAuth jwtauth = 6;
     */
    value: JWTAuth;
    case: "jwtauth";
  } | {
    /**
     * @generated from field: sentinel.v1.BasicAuth basicauth = 7;
     */
    value: BasicAuth;
    case: "basicauth";
  } | {
    /**
     * @generated from field: sentinel.v1.RateLimit ratelimit = 8;
     */
    value: RateLimit;
    case: "ratelimit";
  } | {
    /**
     * @generated from field: sentinel.v1.IPRules ip_rules = 9;
     */
    value: IPRules;
    case: "ipRules";
  } | {
    /**
     * @generated from field: sentinel.v1.OpenApiRequestValidation openapi = 10;
     */
    value: OpenApiRequestValidation;
    case: "openapi";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message sentinel.v1.Policy.
 * Use `create(PolicySchema)` to create a new message.
 */
export const PolicySchema: GenMessage<Policy> = /*@__PURE__*/
  messageDesc(file_policies_v1_policy, 0);

