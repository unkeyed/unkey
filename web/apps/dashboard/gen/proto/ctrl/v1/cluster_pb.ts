// @generated by protoc-gen-es v2.8.0 with parameter "target=ts"
// @generated from file ctrl/v1/cluster.proto (package ctrl.v1, syntax proto3)
/* eslint-disable */

// Package ctrl.v1 provides the Cluster service for multi-cluster deployment orchestration.
//
// The Cluster service enables a central control plane to coordinate deployments and sentinels
// across multiple Kubernetes clusters. Each cluster runs an agent (such as krane) that establishes
// a long-lived watch connection to receive deployment and sentinel configuration events.
//
// This design follows the Kubernetes watch pattern where agents (like kubelet) maintain
// a streaming connection to receive incremental updates, enabling real-time deployment
// orchestration across distributed clusters.

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file ctrl/v1/cluster.proto.
 */
export const file_ctrl_v1_cluster: GenFile = /*@__PURE__*/
  fileDesc("ChVjdHJsL3YxL2NsdXN0ZXIucHJvdG8SB2N0cmwudjEiTgohV2F0Y2hDaWxpdW1OZXR3b3JrUG9saWNpZXNSZXF1ZXN0Eg4KBnJlZ2lvbhgBIAEoCRIZChF2ZXJzaW9uX2xhc3Rfc2VlbhgCIAEoBCJ1ChhBcHBseUNpbGl1bU5ldHdvcmtQb2xpY3kSFQoNazhzX25hbWVzcGFjZRgBIAEoCRIQCghrOHNfbmFtZRgCIAEoCRIgChhjaWxpdW1fbmV0d29ya19wb2xpY3lfaWQYAyABKAkSDgoGcG9saWN5GAQgASgMIkQKGURlbGV0ZUNpbGl1bU5ldHdvcmtQb2xpY3kSFQoNazhzX25hbWVzcGFjZRgBIAEoCRIQCghrOHNfbmFtZRgCIAEoCSKeAQoYQ2lsaXVtTmV0d29ya1BvbGljeVN0YXRlEg8KB3ZlcnNpb24YAyABKAQSMgoFYXBwbHkYASABKAsyIS5jdHJsLnYxLkFwcGx5Q2lsaXVtTmV0d29ya1BvbGljeUgAEjQKBmRlbGV0ZRgCIAEoCzIiLmN0cmwudjEuRGVsZXRlQ2lsaXVtTmV0d29ya1BvbGljeUgAQgcKBXN0YXRlIk0KKUdldERlc2lyZWRDaWxpdW1OZXR3b3JrUG9saWN5U3RhdGVSZXF1ZXN0EiAKGGNpbGl1bV9uZXR3b3JrX3BvbGljeV9pZBgBIAEoCSI1Ch5HZXREZXNpcmVkU2VudGluZWxTdGF0ZVJlcXVlc3QSEwoLc2VudGluZWxfaWQYASABKAkiOQogR2V0RGVzaXJlZERlcGxveW1lbnRTdGF0ZVJlcXVlc3QSFQoNZGVwbG95bWVudF9pZBgBIAEoCSK3BAodUmVwb3J0RGVwbG95bWVudFN0YXR1c1JlcXVlc3QSPwoGdXBkYXRlGAEgASgLMi0uY3RybC52MS5SZXBvcnREZXBsb3ltZW50U3RhdHVzUmVxdWVzdC5VcGRhdGVIABI/CgZkZWxldGUYAiABKAsyLS5jdHJsLnYxLlJlcG9ydERlcGxveW1lbnRTdGF0dXNSZXF1ZXN0LkRlbGV0ZUgAGu0CCgZVcGRhdGUSEAoIazhzX25hbWUYASABKAkSSQoJaW5zdGFuY2VzGAIgAygLMjYuY3RybC52MS5SZXBvcnREZXBsb3ltZW50U3RhdHVzUmVxdWVzdC5VcGRhdGUuSW5zdGFuY2UahQIKCEluc3RhbmNlEhAKCGs4c19uYW1lGAEgASgJEg8KB2FkZHJlc3MYAiABKAkSFgoOY3B1X21pbGxpY29yZXMYAyABKAMSEgoKbWVtb3J5X21pYhgEIAEoAxJNCgZzdGF0dXMYBSABKA4yPS5jdHJsLnYxLlJlcG9ydERlcGxveW1lbnRTdGF0dXNSZXF1ZXN0LlVwZGF0ZS5JbnN0YW5jZS5TdGF0dXMiWwoGU3RhdHVzEhYKElNUQVRVU19VTlNQRUNJRklFRBAAEhIKDlNUQVRVU19QRU5ESU5HEAESEgoOU1RBVFVTX1JVTk5JTkcQAhIRCg1TVEFUVVNfRkFJTEVEEAMaGgoGRGVsZXRlEhAKCGs4c19uYW1lGAEgASgJQggKBmNoYW5nZSIgCh5SZXBvcnREZXBsb3ltZW50U3RhdHVzUmVzcG9uc2UibAobUmVwb3J0U2VudGluZWxTdGF0dXNSZXF1ZXN0EhAKCGs4c19uYW1lGAEgASgJEhoKEmF2YWlsYWJsZV9yZXBsaWNhcxgCIAEoBRIfCgZoZWFsdGgYAyABKA4yDy5jdHJsLnYxLkhlYWx0aCIeChxSZXBvcnRTZW50aW5lbFN0YXR1c1Jlc3BvbnNlIkQKF1dhdGNoRGVwbG95bWVudHNSZXF1ZXN0Eg4KBnJlZ2lvbhgBIAEoCRIZChF2ZXJzaW9uX2xhc3Rfc2VlbhgCIAEoBCJCChVXYXRjaFNlbnRpbmVsc1JlcXVlc3QSDgoGcmVnaW9uGAEgASgJEhkKEXZlcnNpb25fbGFzdF9zZWVuGAIgASgEIn0KDVNlbnRpbmVsU3RhdGUSDwoHdmVyc2lvbhgDIAEoBBInCgVhcHBseRgBIAEoCzIWLmN0cmwudjEuQXBwbHlTZW50aW5lbEgAEikKBmRlbGV0ZRgCIAEoCzIXLmN0cmwudjEuRGVsZXRlU2VudGluZWxIAEIHCgVzdGF0ZSKDAQoPRGVwbG95bWVudFN0YXRlEg8KB3ZlcnNpb24YAyABKAQSKQoFYXBwbHkYASABKAsyGC5jdHJsLnYxLkFwcGx5RGVwbG95bWVudEgAEisKBmRlbGV0ZRgCIAEoCzIZLmN0cmwudjEuRGVsZXRlRGVwbG95bWVudEgAQgcKBXN0YXRlIsUBCg1BcHBseVNlbnRpbmVsEhAKCGs4c19uYW1lGAEgASgJEhQKDHdvcmtzcGFjZV9pZBgCIAEoCRISCgpwcm9qZWN0X2lkGAMgASgJEhYKDmVudmlyb25tZW50X2lkGAQgASgJEhMKC3NlbnRpbmVsX2lkGAUgASgJEg0KBWltYWdlGAYgASgJEhAKCHJlcGxpY2FzGAcgASgFEhYKDmNwdV9taWxsaWNvcmVzGAggASgDEhIKCm1lbW9yeV9taWIYCSABKAMiIgoORGVsZXRlU2VudGluZWwSEAoIazhzX25hbWUYASABKAkipwMKD0FwcGx5RGVwbG95bWVudBIVCg1rOHNfbmFtZXNwYWNlGAEgASgJEhAKCGs4c19uYW1lGAIgASgJEhQKDHdvcmtzcGFjZV9pZBgDIAEoCRISCgpwcm9qZWN0X2lkGAQgASgJEhYKDmVudmlyb25tZW50X2lkGAUgASgJEhUKDWRlcGxveW1lbnRfaWQYBiABKAkSDQoFaW1hZ2UYByABKAkSEAoIcmVwbGljYXMYCCABKAUSFgoOY3B1X21pbGxpY29yZXMYCSABKAMSEgoKbWVtb3J5X21pYhgKIAEoAxIVCghidWlsZF9pZBgLIAEoCUgAiAEBEicKH2VuY3J5cHRlZF9lbnZpcm9ubWVudF92YXJpYWJsZXMYDCABKAwSDwoHY29tbWFuZBgNIAMoCRIMCgRwb3J0GA4gASgFEhYKDnJlc3RhcnRfcG9saWN5GA8gASgJEhcKD3NodXRkb3duX3NpZ25hbBgQIAEoCRIYCgtoZWFsdGhjaGVjaxgRIAEoDEgBiAEBQgsKCV9idWlsZF9pZEIOCgxfaGVhbHRoY2hlY2siOwoQRGVsZXRlRGVwbG95bWVudBIVCg1rOHNfbmFtZXNwYWNlGAEgASgJEhAKCGs4c19uYW1lGAIgASgJKl0KBkhlYWx0aBIWChJIRUFMVEhfVU5TUEVDSUZJRUQQABISCg5IRUFMVEhfSEVBTFRIWRABEhQKEEhFQUxUSF9VTkhFQUxUSFkQAhIRCg1IRUFMVEhfUEFVU0VEEAMyqAYKDkNsdXN0ZXJTZXJ2aWNlElAKEFdhdGNoRGVwbG95bWVudHMSIC5jdHJsLnYxLldhdGNoRGVwbG95bWVudHNSZXF1ZXN0GhguY3RybC52MS5EZXBsb3ltZW50U3RhdGUwARJKCg5XYXRjaFNlbnRpbmVscxIeLmN0cmwudjEuV2F0Y2hTZW50aW5lbHNSZXF1ZXN0GhYuY3RybC52MS5TZW50aW5lbFN0YXRlMAESWgoXR2V0RGVzaXJlZFNlbnRpbmVsU3RhdGUSJy5jdHJsLnYxLkdldERlc2lyZWRTZW50aW5lbFN0YXRlUmVxdWVzdBoWLmN0cmwudjEuU2VudGluZWxTdGF0ZRJjChRSZXBvcnRTZW50aW5lbFN0YXR1cxIkLmN0cmwudjEuUmVwb3J0U2VudGluZWxTdGF0dXNSZXF1ZXN0GiUuY3RybC52MS5SZXBvcnRTZW50aW5lbFN0YXR1c1Jlc3BvbnNlEmAKGUdldERlc2lyZWREZXBsb3ltZW50U3RhdGUSKS5jdHJsLnYxLkdldERlc2lyZWREZXBsb3ltZW50U3RhdGVSZXF1ZXN0GhguY3RybC52MS5EZXBsb3ltZW50U3RhdGUSaQoWUmVwb3J0RGVwbG95bWVudFN0YXR1cxImLmN0cmwudjEuUmVwb3J0RGVwbG95bWVudFN0YXR1c1JlcXVlc3QaJy5jdHJsLnYxLlJlcG9ydERlcGxveW1lbnRTdGF0dXNSZXNwb25zZRJtChpXYXRjaENpbGl1bU5ldHdvcmtQb2xpY2llcxIqLmN0cmwudjEuV2F0Y2hDaWxpdW1OZXR3b3JrUG9saWNpZXNSZXF1ZXN0GiEuY3RybC52MS5DaWxpdW1OZXR3b3JrUG9saWN5U3RhdGUwARJ7CiJHZXREZXNpcmVkQ2lsaXVtTmV0d29ya1BvbGljeVN0YXRlEjIuY3RybC52MS5HZXREZXNpcmVkQ2lsaXVtTmV0d29ya1BvbGljeVN0YXRlUmVxdWVzdBohLmN0cmwudjEuQ2lsaXVtTmV0d29ya1BvbGljeVN0YXRlQosBCgtjb20uY3RybC52MUIMQ2x1c3RlclByb3RvUAFaMWdpdGh1Yi5jb20vdW5rZXllZC91bmtleS9nZW4vcHJvdG8vY3RybC92MTtjdHJsdjGiAgNDWFiqAgdDdHJsLlYxygIHQ3RybFxWMeICE0N0cmxcVjFcR1BCTWV0YWRhdGHqAghDdHJsOjpWMWIGcHJvdG8z");

/**
 * @generated from message ctrl.v1.WatchCiliumNetworkPoliciesRequest
 */
export type WatchCiliumNetworkPoliciesRequest = Message<"ctrl.v1.WatchCiliumNetworkPoliciesRequest"> & {
  /**
   * @generated from field: string region = 1;
   */
  region: string;

  /**
   * @generated from field: uint64 version_last_seen = 2;
   */
  versionLastSeen: bigint;
};

/**
 * Describes the message ctrl.v1.WatchCiliumNetworkPoliciesRequest.
 * Use `create(WatchCiliumNetworkPoliciesRequestSchema)` to create a new message.
 */
export const WatchCiliumNetworkPoliciesRequestSchema: GenMessage<WatchCiliumNetworkPoliciesRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 0);

/**
 * @generated from message ctrl.v1.ApplyCiliumNetworkPolicy
 */
export type ApplyCiliumNetworkPolicy = Message<"ctrl.v1.ApplyCiliumNetworkPolicy"> & {
  /**
   * @generated from field: string k8s_namespace = 1;
   */
  k8sNamespace: string;

  /**
   * @generated from field: string k8s_name = 2;
   */
  k8sName: string;

  /**
   * @generated from field: string cilium_network_policy_id = 3;
   */
  ciliumNetworkPolicyId: string;

  /**
   * @generated from field: bytes policy = 4;
   */
  policy: Uint8Array;
};

/**
 * Describes the message ctrl.v1.ApplyCiliumNetworkPolicy.
 * Use `create(ApplyCiliumNetworkPolicySchema)` to create a new message.
 */
export const ApplyCiliumNetworkPolicySchema: GenMessage<ApplyCiliumNetworkPolicy> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 1);

/**
 * @generated from message ctrl.v1.DeleteCiliumNetworkPolicy
 */
export type DeleteCiliumNetworkPolicy = Message<"ctrl.v1.DeleteCiliumNetworkPolicy"> & {
  /**
   * @generated from field: string k8s_namespace = 1;
   */
  k8sNamespace: string;

  /**
   * @generated from field: string k8s_name = 2;
   */
  k8sName: string;
};

/**
 * Describes the message ctrl.v1.DeleteCiliumNetworkPolicy.
 * Use `create(DeleteCiliumNetworkPolicySchema)` to create a new message.
 */
export const DeleteCiliumNetworkPolicySchema: GenMessage<DeleteCiliumNetworkPolicy> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 2);

/**
 * @generated from message ctrl.v1.CiliumNetworkPolicyState
 */
export type CiliumNetworkPolicyState = Message<"ctrl.v1.CiliumNetworkPolicyState"> & {
  /**
   * @generated from field: uint64 version = 3;
   */
  version: bigint;

  /**
   * @generated from oneof ctrl.v1.CiliumNetworkPolicyState.state
   */
  state: {
    /**
     * @generated from field: ctrl.v1.ApplyCiliumNetworkPolicy apply = 1;
     */
    value: ApplyCiliumNetworkPolicy;
    case: "apply";
  } | {
    /**
     * @generated from field: ctrl.v1.DeleteCiliumNetworkPolicy delete = 2;
     */
    value: DeleteCiliumNetworkPolicy;
    case: "delete";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ctrl.v1.CiliumNetworkPolicyState.
 * Use `create(CiliumNetworkPolicyStateSchema)` to create a new message.
 */
export const CiliumNetworkPolicyStateSchema: GenMessage<CiliumNetworkPolicyState> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 3);

/**
 * @generated from message ctrl.v1.GetDesiredCiliumNetworkPolicyStateRequest
 */
export type GetDesiredCiliumNetworkPolicyStateRequest = Message<"ctrl.v1.GetDesiredCiliumNetworkPolicyStateRequest"> & {
  /**
   * @generated from field: string cilium_network_policy_id = 1;
   */
  ciliumNetworkPolicyId: string;
};

/**
 * Describes the message ctrl.v1.GetDesiredCiliumNetworkPolicyStateRequest.
 * Use `create(GetDesiredCiliumNetworkPolicyStateRequestSchema)` to create a new message.
 */
export const GetDesiredCiliumNetworkPolicyStateRequestSchema: GenMessage<GetDesiredCiliumNetworkPolicyStateRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 4);

/**
 * @generated from message ctrl.v1.GetDesiredSentinelStateRequest
 */
export type GetDesiredSentinelStateRequest = Message<"ctrl.v1.GetDesiredSentinelStateRequest"> & {
  /**
   * @generated from field: string sentinel_id = 1;
   */
  sentinelId: string;
};

/**
 * Describes the message ctrl.v1.GetDesiredSentinelStateRequest.
 * Use `create(GetDesiredSentinelStateRequestSchema)` to create a new message.
 */
export const GetDesiredSentinelStateRequestSchema: GenMessage<GetDesiredSentinelStateRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 5);

/**
 * @generated from message ctrl.v1.GetDesiredDeploymentStateRequest
 */
export type GetDesiredDeploymentStateRequest = Message<"ctrl.v1.GetDesiredDeploymentStateRequest"> & {
  /**
   * @generated from field: string deployment_id = 1;
   */
  deploymentId: string;
};

/**
 * Describes the message ctrl.v1.GetDesiredDeploymentStateRequest.
 * Use `create(GetDesiredDeploymentStateRequestSchema)` to create a new message.
 */
export const GetDesiredDeploymentStateRequestSchema: GenMessage<GetDesiredDeploymentStateRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 6);

/**
 * ReportDeploymentStatusRequest reports the actual state of a deployment from the agent.
 * Used by runActualStateReportLoop to inform the control plane of K8s cluster state.
 *
 * @generated from message ctrl.v1.ReportDeploymentStatusRequest
 */
export type ReportDeploymentStatusRequest = Message<"ctrl.v1.ReportDeploymentStatusRequest"> & {
  /**
   * @generated from oneof ctrl.v1.ReportDeploymentStatusRequest.change
   */
  change: {
    /**
     * @generated from field: ctrl.v1.ReportDeploymentStatusRequest.Update update = 1;
     */
    value: ReportDeploymentStatusRequest_Update;
    case: "update";
  } | {
    /**
     * @generated from field: ctrl.v1.ReportDeploymentStatusRequest.Delete delete = 2;
     */
    value: ReportDeploymentStatusRequest_Delete;
    case: "delete";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ctrl.v1.ReportDeploymentStatusRequest.
 * Use `create(ReportDeploymentStatusRequestSchema)` to create a new message.
 */
export const ReportDeploymentStatusRequestSchema: GenMessage<ReportDeploymentStatusRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 7);

/**
 * @generated from message ctrl.v1.ReportDeploymentStatusRequest.Update
 */
export type ReportDeploymentStatusRequest_Update = Message<"ctrl.v1.ReportDeploymentStatusRequest.Update"> & {
  /**
   * @generated from field: string k8s_name = 1;
   */
  k8sName: string;

  /**
   * @generated from field: repeated ctrl.v1.ReportDeploymentStatusRequest.Update.Instance instances = 2;
   */
  instances: ReportDeploymentStatusRequest_Update_Instance[];
};

/**
 * Describes the message ctrl.v1.ReportDeploymentStatusRequest.Update.
 * Use `create(ReportDeploymentStatusRequest_UpdateSchema)` to create a new message.
 */
export const ReportDeploymentStatusRequest_UpdateSchema: GenMessage<ReportDeploymentStatusRequest_Update> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 7, 0);

/**
 * @generated from message ctrl.v1.ReportDeploymentStatusRequest.Update.Instance
 */
export type ReportDeploymentStatusRequest_Update_Instance = Message<"ctrl.v1.ReportDeploymentStatusRequest.Update.Instance"> & {
  /**
   * @generated from field: string k8s_name = 1;
   */
  k8sName: string;

  /**
   * @generated from field: string address = 2;
   */
  address: string;

  /**
   * @generated from field: int64 cpu_millicores = 3;
   */
  cpuMillicores: bigint;

  /**
   * @generated from field: int64 memory_mib = 4;
   */
  memoryMib: bigint;

  /**
   * @generated from field: ctrl.v1.ReportDeploymentStatusRequest.Update.Instance.Status status = 5;
   */
  status: ReportDeploymentStatusRequest_Update_Instance_Status;
};

/**
 * Describes the message ctrl.v1.ReportDeploymentStatusRequest.Update.Instance.
 * Use `create(ReportDeploymentStatusRequest_Update_InstanceSchema)` to create a new message.
 */
export const ReportDeploymentStatusRequest_Update_InstanceSchema: GenMessage<ReportDeploymentStatusRequest_Update_Instance> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 7, 0, 0);

/**
 * @generated from enum ctrl.v1.ReportDeploymentStatusRequest.Update.Instance.Status
 */
export enum ReportDeploymentStatusRequest_Update_Instance_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Deployment request accepted, container/pod creation in progress
   *
   * @generated from enum value: STATUS_PENDING = 1;
   */
  PENDING = 1,

  /**
   * Container/pod is running and healthy
   *
   * @generated from enum value: STATUS_RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * Container/pod failed to start
   *
   * @generated from enum value: STATUS_FAILED = 3;
   */
  FAILED = 3,
}

/**
 * Describes the enum ctrl.v1.ReportDeploymentStatusRequest.Update.Instance.Status.
 */
export const ReportDeploymentStatusRequest_Update_Instance_StatusSchema: GenEnum<ReportDeploymentStatusRequest_Update_Instance_Status> = /*@__PURE__*/
  enumDesc(file_ctrl_v1_cluster, 7, 0, 0, 0);

/**
 * @generated from message ctrl.v1.ReportDeploymentStatusRequest.Delete
 */
export type ReportDeploymentStatusRequest_Delete = Message<"ctrl.v1.ReportDeploymentStatusRequest.Delete"> & {
  /**
   * @generated from field: string k8s_name = 1;
   */
  k8sName: string;
};

/**
 * Describes the message ctrl.v1.ReportDeploymentStatusRequest.Delete.
 * Use `create(ReportDeploymentStatusRequest_DeleteSchema)` to create a new message.
 */
export const ReportDeploymentStatusRequest_DeleteSchema: GenMessage<ReportDeploymentStatusRequest_Delete> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 7, 1);

/**
 * @generated from message ctrl.v1.ReportDeploymentStatusResponse
 */
export type ReportDeploymentStatusResponse = Message<"ctrl.v1.ReportDeploymentStatusResponse"> & {
};

/**
 * Describes the message ctrl.v1.ReportDeploymentStatusResponse.
 * Use `create(ReportDeploymentStatusResponseSchema)` to create a new message.
 */
export const ReportDeploymentStatusResponseSchema: GenMessage<ReportDeploymentStatusResponse> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 8);

/**
 * ReportSentinelStatusRequest reports the actual state of a sentinel from the agent.
 * Used by runActualStateReportLoop to inform the control plane of K8s cluster state.
 *
 * @generated from message ctrl.v1.ReportSentinelStatusRequest
 */
export type ReportSentinelStatusRequest = Message<"ctrl.v1.ReportSentinelStatusRequest"> & {
  /**
   * @generated from field: string k8s_name = 1;
   */
  k8sName: string;

  /**
   * @generated from field: int32 available_replicas = 2;
   */
  availableReplicas: number;

  /**
   * @generated from field: ctrl.v1.Health health = 3;
   */
  health: Health;
};

/**
 * Describes the message ctrl.v1.ReportSentinelStatusRequest.
 * Use `create(ReportSentinelStatusRequestSchema)` to create a new message.
 */
export const ReportSentinelStatusRequestSchema: GenMessage<ReportSentinelStatusRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 9);

/**
 * @generated from message ctrl.v1.ReportSentinelStatusResponse
 */
export type ReportSentinelStatusResponse = Message<"ctrl.v1.ReportSentinelStatusResponse"> & {
};

/**
 * Describes the message ctrl.v1.ReportSentinelStatusResponse.
 * Use `create(ReportSentinelStatusResponseSchema)` to create a new message.
 */
export const ReportSentinelStatusResponseSchema: GenMessage<ReportSentinelStatusResponse> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 10);

/**
 * WatchDeploymentsRequest initiates a stream of deployment state changes.
 * The version_last_seen enables resumable streaming - the server will only send
 * events newer than this version. Independent of the sentinel stream version.
 *
 * @generated from message ctrl.v1.WatchDeploymentsRequest
 */
export type WatchDeploymentsRequest = Message<"ctrl.v1.WatchDeploymentsRequest"> & {
  /**
   * @generated from field: string region = 1;
   */
  region: string;

  /**
   * @generated from field: uint64 version_last_seen = 2;
   */
  versionLastSeen: bigint;
};

/**
 * Describes the message ctrl.v1.WatchDeploymentsRequest.
 * Use `create(WatchDeploymentsRequestSchema)` to create a new message.
 */
export const WatchDeploymentsRequestSchema: GenMessage<WatchDeploymentsRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 11);

/**
 * WatchSentinelsRequest initiates a stream of sentinel state changes.
 * The version_last_seen enables resumable streaming - the server will only send
 * events newer than this version. Independent of the deployment stream version.
 *
 * @generated from message ctrl.v1.WatchSentinelsRequest
 */
export type WatchSentinelsRequest = Message<"ctrl.v1.WatchSentinelsRequest"> & {
  /**
   * @generated from field: string region = 1;
   */
  region: string;

  /**
   * @generated from field: uint64 version_last_seen = 2;
   */
  versionLastSeen: bigint;
};

/**
 * Describes the message ctrl.v1.WatchSentinelsRequest.
 * Use `create(WatchSentinelsRequestSchema)` to create a new message.
 */
export const WatchSentinelsRequestSchema: GenMessage<WatchSentinelsRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 12);

/**
 * SentinelState represents a lifecycle event for an API sentinel configuration.
 *
 * Sentinels are frontline points for services, typically handling routing, load balancing,
 * and API management. The event follows a declarative model where the cluster agent ensures
 * the cluster state matches the desired configuration.
 *
 * @generated from message ctrl.v1.SentinelState
 */
export type SentinelState = Message<"ctrl.v1.SentinelState"> & {
  /**
   * version is the sentinel-specific resource version for this state update.
   * Clients should track the max version seen and use it when reconnecting to
   * the WatchSentinels stream to resume from the correct position.
   * When returned from GetDesiredSentinelState, this field is not set.
   *
   * @generated from field: uint64 version = 3;
   */
  version: bigint;

  /**
   * state contains the specific sentinel operation to perform.
   * Only one state type is set per message, determining the action the agent should take.
   *
   * @generated from oneof ctrl.v1.SentinelState.state
   */
  state: {
    /**
     * apply indicates the sentinel should exist with this configuration.
     * The agent will create the sentinel if it doesn't exist or update it if it does.
     * This follows the same semantics as "kubectl apply" - declare desired state
     * and let the agent determine the appropriate action.
     *
     * @generated from field: ctrl.v1.ApplySentinel apply = 1;
     */
    value: ApplySentinel;
    case: "apply";
  } | {
    /**
     * delete indicates the sentinel should be removed from the cluster.
     *
     * @generated from field: ctrl.v1.DeleteSentinel delete = 2;
     */
    value: DeleteSentinel;
    case: "delete";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ctrl.v1.SentinelState.
 * Use `create(SentinelStateSchema)` to create a new message.
 */
export const SentinelStateSchema: GenMessage<SentinelState> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 13);

/**
 * DeploymentState represents a lifecycle event for an application deployment.
 *
 * Deployments are the primary workload type, representing stateless applications
 * that can be scaled horizontally. The event follows a declarative model where
 * the cluster agent ensures the cluster state matches the desired configuration.
 *
 * @generated from message ctrl.v1.DeploymentState
 */
export type DeploymentState = Message<"ctrl.v1.DeploymentState"> & {
  /**
   * version is the deployment-specific resource version for this state update.
   * Clients should track the max version seen and use it when reconnecting to
   * the WatchDeployments stream to resume from the correct position.
   * When returned from GetDesiredDeploymentState, this field is not set.
   *
   * @generated from field: uint64 version = 3;
   */
  version: bigint;

  /**
   * state contains the specific deployment operation to perform.
   * Only one state type is set per message, determining the action the agent should take.
   *
   * @generated from oneof ctrl.v1.DeploymentState.state
   */
  state: {
    /**
     * apply indicates the deployment should exist with this configuration.
     * The agent will create the deployment if it doesn't exist or update it if it does.
     * This follows the same semantics as "kubectl apply" - declare desired state
     * and let the agent determine the appropriate action.
     *
     * @generated from field: ctrl.v1.ApplyDeployment apply = 1;
     */
    value: ApplyDeployment;
    case: "apply";
  } | {
    /**
     * delete indicates the deployment should be removed from the cluster.
     *
     * @generated from field: ctrl.v1.DeleteDeployment delete = 2;
     */
    value: DeleteDeployment;
    case: "delete";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ctrl.v1.DeploymentState.
 * Use `create(DeploymentStateSchema)` to create a new message.
 */
export const DeploymentStateSchema: GenMessage<DeploymentState> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 14);

/**
 * ApplySentinel contains the desired configuration for a sentinel.
 *
 * The cluster agent will ensure a sentinel exists with this exact configuration, creating it if
 * it doesn't exist or updating it if it does. All fields except namespace are required.
 * The control plane ensures that sentinel_id is unique within the namespace.
 *
 * @generated from message ctrl.v1.ApplySentinel
 */
export type ApplySentinel = Message<"ctrl.v1.ApplySentinel"> & {
  /**
   * @generated from field: string k8s_name = 1;
   */
  k8sName: string;

  /**
   * workspace_id identifies the workspace that owns this sentinel.
   *
   * @generated from field: string workspace_id = 2;
   */
  workspaceId: string;

  /**
   * project_id identifies the project within the workspace.
   *
   * @generated from field: string project_id = 3;
   */
  projectId: string;

  /**
   * environment_id in which the sentinel should exist.
   *
   * @generated from field: string environment_id = 4;
   */
  environmentId: string;

  /**
   * sentinel_id is the unique identifier for this sentinel globally
   *
   * @generated from field: string sentinel_id = 5;
   */
  sentinelId: string;

  /**
   * @generated from field: string image = 6;
   */
  image: string;

  /**
   * @generated from field: int32 replicas = 7;
   */
  replicas: number;

  /**
   * @generated from field: int64 cpu_millicores = 8;
   */
  cpuMillicores: bigint;

  /**
   * @generated from field: int64 memory_mib = 9;
   */
  memoryMib: bigint;
};

/**
 * Describes the message ctrl.v1.ApplySentinel.
 * Use `create(ApplySentinelSchema)` to create a new message.
 */
export const ApplySentinelSchema: GenMessage<ApplySentinel> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 15);

/**
 * DeleteSentinel identifies a sentinel to remove from the cluster.
 *
 * The sentinel and all its resources (pods, services, frontline) will be deleted.
 * In-flight requests may be disrupted unless proper connection draining is configured.
 *
 * @generated from message ctrl.v1.DeleteSentinel
 */
export type DeleteSentinel = Message<"ctrl.v1.DeleteSentinel"> & {
  /**
   * @generated from field: string k8s_name = 1;
   */
  k8sName: string;
};

/**
 * Describes the message ctrl.v1.DeleteSentinel.
 * Use `create(DeleteSentinelSchema)` to create a new message.
 */
export const DeleteSentinelSchema: GenMessage<DeleteSentinel> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 16);

/**
 * ApplyDeployment contains the desired configuration for a deployment.
 *
 * The cluster agent will ensure a deployment exists with this exact configuration, creating it if
 * it doesn't exist or updating it if it does. All fields except namespace are required.
 * The control plane ensures that deployment_id is unique within the namespace.
 *
 * @generated from message ctrl.v1.ApplyDeployment
 */
export type ApplyDeployment = Message<"ctrl.v1.ApplyDeployment"> & {
  /**
   * namespace is the Kubernetes namespace in which the deployment should exist.
   *
   * @generated from field: string k8s_namespace = 1;
   */
  k8sNamespace: string;

  /**
   * @generated from field: string k8s_name = 2;
   */
  k8sName: string;

  /**
   * workspace_id identifies the workspace that owns this deployment.
   * Used for multi-tenancy and access control.
   *
   * @generated from field: string workspace_id = 3;
   */
  workspaceId: string;

  /**
   * project_id identifies the project within the workspace.
   * Deployments are scoped to projects for organizational purposes.
   *
   * @generated from field: string project_id = 4;
   */
  projectId: string;

  /**
   * environment_id specifies the environment .
   * Used for environment-specific configuration and isolation.
   *
   * @generated from field: string environment_id = 5;
   */
  environmentId: string;

  /**
   * deployment_id is the unique identifier for this deployment within the namespace.
   *
   * @generated from field: string deployment_id = 6;
   */
  deploymentId: string;

  /**
   * image is the container image to deploy.
   * Must be a valid container registry URL accessible by the cluster.
   * Example: "gcr.io/myproject/app:v2.1.0"
   *
   * @generated from field: string image = 7;
   */
  image: string;

  /**
   * replicas is the desired number of pod instances.
   * Must be at least 1. Set higher for increased availability and load distribution.
   *
   * @generated from field: int32 replicas = 8;
   */
  replicas: number;

  /**
   * cpu_millicores is the CPU request/limit in millicores (1000 = 1 CPU core).
   * This ensures each pod has sufficient CPU resources.
   * Example: 250 = 0.25 CPU cores
   *
   * @generated from field: int64 cpu_millicores = 9;
   */
  cpuMillicores: bigint;

  /**
   * memory_mib is the memory request/limit in mebibytes.
   * This ensures each pod has sufficient memory.
   * Example: 256 = 256 MiB
   *
   * @generated from field: int64 memory_mib = 10;
   */
  memoryMib: bigint;

  /**
   * @generated from field: optional string build_id = 11;
   */
  buildId?: string;

  /**
   * @generated from field: bytes encrypted_environment_variables = 12;
   */
  encryptedEnvironmentVariables: Uint8Array;

  /**
   * command is the container command override (e.g., ["./app", "serve"]).
   * If empty, the container's default entrypoint/cmd from the Dockerfile is used.
   *
   * @generated from field: repeated string command = 13;
   */
  command: string[];

  /**
   * port is the container port the application listens on.
   *
   * @generated from field: int32 port = 14;
   */
  port: number;

  /**
   * restart_policy controls pod restart behavior: "always", "on-failure", or "never".
   *
   * @generated from field: string restart_policy = 15;
   */
  restartPolicy: string;

  /**
   * shutdown_signal is the signal sent to the container for graceful shutdown.
   * "SIGTERM", "SIGINT", "SIGQUIT", or "SIGKILL".
   *
   * @generated from field: string shutdown_signal = 16;
   */
  shutdownSignal: string;

  /**
   * healthcheck is a JSON-encoded Healthcheck struct for configuring liveness/readiness probes.
   * If empty, no probes are configured.
   *
   * @generated from field: optional bytes healthcheck = 17;
   */
  healthcheck?: Uint8Array;
};

/**
 * Describes the message ctrl.v1.ApplyDeployment.
 * Use `create(ApplyDeploymentSchema)` to create a new message.
 */
export const ApplyDeploymentSchema: GenMessage<ApplyDeployment> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 17);

/**
 * DeleteDeployment identifies a deployment to remove from the cluster.
 *
 * The deployment and all its pods will be terminated gracefully according to
 * the configured termination grace period. All associated resources (services,
 * configmaps specific to this deployment) will also be cleaned up.
 *
 * @generated from message ctrl.v1.DeleteDeployment
 */
export type DeleteDeployment = Message<"ctrl.v1.DeleteDeployment"> & {
  /**
   * @generated from field: string k8s_namespace = 1;
   */
  k8sNamespace: string;

  /**
   * @generated from field: string k8s_name = 2;
   */
  k8sName: string;
};

/**
 * Describes the message ctrl.v1.DeleteDeployment.
 * Use `create(DeleteDeploymentSchema)` to create a new message.
 */
export const DeleteDeploymentSchema: GenMessage<DeleteDeployment> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 18);

/**
 * Health represents the health state of a resource (sentinel, deployment instance, etc.)
 *
 * @generated from enum ctrl.v1.Health
 */
export enum Health {
  /**
   * @generated from enum value: HEALTH_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: HEALTH_HEALTHY = 1;
   */
  HEALTHY = 1,

  /**
   * @generated from enum value: HEALTH_UNHEALTHY = 2;
   */
  UNHEALTHY = 2,

  /**
   * @generated from enum value: HEALTH_PAUSED = 3;
   */
  PAUSED = 3,
}

/**
 * Describes the enum ctrl.v1.Health.
 */
export const HealthSchema: GenEnum<Health> = /*@__PURE__*/
  enumDesc(file_ctrl_v1_cluster, 0);

/**
 * ClusterService coordinates deployment and sentinel configurations across multiple clusters.
 *
 * Agents in each cluster establish watch streams to receive configuration events
 * from the control plane. The service provides separate streams for deployments and
 * sentinels, each with independent version cursors. This allows the two control loops
 * to operate independently with isolated failure domains.
 *
 * The watch connections are designed to be long-lived with automatic reconnection on failure.
 * When an agent reconnects, it should resume from its last seen version for that resource type.
 *
 * @generated from service ctrl.v1.ClusterService
 */
export const ClusterService: GenService<{
  /**
   * WatchDeployments streams deployment state changes from the control plane to agents.
   * Each deployment controller maintains its own version cursor for resumable streaming.
   * The agent applies received state to Kubernetes to converge actual state toward desired state.
   *
   * @generated from rpc ctrl.v1.ClusterService.WatchDeployments
   */
  watchDeployments: {
    methodKind: "server_streaming";
    input: typeof WatchDeploymentsRequestSchema;
    output: typeof DeploymentStateSchema;
  },
  /**
   * WatchSentinels streams sentinel state changes from the control plane to agents.
   * Each sentinel controller maintains its own version cursor for resumable streaming.
   * The agent applies received state to Kubernetes to converge actual state toward desired state.
   *
   * @generated from rpc ctrl.v1.ClusterService.WatchSentinels
   */
  watchSentinels: {
    methodKind: "server_streaming";
    input: typeof WatchSentinelsRequestSchema;
    output: typeof SentinelStateSchema;
  },
  /**
   * GetDesiredSentinelState returns the current desired state for a single sentinel.
   * Used by the resync loop to verify consistency for existing resources.
   *
   * @generated from rpc ctrl.v1.ClusterService.GetDesiredSentinelState
   */
  getDesiredSentinelState: {
    methodKind: "unary";
    input: typeof GetDesiredSentinelStateRequestSchema;
    output: typeof SentinelStateSchema;
  },
  /**
   * ReportSentinelStatus reports actual sentinel state from the agent to the control plane.
   * Called when K8s watch events indicate sentinel Deployment changes.
   *
   * @generated from rpc ctrl.v1.ClusterService.ReportSentinelStatus
   */
  reportSentinelStatus: {
    methodKind: "unary";
    input: typeof ReportSentinelStatusRequestSchema;
    output: typeof ReportSentinelStatusResponseSchema;
  },
  /**
   * GetDesiredDeploymentState returns the current desired state for a single deployment.
   * Used by the resync loop to verify consistency for existing resources.
   *
   * @generated from rpc ctrl.v1.ClusterService.GetDesiredDeploymentState
   */
  getDesiredDeploymentState: {
    methodKind: "unary";
    input: typeof GetDesiredDeploymentStateRequestSchema;
    output: typeof DeploymentStateSchema;
  },
  /**
   * ReportDeploymentStatus reports actual deployment state from the agent to the control plane.
   * Called when K8s watch events indicate ReplicaSet changes.
   *
   * @generated from rpc ctrl.v1.ClusterService.ReportDeploymentStatus
   */
  reportDeploymentStatus: {
    methodKind: "unary";
    input: typeof ReportDeploymentStatusRequestSchema;
    output: typeof ReportDeploymentStatusResponseSchema;
  },
  /**
   * WatchCiliumNetworkPolicies streams Cilium network policy state changes from the control plane.
   * Each cilium controller maintains its own version cursor for resumable streaming.
   *
   * @generated from rpc ctrl.v1.ClusterService.WatchCiliumNetworkPolicies
   */
  watchCiliumNetworkPolicies: {
    methodKind: "server_streaming";
    input: typeof WatchCiliumNetworkPoliciesRequestSchema;
    output: typeof CiliumNetworkPolicyStateSchema;
  },
  /**
   * GetDesiredCiliumNetworkPolicyState returns the current desired state for a single Cilium policy.
   * Used by the resync loop to verify consistency for existing resources.
   *
   * @generated from rpc ctrl.v1.ClusterService.GetDesiredCiliumNetworkPolicyState
   */
  getDesiredCiliumNetworkPolicyState: {
    methodKind: "unary";
    input: typeof GetDesiredCiliumNetworkPolicyStateRequestSchema;
    output: typeof CiliumNetworkPolicyStateSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_ctrl_v1_cluster, 0);

