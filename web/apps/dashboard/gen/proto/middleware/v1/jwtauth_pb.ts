// @generated by protoc-gen-es v2.8.0 with parameter "target=ts"
// @generated from file middleware/v1/jwtauth.proto (package sentinel.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file middleware/v1/jwtauth.proto.
 */
export const file_middleware_v1_jwtauth: GenFile = /*@__PURE__*/
  fileDesc("ChttaWRkbGV3YXJlL3YxL2p3dGF1dGgucHJvdG8SC3NlbnRpbmVsLnYxIooCCgdKV1RBdXRoEhIKCGp3a3NfdXJpGAEgASgJSAASFQoLb2lkY19pc3N1ZXIYAiABKAlIABIYCg5wdWJsaWNfa2V5X3BlbRgLIAEoDEgAEg4KBmlzc3VlchgDIAEoCRIRCglhdWRpZW5jZXMYBCADKAkSEgoKYWxnb3JpdGhtcxgFIAMoCRIVCg1zdWJqZWN0X2NsYWltGAYgASgJEhYKDmZvcndhcmRfY2xhaW1zGAcgAygJEhcKD2FsbG93X2Fub255bW91cxgIIAEoCBIVCg1jbG9ja19za2V3X21zGAkgASgDEhUKDWp3a3NfY2FjaGVfbXMYCiABKANCDQoLandrc19zb3VyY2VCpwEKD2NvbS5zZW50aW5lbC52MUIMSnd0YXV0aFByb3RvUAFaOWdpdGh1Yi5jb20vdW5rZXllZC91bmtleS9nZW4vcHJvdG8vc2VudGluZWwvdjE7c2VudGluZWx2MaICA1NYWKoCC1NlbnRpbmVsLlYxygILU2VudGluZWxcVjHiAhdTZW50aW5lbFxWMVxHUEJNZXRhZGF0YeoCDFNlbnRpbmVsOjpWMWIGcHJvdG8z");

/**
 * JWTAuth validates Bearer JSON Web Tokens using JWKS (JSON Web Key Sets)
 * and produces a [Principal] on success.
 *
 * Without it, every upstream service must implement
 * its own token validation, duplicating JWKS fetching, signature verification,
 * claim validation, and key rotation logic. JWTAuth centralizes all of this
 * at the proxy layer.
 *
 * On successful validation, JWTAuth produces a [Principal] with type
 * PRINCIPAL_TYPE_JWT. The subject is extracted from a configurable token
 * claim (default "sub"), and selected claims are forwarded into
 * Principal.claims for use by downstream policies. This means a RateLimit
 * policy can throttle per-user or per-organization (via PrincipalClaimKey),
 * all without the upstream parsing the JWT itself.
 *
 * For common identity providers (Auth0, Clerk, Cognito, Okta), use the
 * oidc_issuer field instead of jwks_uri — sentinel auto-discovers the
 * JWKS endpoint via OpenID Connect discovery.
 *
 * @generated from message sentinel.v1.JWTAuth
 */
export type JWTAuth = Message<"sentinel.v1.JWTAuth"> & {
  /**
   * The source of signing keys for token verification. Exactly one must
   * be set.
   *
   * @generated from oneof sentinel.v1.JWTAuth.jwks_source
   */
  jwksSource: {
    /**
     * URI pointing to the JWKS endpoint that serves the signing keys, e.g.
     * "https://example.com/.well-known/jwks.json". Sentinel fetches and
     * caches these keys, using them to verify token signatures.
     *
     * Use this when you know the JWKS endpoint directly.
     *
     * @generated from field: string jwks_uri = 1;
     */
    value: string;
    case: "jwksUri";
  } | {
    /**
     * OIDC issuer URL. Sentinel appends /.well-known/openid-configuration to
     * discover the JWKS URI automatically. This is the preferred approach for
     * OIDC-compliant providers because it also validates that the issuer claim
     * matches the discovery document.
     *
     * @generated from field: string oidc_issuer = 2;
     */
    value: string;
    case: "oidcIssuer";
  } | {
    /**
     * PEM-encoded public key for direct signature verification without a
     * JWKS endpoint. Useful for self-signed JWTs or simple setups where
     * key rotation is handled out-of-band and running a JWKS server is
     * unnecessary overhead. Also eliminates the runtime network dependency
     * on a JWKS endpoint.
     *
     * Must be a PEM-encoded RSA or EC public key (PKIX/X.509 format).
     *
     * @generated from field: bytes public_key_pem = 11;
     */
    value: Uint8Array;
    case: "publicKeyPem";
  } | { case: undefined; value?: undefined };

  /**
   * Required issuer claim (iss). When set, tokens whose iss claim does not
   * match this value are rejected. This prevents tokens issued by one
   * provider from being accepted by a policy configured for another,
   * which is a critical security boundary in multi-tenant systems.
   *
   * @generated from field: string issuer = 3;
   */
  issuer: string;

  /**
   * Required audience claims (aud). The token must contain at least one of
   * these values in its aud claim. Audience validation prevents tokens
   * intended for one service from being used at another, which is especially
   * important when multiple services share the same identity provider.
   *
   * @generated from field: repeated string audiences = 4;
   */
  audiences: string[];

  /**
   * Allowed signing algorithms, e.g. ["RS256", "ES256"]. Defaults to
   * ["RS256"] if empty. Explicitly listing allowed algorithms is a security
   * best practice that prevents algorithm confusion attacks, where an
   * attacker crafts a token signed with an unexpected algorithm (like
   * "none" or HS256 with a public key as the HMAC secret).
   *
   * @generated from field: repeated string algorithms = 5;
   */
  algorithms: string[];

  /**
   * Which token claim to use as the [Principal] subject. Defaults to "sub"
   * if empty. Override this when your identity provider uses a non-standard
   * claim for the primary identity (e.g., "uid" for some Okta
   * configurations, or "email" when you want email-based identity).
   *
   * @generated from field: string subject_claim = 6;
   */
  subjectClaim: string;

  /**
   * Additional token claims to extract into [Principal].claims. These become
   * available to downstream policies — for example, forwarding "org_id"
   * lets a RateLimit policy with a PrincipalClaimKey apply per-organization
   * limits.
   *
   * @generated from field: repeated string forward_claims = 7;
   */
  forwardClaims: string[];

  /**
   * When true, requests without a Bearer token are allowed through without
   * authentication. No [Principal] is produced for anonymous requests. This
   * enables endpoints that serve both public and authenticated content,
   * where the upstream adjusts behavior based on whether identity headers
   * are present.
   *
   * @generated from field: bool allow_anonymous = 8;
   */
  allowAnonymous: boolean;

  /**
   * Maximum acceptable clock skew in milliseconds for exp (expiration) and
   * nbf (not before) claim validation. Defaults to 0, meaning no skew
   * tolerance. In distributed systems where clock synchronization is
   * imperfect, a small skew tolerance (e.g., 5000ms) prevents valid tokens
   * from being rejected due to minor clock differences between the token
   * issuer and sentinel.
   *
   * @generated from field: int64 clock_skew_ms = 9;
   */
  clockSkewMs: bigint;

  /**
   * How long to cache JWKS responses in milliseconds. Defaults to 3600000
   * (1 hour). Sentinel refetches the JWKS when a token references a key ID
   * not found in the cache, which handles key rotation gracefully. A longer
   * cache duration reduces load on the JWKS endpoint but increases the time
   * before revoked keys are detected.
   *
   * @generated from field: int64 jwks_cache_ms = 10;
   */
  jwksCacheMs: bigint;
};

/**
 * Describes the message sentinel.v1.JWTAuth.
 * Use `create(JWTAuthSchema)` to create a new message.
 */
export const JWTAuthSchema: GenMessage<JWTAuth> = /*@__PURE__*/
  messageDesc(file_middleware_v1_jwtauth, 0);

