// @generated by protoc-gen-es v2.8.0 with parameter "target=ts"
// @generated from file middleware/v1/middleware.proto (package sentinel.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { BasicAuth } from "./basicauth_pb";
import { file_middleware_v1_basicauth } from "./basicauth_pb";
import type { IPRules } from "./iprules_pb";
import { file_middleware_v1_iprules } from "./iprules_pb";
import type { JWTAuth } from "./jwtauth_pb";
import { file_middleware_v1_jwtauth } from "./jwtauth_pb";
import type { KeyAuth } from "./keyauth_pb";
import { file_middleware_v1_keyauth } from "./keyauth_pb";
import type { MatchExpr } from "./match_pb";
import { file_middleware_v1_match } from "./match_pb";
import type { OpenApiRequestValidation } from "./openapi_pb";
import { file_middleware_v1_openapi } from "./openapi_pb";
import type { RateLimit } from "./ratelimit_pb";
import { file_middleware_v1_ratelimit } from "./ratelimit_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file middleware/v1/middleware.proto.
 */
export const file_middleware_v1_middleware: GenFile = /*@__PURE__*/
  fileDesc("Ch5taWRkbGV3YXJlL3YxL21pZGRsZXdhcmUucHJvdG8SC3NlbnRpbmVsLnYxIlAKCk1pZGRsZXdhcmUSJQoIcG9saWNpZXMYASADKAsyEy5zZW50aW5lbC52MS5Qb2xpY3kSGwoTdHJ1c3RlZF9wcm94eV9jaWRycxgCIAMoCSL0AgoGUG9saWN5EgoKAmlkGAEgASgJEgwKBG5hbWUYAiABKAkSDwoHZW5hYmxlZBgDIAEoCBIlCgVtYXRjaBgEIAMoCzIWLnNlbnRpbmVsLnYxLk1hdGNoRXhwchInCgdrZXlhdXRoGAUgASgLMhQuc2VudGluZWwudjEuS2V5QXV0aEgAEicKB2p3dGF1dGgYBiABKAsyFC5zZW50aW5lbC52MS5KV1RBdXRoSAASKwoJYmFzaWNhdXRoGAcgASgLMhYuc2VudGluZWwudjEuQmFzaWNBdXRoSAASKwoJcmF0ZWxpbWl0GAggASgLMhYuc2VudGluZWwudjEuUmF0ZUxpbWl0SAASKAoIaXBfcnVsZXMYCSABKAsyFC5zZW50aW5lbC52MS5JUFJ1bGVzSAASOAoHb3BlbmFwaRgKIAEoCzIlLnNlbnRpbmVsLnYxLk9wZW5BcGlSZXF1ZXN0VmFsaWRhdGlvbkgAQggKBmNvbmZpZ0KqAQoPY29tLnNlbnRpbmVsLnYxQg9NaWRkbGV3YXJlUHJvdG9QAVo5Z2l0aHViLmNvbS91bmtleWVkL3Vua2V5L2dlbi9wcm90by9zZW50aW5lbC92MTtzZW50aW5lbHYxogIDU1hYqgILU2VudGluZWwuVjHKAgtTZW50aW5lbFxWMeICF1NlbnRpbmVsXFYxXEdQQk1ldGFkYXRh6gIMU2VudGluZWw6OlYxYgZwcm90bzM", [file_middleware_v1_basicauth, file_middleware_v1_iprules, file_middleware_v1_jwtauth, file_middleware_v1_keyauth, file_middleware_v1_match, file_middleware_v1_openapi, file_middleware_v1_ratelimit]);

/**
 * Middleware is the per-deployment policy configuration for sentinel.
 *
 * Sentinel is Unkey's reverse proxy. Each deployment gets a Middleware
 * configuration that defines which policies apply to incoming requests and in
 * what order. When a request arrives, sentinel evaluates every policy's
 * match conditions against it, collects the matching policies, and executes
 * them sequentially in list order. This gives operators full control over
 * request processing without relying on implicit ordering conventions.
 *
 * A deployment with no policies is a plain pass-through proxy. Adding policies
 * incrementally layers on authentication, authorization, traffic shaping,
 * and validation — all without touching application code.
 *
 * @generated from message sentinel.v1.Middleware
 */
export type Middleware = Message<"sentinel.v1.Middleware"> & {
  /**
   * The ordered list of policies for this deployment. Sentinel executes
   * matching policies in exactly this order, so authn policies should appear
   * before policies that depend on a [Principal].
   *
   * @generated from field: repeated sentinel.v1.Policy policies = 1;
   */
  policies: Policy[];

  /**
   * CIDR ranges of trusted proxies sitting in front of sentinel, used to
   * derive the real client IP from the X-Forwarded-For header chain.
   * Sentinel walks X-Forwarded-For right-to-left, skipping entries that
   * fall within a trusted CIDR, and uses the first untrusted entry as the
   * client IP. When this list is empty, sentinel uses the direct peer IP
   * and ignores X-Forwarded-For entirely — this is the safe default that
   * prevents IP spoofing via forged headers.
   *
   * This setting affects all policies that depend on client IP: [IPRules]
   * for allow/deny decisions and [RateLimit] with a [RemoteIpKey] source.
   *
   * Examples: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16"]
   *
   * @generated from field: repeated string trusted_proxy_cidrs = 2;
   */
  trustedProxyCidrs: string[];
};

/**
 * Describes the message sentinel.v1.Middleware.
 * Use `create(MiddlewareSchema)` to create a new message.
 */
export const MiddlewareSchema: GenMessage<Middleware> = /*@__PURE__*/
  messageDesc(file_middleware_v1_middleware, 0);

/**
 * Policy is a single middleware layer in a deployment's configuration. Each policy
 * combines a match expression (which requests does it apply to?) with a
 * configuration (what does it do?). This separation is what makes the system
 * composable: the same rate limiter config can be scoped to POST /api/*
 * without the rate limiter needing to know anything about path matching.
 *
 * Policies carry a stable id for correlation across logs, metrics, and
 * debugging. The disabled flag allows operators to disable a policy without
 * removing it from config, which is critical for incident response — you can
 * turn off a misbehaving policy and re-enable it once the issue is resolved,
 * without losing the configuration or triggering a full redeploy.
 *
 * @generated from message sentinel.v1.Policy
 */
export type Policy = Message<"sentinel.v1.Policy"> & {
  /**
   * Stable identifier for this policy, used in log entries, metrics labels,
   * and error messages. Should be unique within a deployment's Middleware
   * config. Typically a UUID or a slug like "api-ratelimit".
   *
   * @generated from field: string id = 1;
   */
  id: string;

  /**
   * Human-friendly label displayed in the dashboard and audit logs.
   * Does not affect policy behavior.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * When false, sentinel skips this policy entirely during evaluation.
   * This allows operators to toggle policies on and off without modifying
   * or removing the underlying configuration, which is useful during
   * incidents, gradual rollouts, and debugging.
   *
   * @generated from field: bool enabled = 3;
   */
  enabled: boolean;

  /**
   * Match conditions that determine which requests this policy applies to.
   * All entries must match for the policy to run (implicit AND). An empty
   * list matches all requests — this is the common case for global policies
   * like IP allowlists or rate limiting.
   *
   * For OR semantics, create separate policies with the same config and
   * different match lists.
   *
   * @generated from field: repeated sentinel.v1.MatchExpr match = 4;
   */
  match: MatchExpr[];

  /**
   * The policy configuration. Exactly one must be set.
   *
   * @generated from oneof sentinel.v1.Policy.config
   */
  config: {
    /**
     * @generated from field: sentinel.v1.KeyAuth keyauth = 5;
     */
    value: KeyAuth;
    case: "keyauth";
  } | {
    /**
     * @generated from field: sentinel.v1.JWTAuth jwtauth = 6;
     */
    value: JWTAuth;
    case: "jwtauth";
  } | {
    /**
     * @generated from field: sentinel.v1.BasicAuth basicauth = 7;
     */
    value: BasicAuth;
    case: "basicauth";
  } | {
    /**
     * @generated from field: sentinel.v1.RateLimit ratelimit = 8;
     */
    value: RateLimit;
    case: "ratelimit";
  } | {
    /**
     * @generated from field: sentinel.v1.IPRules ip_rules = 9;
     */
    value: IPRules;
    case: "ipRules";
  } | {
    /**
     * @generated from field: sentinel.v1.OpenApiRequestValidation openapi = 10;
     */
    value: OpenApiRequestValidation;
    case: "openapi";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message sentinel.v1.Policy.
 * Use `create(PolicySchema)` to create a new message.
 */
export const PolicySchema: GenMessage<Policy> = /*@__PURE__*/
  messageDesc(file_middleware_v1_middleware, 1);

