// @generated by protoc-gen-es v2.8.0 with parameter "target=ts"
// @generated from file middleware/v1/ratelimit.proto (package sentinel.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file middleware/v1/ratelimit.proto.
 */
export const file_middleware_v1_ratelimit: GenFile = /*@__PURE__*/
  fileDesc("Ch1taWRkbGV3YXJlL3YxL3JhdGVsaW1pdC5wcm90bxILc2VudGluZWwudjEiVQoJUmF0ZUxpbWl0Eg0KBWxpbWl0GAEgASgDEhEKCXdpbmRvd19tcxgCIAEoAxImCgNrZXkYAyABKAsyGS5zZW50aW5lbC52MS5SYXRlTGltaXRLZXkimQIKDFJhdGVMaW1pdEtleRItCglyZW1vdGVfaXAYASABKAsyGC5zZW50aW5lbC52MS5SZW1vdGVJcEtleUgAEigKBmhlYWRlchgCIAEoCzIWLnNlbnRpbmVsLnYxLkhlYWRlcktleUgAEkUKFWF1dGhlbnRpY2F0ZWRfc3ViamVjdBgDIAEoCzIkLnNlbnRpbmVsLnYxLkF1dGhlbnRpY2F0ZWRTdWJqZWN0S2V5SAASJAoEcGF0aBgEIAEoCzIULnNlbnRpbmVsLnYxLlBhdGhLZXlIABI5Cg9wcmluY2lwYWxfY2xhaW0YBSABKAsyHi5zZW50aW5lbC52MS5QcmluY2lwYWxDbGFpbUtleUgAQggKBnNvdXJjZSINCgtSZW1vdGVJcEtleSIZCglIZWFkZXJLZXkSDAoEbmFtZRgBIAEoCSIZChdBdXRoZW50aWNhdGVkU3ViamVjdEtleSIJCgdQYXRoS2V5IicKEVByaW5jaXBhbENsYWltS2V5EhIKCmNsYWltX25hbWUYASABKAlCqQEKD2NvbS5zZW50aW5lbC52MUIOUmF0ZWxpbWl0UHJvdG9QAVo5Z2l0aHViLmNvbS91bmtleWVkL3Vua2V5L2dlbi9wcm90by9zZW50aW5lbC92MTtzZW50aW5lbHYxogIDU1hYqgILU2VudGluZWwuVjHKAgtTZW50aW5lbFxWMeICF1NlbnRpbmVsXFYxXEdQQk1ldGFkYXRh6gIMU2VudGluZWw6OlYxYgZwcm90bzM");

/**
 * RateLimit enforces request rate limits at the gateway, protecting upstream
 * services from being overwhelmed by traffic spikes, abusive clients, or
 * misconfigured integrations.
 *
 * Rate limiting at the proxy layer rather than in application code ensures
 * consistent enforcement across all endpoints. It also means the upstream
 * never sees the excess traffic, which matters for cost-sensitive services
 * and APIs with expensive backend operations.
 *
 * Sentinel delegates rate limit state to Unkey's distributed rate limiting
 * service, which provides consistent counts across multiple sentinel
 * instances. This is critical for horizontally scaled deployments where
 * per-instance counters would allow N times the intended rate.
 *
 * @generated from message sentinel.v1.RateLimit
 */
export type RateLimit = Message<"sentinel.v1.RateLimit"> & {
  /**
   * Maximum number of requests allowed within the window. When the count
   * within the current window exceeds this value, subsequent requests are
   * rejected with 429 Too Many Requests.
   *
   * @generated from field: int64 limit = 1;
   */
  limit: bigint;

  /**
   * The time window in milliseconds over which the limit is enforced.
   * For example, limit=100 with window_ms=60000 means "100 requests per
   * minute".
   *
   * @generated from field: int64 window_ms = 2;
   */
  windowMs: bigint;

  /**
   * How to derive the rate limit key â€” the identity of "who" is being
   * limited. This determines whether limits are per-IP, per-header-value,
   * per-authenticated-subject, or per-claim. Choosing the right key source
   * is critical: IP-based limiting can be defeated by proxies and NAT,
   * header-based limiting relies on client-supplied values, and subject-based
   * limiting requires an upstream authn policy to have produced a [Principal].
   *
   * @generated from field: sentinel.v1.RateLimitKey key = 3;
   */
  key?: RateLimitKey;
};

/**
 * Describes the message sentinel.v1.RateLimit.
 * Use `create(RateLimitSchema)` to create a new message.
 */
export const RateLimitSchema: GenMessage<RateLimit> = /*@__PURE__*/
  messageDesc(file_middleware_v1_ratelimit, 0);

/**
 * RateLimitKey determines how sentinel identifies the entity being rate
 * limited. The choice of key source fundamentally changes the limiting
 * behavior, so it should match the threat model and use case.
 *
 * @generated from message sentinel.v1.RateLimitKey
 */
export type RateLimitKey = Message<"sentinel.v1.RateLimitKey"> & {
  /**
   * @generated from oneof sentinel.v1.RateLimitKey.source
   */
  source: {
    /**
     * Limit by the client's IP address. Effective for anonymous traffic and
     * DDoS protection, but can over-limit legitimate users behind shared
     * NATs or corporate proxies where many clients share a single IP.
     * The client IP is derived using the trusted proxy configuration in
     * [Middleware.trusted_proxy_cidrs].
     *
     * @generated from field: sentinel.v1.RemoteIpKey remote_ip = 1;
     */
    value: RemoteIpKey;
    case: "remoteIp";
  } | {
    /**
     * Limit by the value of a specific request header. Useful for
     * pre-authenticated traffic where a trusted upstream has already
     * identified the caller via a header like X-Tenant-Id. Since clients
     * can set arbitrary headers, this should only be used when sentinel is
     * behind a trusted proxy that sets the header.
     *
     * @generated from field: sentinel.v1.HeaderKey header = 2;
     */
    value: HeaderKey;
    case: "header";
  } | {
    /**
     * Limit by the [Principal] subject produced by an upstream authn policy.
     * This is the most accurate key source for authenticated APIs because
     * it limits each authenticated identity independently, regardless of
     * how many IPs or devices they use. Requires a [KeyAuth], [JWTAuth],
     * or [BasicAuth] policy earlier in the policy list.
     *
     * @generated from field: sentinel.v1.AuthenticatedSubjectKey authenticated_subject = 3;
     */
    value: AuthenticatedSubjectKey;
    case: "authenticatedSubject";
  } | {
    /**
     * Limit by the request URL path. Creates a separate rate limit bucket
     * per path, useful for protecting specific expensive endpoints without
     * needing a separate policy per route.
     *
     * @generated from field: sentinel.v1.PathKey path = 4;
     */
    value: PathKey;
    case: "path";
  } | {
    /**
     * Limit by a specific claim from the [Principal]. This enables
     * per-organization or per-tenant rate limiting when the identity claim
     * is more granular than what you want to throttle. For example, using
     * claim_name "org_id" creates a shared rate limit bucket for all users
     * within the same organization, regardless of which individual subject
     * authenticated. Requires a [Principal] with the named claim present
     * in its claims map.
     *
     * @generated from field: sentinel.v1.PrincipalClaimKey principal_claim = 5;
     */
    value: PrincipalClaimKey;
    case: "principalClaim";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message sentinel.v1.RateLimitKey.
 * Use `create(RateLimitKeySchema)` to create a new message.
 */
export const RateLimitKeySchema: GenMessage<RateLimitKey> = /*@__PURE__*/
  messageDesc(file_middleware_v1_ratelimit, 1);

/**
 * RemoteIpKey derives the rate limit key from the client's IP address.
 *
 * @generated from message sentinel.v1.RemoteIpKey
 */
export type RemoteIpKey = Message<"sentinel.v1.RemoteIpKey"> & {
};

/**
 * Describes the message sentinel.v1.RemoteIpKey.
 * Use `create(RemoteIpKeySchema)` to create a new message.
 */
export const RemoteIpKeySchema: GenMessage<RemoteIpKey> = /*@__PURE__*/
  messageDesc(file_middleware_v1_ratelimit, 2);

/**
 * HeaderKey derives the rate limit key from a request header value.
 *
 * @generated from message sentinel.v1.HeaderKey
 */
export type HeaderKey = Message<"sentinel.v1.HeaderKey"> & {
  /**
   * The header name to read, e.g. "X-Tenant-Id". If the header is absent,
   * the request is rate limited under a shared "unknown" bucket.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message sentinel.v1.HeaderKey.
 * Use `create(HeaderKeySchema)` to create a new message.
 */
export const HeaderKeySchema: GenMessage<HeaderKey> = /*@__PURE__*/
  messageDesc(file_middleware_v1_ratelimit, 3);

/**
 * AuthenticatedSubjectKey derives the rate limit key from the [Principal]
 * subject. If no Principal exists (no authn policy matched or all authn
 * policies allowed anonymous access), the request is rate limited under a
 * shared anonymous bucket.
 *
 * @generated from message sentinel.v1.AuthenticatedSubjectKey
 */
export type AuthenticatedSubjectKey = Message<"sentinel.v1.AuthenticatedSubjectKey"> & {
};

/**
 * Describes the message sentinel.v1.AuthenticatedSubjectKey.
 * Use `create(AuthenticatedSubjectKeySchema)` to create a new message.
 */
export const AuthenticatedSubjectKeySchema: GenMessage<AuthenticatedSubjectKey> = /*@__PURE__*/
  messageDesc(file_middleware_v1_ratelimit, 4);

/**
 * PathKey derives the rate limit key from the request URL path.
 *
 * @generated from message sentinel.v1.PathKey
 */
export type PathKey = Message<"sentinel.v1.PathKey"> & {
};

/**
 * Describes the message sentinel.v1.PathKey.
 * Use `create(PathKeySchema)` to create a new message.
 */
export const PathKeySchema: GenMessage<PathKey> = /*@__PURE__*/
  messageDesc(file_middleware_v1_ratelimit, 5);

/**
 * PrincipalClaimKey derives the rate limit key from a named claim in the
 * [Principal]'s claims map. If the claim is absent or the Principal does
 * not exist, the request is rate limited under a shared "unknown" bucket.
 *
 * @generated from message sentinel.v1.PrincipalClaimKey
 */
export type PrincipalClaimKey = Message<"sentinel.v1.PrincipalClaimKey"> & {
  /**
   * The claim name to read from [Principal].claims, e.g. "org_id" or
   * "plan". The claim value becomes the rate limit bucket key.
   *
   * @generated from field: string claim_name = 1;
   */
  claimName: string;
};

/**
 * Describes the message sentinel.v1.PrincipalClaimKey.
 * Use `create(PrincipalClaimKeySchema)` to create a new message.
 */
export const PrincipalClaimKeySchema: GenMessage<PrincipalClaimKey> = /*@__PURE__*/
  messageDesc(file_middleware_v1_ratelimit, 6);

