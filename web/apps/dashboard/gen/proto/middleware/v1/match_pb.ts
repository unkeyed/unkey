// @generated by protoc-gen-es v2.8.0 with parameter "target=ts"
// @generated from file middleware/v1/match.proto (package sentinel.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file middleware/v1/match.proto.
 */
export const file_middleware_v1_match: GenFile = /*@__PURE__*/
  fileDesc("ChltaWRkbGV3YXJlL3YxL21hdGNoLnByb3RvEgtzZW50aW5lbC52MSLIAQoJTWF0Y2hFeHByEiYKBHBhdGgYASABKAsyFi5zZW50aW5lbC52MS5QYXRoTWF0Y2hIABIqCgZtZXRob2QYAiABKAsyGC5zZW50aW5lbC52MS5NZXRob2RNYXRjaEgAEioKBmhlYWRlchgDIAEoCzIYLnNlbnRpbmVsLnYxLkhlYWRlck1hdGNoSAASMwoLcXVlcnlfcGFyYW0YBCABKAsyHC5zZW50aW5lbC52MS5RdWVyeVBhcmFtTWF0Y2hIAEIGCgRleHByIl8KC1N0cmluZ01hdGNoEhMKC2lnbm9yZV9jYXNlGAEgASgIEg8KBWV4YWN0GAIgASgJSAASEAoGcHJlZml4GAMgASgJSAASDwoFcmVnZXgYBCABKAlIAEIHCgVtYXRjaCIzCglQYXRoTWF0Y2gSJgoEcGF0aBgBIAEoCzIYLnNlbnRpbmVsLnYxLlN0cmluZ01hdGNoIh4KC01ldGhvZE1hdGNoEg8KB21ldGhvZHMYASADKAkiYgoLSGVhZGVyTWF0Y2gSDAoEbmFtZRgBIAEoCRIRCgdwcmVzZW50GAIgASgISAASKQoFdmFsdWUYAyABKAsyGC5zZW50aW5lbC52MS5TdHJpbmdNYXRjaEgAQgcKBW1hdGNoImYKD1F1ZXJ5UGFyYW1NYXRjaBIMCgRuYW1lGAEgASgJEhEKB3ByZXNlbnQYAiABKAhIABIpCgV2YWx1ZRgDIAEoCzIYLnNlbnRpbmVsLnYxLlN0cmluZ01hdGNoSABCBwoFbWF0Y2hCpQEKD2NvbS5zZW50aW5lbC52MUIKTWF0Y2hQcm90b1ABWjlnaXRodWIuY29tL3Vua2V5ZWQvdW5rZXkvZ2VuL3Byb3RvL3NlbnRpbmVsL3YxO3NlbnRpbmVsdjGiAgNTWFiqAgtTZW50aW5lbC5WMcoCC1NlbnRpbmVsXFYx4gIXU2VudGluZWxcVjFcR1BCTWV0YWRhdGHqAgxTZW50aW5lbDo6VjFiBnByb3RvMw");

/**
 * MatchExpr tests a single property of an incoming HTTP request.
 *
 * A Policy carries a repeated list of MatchExpr. All entries must match for
 * the policy to run (implicit AND). An empty list matches all requests.
 *
 * If you need OR semantics, create multiple policies with the same config
 * and different match lists. This is simpler to reason about than a recursive
 * expression tree, and covers the vast majority of real-world routing needs.
 * Combinators (And/Or/Not) can be added later as new oneof branches without
 * breaking the wire format.
 *
 * @generated from message sentinel.v1.MatchExpr
 */
export type MatchExpr = Message<"sentinel.v1.MatchExpr"> & {
  /**
   * @generated from oneof sentinel.v1.MatchExpr.expr
   */
  expr: {
    /**
     * @generated from field: sentinel.v1.PathMatch path = 1;
     */
    value: PathMatch;
    case: "path";
  } | {
    /**
     * @generated from field: sentinel.v1.MethodMatch method = 2;
     */
    value: MethodMatch;
    case: "method";
  } | {
    /**
     * @generated from field: sentinel.v1.HeaderMatch header = 3;
     */
    value: HeaderMatch;
    case: "header";
  } | {
    /**
     * @generated from field: sentinel.v1.QueryParamMatch query_param = 4;
     */
    value: QueryParamMatch;
    case: "queryParam";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message sentinel.v1.MatchExpr.
 * Use `create(MatchExprSchema)` to create a new message.
 */
export const MatchExprSchema: GenMessage<MatchExpr> = /*@__PURE__*/
  messageDesc(file_middleware_v1_match, 0);

/**
 * StringMatch is the shared string matching primitive used by all leaf
 * matchers that compare against string values (paths, header values, query
 * parameter values). Centralizing matching logic in one message ensures
 * consistent behavior across all matchers and avoids duplicating regex
 * validation, case folding, and prefix logic.
 *
 * Exactly one of exact, prefix, or regex must be set. When ignore_case is
 * true, comparison is performed after Unicode case folding for exact and
 * prefix matches. For regex matches, ignore_case prepends (?i) to the
 * pattern.
 *
 * @generated from message sentinel.v1.StringMatch
 */
export type StringMatch = Message<"sentinel.v1.StringMatch"> & {
  /**
   * When true, matching is case-insensitive. Applied to all match modes.
   *
   * @generated from field: bool ignore_case = 1;
   */
  ignoreCase: boolean;

  /**
   * @generated from oneof sentinel.v1.StringMatch.match
   */
  match: {
    /**
     * The string must equal this value exactly (after optional case folding).
     *
     * @generated from field: string exact = 2;
     */
    value: string;
    case: "exact";
  } | {
    /**
     * The string must start with this prefix (after optional case folding).
     *
     * @generated from field: string prefix = 3;
     */
    value: string;
    case: "prefix";
  } | {
    /**
     * The string must match this RE2-compatible regular expression. RE2 is
     * required (not PCRE) because Go's regexp package uses RE2, which
     * guarantees linear-time matching and is safe for user-provided patterns.
     * See https://github.com/google/re2/wiki/Syntax for the full syntax.
     *
     * @generated from field: string regex = 4;
     */
    value: string;
    case: "regex";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message sentinel.v1.StringMatch.
 * Use `create(StringMatchSchema)` to create a new message.
 */
export const StringMatchSchema: GenMessage<StringMatch> = /*@__PURE__*/
  messageDesc(file_middleware_v1_match, 1);

/**
 * PathMatch tests the URL path of the incoming request. The path is compared
 * without the query string — use [QueryParamMatch] to match query parameters
 * separately. Leading slashes are preserved, so patterns should include them
 * (e.g., prefix "/api/v1" not "api/v1").
 *
 * @generated from message sentinel.v1.PathMatch
 */
export type PathMatch = Message<"sentinel.v1.PathMatch"> & {
  /**
   * @generated from field: sentinel.v1.StringMatch path = 1;
   */
  path?: StringMatch;
};

/**
 * Describes the message sentinel.v1.PathMatch.
 * Use `create(PathMatchSchema)` to create a new message.
 */
export const PathMatchSchema: GenMessage<PathMatch> = /*@__PURE__*/
  messageDesc(file_middleware_v1_match, 2);

/**
 * MethodMatch tests the HTTP method of the incoming request. Comparison is
 * always case-insensitive per the HTTP specification, regardless of the
 * StringMatch ignore_case setting. The methods list is an OR — the request
 * matches if its method equals any entry.
 *
 * @generated from message sentinel.v1.MethodMatch
 */
export type MethodMatch = Message<"sentinel.v1.MethodMatch"> & {
  /**
   * HTTP methods to match against, e.g. ["GET", "POST"]. The match succeeds
   * if the request method equals any of these values (case-insensitive).
   *
   * @generated from field: repeated string methods = 1;
   */
  methods: string[];
};

/**
 * Describes the message sentinel.v1.MethodMatch.
 * Use `create(MethodMatchSchema)` to create a new message.
 */
export const MethodMatchSchema: GenMessage<MethodMatch> = /*@__PURE__*/
  messageDesc(file_middleware_v1_match, 3);

/**
 * HeaderMatch tests a request header by name and optionally by value. Header
 * names are always matched case-insensitively per HTTP semantics (RFC 7230).
 *
 * When the request contains multiple values for the same header name (either
 * via repeated headers or comma-separated values), the match succeeds if any
 * single value satisfies the condition. This follows the principle of least
 * surprise for operators who may not know whether their clients send headers
 * as separate entries or comma-delimited lists.
 *
 * @generated from message sentinel.v1.HeaderMatch
 */
export type HeaderMatch = Message<"sentinel.v1.HeaderMatch"> & {
  /**
   * The header name to match, e.g. "X-API-Version" or "Content-Type".
   * Matched case-insensitively.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from oneof sentinel.v1.HeaderMatch.match
   */
  match: {
    /**
     * When set to true, the match succeeds if the header is present in the
     * request, regardless of its value. Useful for policies that should only
     * apply to requests carrying a specific header (e.g., match requests
     * with an Authorization header to apply auth policies).
     *
     * @generated from field: bool present = 2;
     */
    value: boolean;
    case: "present";
  } | {
    /**
     * Match against the header value(s) using a [StringMatch]. If the header
     * has multiple values, the match succeeds if any value satisfies the
     * StringMatch condition.
     *
     * @generated from field: sentinel.v1.StringMatch value = 3;
     */
    value: StringMatch;
    case: "value";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message sentinel.v1.HeaderMatch.
 * Use `create(HeaderMatchSchema)` to create a new message.
 */
export const HeaderMatchSchema: GenMessage<HeaderMatch> = /*@__PURE__*/
  messageDesc(file_middleware_v1_match, 4);

/**
 * QueryParamMatch tests a URL query parameter by name and optionally by
 * value. Query parameter names are matched case-sensitively (per the URI
 * specification), unlike header names.
 *
 * When the same parameter appears multiple times in the query string (e.g.,
 * ?tag=a&tag=b), the match succeeds if any occurrence satisfies the
 * condition.
 *
 * @generated from message sentinel.v1.QueryParamMatch
 */
export type QueryParamMatch = Message<"sentinel.v1.QueryParamMatch"> & {
  /**
   * The query parameter name to match, e.g. "version" or "debug".
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * @generated from oneof sentinel.v1.QueryParamMatch.match
   */
  match: {
    /**
     * When set to true, the match succeeds if the query parameter is present,
     * regardless of its value. Useful for feature-flag-style routing (e.g.,
     * match requests with ?debug to apply verbose access logging).
     *
     * @generated from field: bool present = 2;
     */
    value: boolean;
    case: "present";
  } | {
    /**
     * Match against the parameter value(s) using a [StringMatch].
     *
     * @generated from field: sentinel.v1.StringMatch value = 3;
     */
    value: StringMatch;
    case: "value";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message sentinel.v1.QueryParamMatch.
 * Use `create(QueryParamMatchSchema)` to create a new message.
 */
export const QueryParamMatchSchema: GenMessage<QueryParamMatch> = /*@__PURE__*/
  messageDesc(file_middleware_v1_match, 5);

