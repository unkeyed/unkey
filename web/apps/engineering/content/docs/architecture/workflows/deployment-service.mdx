---
title: Deployment Service
description: Durable deployment workflow orchestration
---

# Deployment Service

The `DeployService` orchestrates the complete deployment lifecycle, from building containers to assigning domains.

**Location:** `svc/ctrl/worker/deploy/`
**Proto:** `svc/ctrl/proto/hydra/v1/deployment.proto`
**Key:** `project_id`

## Operations

### Deploy

<Mermaid chart={`flowchart TD
    Start([Deploy Request]) --> FetchMeta[Fetch Metadata]
    FetchMeta --> CheckSource{Source Type?}
    CheckSource -->|GitSource| BuildGit[Build from Git via Depot]
    CheckSource -->|DockerImage| UseImage[Use Pre-built Image]
    BuildGit --> StatusDeploying[Status: Deploying]
    UseImage --> StatusDeploying
    StatusDeploying --> CreateTopology[Create Regional Topologies]
    CreateTopology --> EnsureSentinels[Ensure Sentinels Exist]
    EnsureSentinels --> EnsureNetPol[Ensure Cilium Network Policy]
    EnsureNetPol --> WaitReady[Wait for Instances Ready]
    WaitReady --> BuildRoutes[Build Frontline Routes]
    BuildRoutes --> AssignRoutes[Call RoutingService]
    AssignRoutes --> StatusReady[Status: Ready]
    StatusReady --> UpdateLive[Update Live Deployment]
    UpdateLive --> ScheduleStandby[Schedule Previous Standby]
    ScheduleStandby --> End([Complete])

    style BuildGit fill:#e1f5fe
    style AssignRoutes fill:#e1f5fe
    style StatusReady fill:#c8e6c9

`} />

Creates a new deployment:

1. Fetch deployment, workspace, project, environment metadata
2. Build Docker image from Git via Depot (or use pre-built image)
3. Create regional deployment topologies and ensure sentinels + Cilium network policies exist
4. Poll in parallel until all instances are running
5. Build frontline routes and call RoutingService to assign them atomically
6. Update project's live deployment pointer (production, non-rolled-back only)
7. Schedule previous live deployment for standby via DeploymentService

Implementation: `svc/ctrl/worker/deploy/deploy_handler.go`

### Rollback

<Mermaid chart={`flowchart TD
    Start([Rollback Request]) --> Validate[Validate Deployments]
    Validate --> CheckVMs[Check Target VMs]
    CheckVMs --> FindRoutes[Find Sticky Frontline Routes]
    FindRoutes --> UpdateRoutes[Update Route Deployment IDs]
    UpdateRoutes --> UpdateProject[Update Live Deployment]
    UpdateProject --> End([Success])

    style UpdateRoutes fill:#e1f5fe
    style UpdateProject fill:#c8e6c9

`} />

Rolls back to a previous deployment:

1. Validate source/target deployments
2. Find sticky frontline routes (live + environment level)
3. Update frontline routes to point to target deployment
4. Update project metadata

Implementation: `svc/ctrl/worker/deploy/rollback_handler.go`

### Promote

<Mermaid chart={`flowchart TD
    Start([Promote Request]) --> Validate[Validate Deployment]
    Validate --> FindRoutes[Find All Frontline Routes]
    FindRoutes --> UpdateRoutes[Update Route Deployment IDs]
    UpdateRoutes --> UpdateProject[Update Live Deployment]
    UpdateProject --> End([Success])

    style UpdateRoutes fill:#e1f5fe

`} />

Promotes a deployment to live, removing rolled-back state:

1. Validate deployment is ready
2. Find all project frontline routes
3. Update frontline routes to point to new deployment
4. Clear rolled_back flag

Implementation: `svc/ctrl/worker/deploy/promote_handler.go`

## Why RoutingService?

All frontline route operations are delegated to `RoutingService` to:

- Ensure atomic updates to routing configuration
- Serialize frontline route operations per project
- Provide rollback capabilities for failed routing changes
