---
title: fuzz
description: "provides utilities for consuming fuzzer-generated byte slices"
---

Package fuzz provides utilities for consuming fuzzer-generated byte slices and converting them into typed Go values.

This package is designed for use with Go's native fuzzing (testing.F) to simplify the process of generating structured test data from raw fuzzer input. Instead of manually slicing bytes and handling bounds checks, you can extract typed values directly.

The package automatically calls t.Skip() when the fuzzer-provided input is exhausted, ensuring that all generated values are derived from fuzzer-controlled bytes. This maintains the integrity of coverage-guided fuzzing - the fuzzer retains full control over all randomness.

### Key Types

The main entry point is \[Consumer], created via \[New]. Extraction methods are called on the Consumer: c.String(), c.Int(), c.Bytes(), etc. Generic functions \[Slice] and \[Struct] are also available for typed slices and struct population.

### Usage

Basic value extraction:

	func FuzzMyFunction(f *testing.F) {
	    fuzz.Seed(f) // Add deterministic seed corpus

	    f.Fuzz(func(t *testing.T, data []byte) {
	        c := fuzz.New(t, data)

	        name := c.String()
	        count := c.Int()
	        flags := fuzz.Slice[bool](c)

	        // If we reach here, all values are valid
	        MyFunction(name, count, flags)
	    })
	}

Struct generation:

	type Config struct {
	    Name    string
	    Timeout int
	    Enabled bool
	}

	func FuzzWithConfig(f *testing.F) {
	    fuzz.Seed(f)

	    f.Fuzz(func(t *testing.T, data []byte) {
	        c := fuzz.New(t, data)
	        cfg := fuzz.Struct[Config](c)

	        // Test with fully populated struct
	        Process(cfg)
	    })
	}

### Design Rationale

The package skips tests when input is exhausted rather than falling back to a PRNG. While this means short inputs produce no test coverage, it ensures that the fuzzer can discover all interesting values through input mutation. A PRNG fallback would make some values "invisible" to the coverage-guided fuzzer, potentially missing bugs that only trigger on specific values.

## Variables

```go
var seed = [32]byte{
	0x1f, 0x2e, 0x3d, 0x4c, 0x5b, 0x6a, 0x79, 0x88,
	0x97, 0xa6, 0xb5, 0xc4, 0xd3, 0xe2, 0xf1, 0x00,
	0x10, 0x21, 0x32, 0x43, 0x54, 0x65, 0x76, 0x87,
	0x98, 0xa9, 0xba, 0xcb, 0xdc, 0xed, 0xfe, 0x0f,
}
```


## Functions

### func Seed

```go
func Seed(f *testing.F)
```

Seed adds 256 deterministic pseudo-random byte slices to the fuzz corpus.

The slices vary in length from 0 to 65,025 bytes (lengths follow iÂ² pattern). Because the underlying RNG uses a fixed seed, the output is identical across runs, making fuzz test failures reproducible.

Usage:

	func FuzzSomething(f *testing.F) {
	    fuzz.Seed(f)

	    f.Fuzz(func(t *testing.T, data []byte) {
	        c := fuzz.New(t, data)
	        // ...
	    })
	}

### func Slice

```go
func Slice[T any](c *Consumer) []T
```

Slice extracts a variable-length slice of type T from the Consumer.

The length is determined by consuming a uint8 from the input (max 255 elements), then extracting that many values of type T. Skips if insufficient bytes remain.

Supported element types are the same as the Consumer methods: bool, int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64, string, time.Time, and time.Duration.

### func Struct

```go
func Struct[T any](c *Consumer) T
```

Struct populates a struct of type T with generated values.

Only exported fields are filled. Unexported fields are left at their zero value. Nested structs are filled recursively. Slice fields use \[Slice] for extraction.

Supported field types are: bool, int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64, string, time.Time, time.Duration, slices of supported types, and nested structs containing supported types.

Skips the test if insufficient bytes remain. Panics if T is not a struct or contains unsupported field types.


## Types

### type Consumer

```go
type Consumer struct {
	t    *testing.T
	data []byte
	pos  int
}
```

Consumer consumes bytes from fuzzer input to generate typed values.

Consumer tracks a position within the input byte slice and advances it as values are extracted. When insufficient bytes remain for a requested operation, Consumer automatically calls t.Skip() to abort the test iteration.

Consumer is not safe for concurrent use.

#### func New

```go
func New(t *testing.T, data []byte) *Consumer
```

New creates a Consumer from fuzzer-provided bytes.

The Consumer will use t.Skip() to abort test iterations when the input is exhausted, ensuring all generated values come from fuzzer-controlled bytes.

#### func (Consumer) Bool

```go
func (c *Consumer) Bool() bool
```

Bool extracts a boolean value from the Consumer.

#### func (Consumer) Bytes

```go
func (c *Consumer) Bytes() []byte
```

Bytes extracts a variable-length byte slice from the Consumer. Uses a uint16 for the length prefix, limiting slices to 65535 bytes.

#### func (Consumer) BytesN

```go
func (c *Consumer) BytesN(n int) []byte
```

BytesN extracts exactly n bytes from the Consumer.

#### func (Consumer) Duration

```go
func (c *Consumer) Duration() time.Duration
```

Duration extracts a time.Duration value from the Consumer as nanoseconds.

#### func (Consumer) Exhausted

```go
func (c *Consumer) Exhausted() bool
```

Exhausted returns true if no bytes remain to be consumed.

#### func (Consumer) Float32

```go
func (c *Consumer) Float32() float32
```

Float32 extracts a float32 value from the Consumer (4 bytes).

#### func (Consumer) Float64

```go
func (c *Consumer) Float64() float64
```

Float64 extracts a float64 value from the Consumer (8 bytes).

#### func (Consumer) Int

```go
func (c *Consumer) Int() int
```

Int extracts an int value from the Consumer (8 bytes).

#### func (Consumer) Int16

```go
func (c *Consumer) Int16() int16
```

Int16 extracts an int16 value from the Consumer (2 bytes, big-endian).

#### func (Consumer) Int32

```go
func (c *Consumer) Int32() int32
```

Int32 extracts an int32 value from the Consumer (4 bytes, big-endian).

#### func (Consumer) Int64

```go
func (c *Consumer) Int64() int64
```

Int64 extracts an int64 value from the Consumer (8 bytes, big-endian).

#### func (Consumer) Int8

```go
func (c *Consumer) Int8() int8
```

Int8 extracts an int8 value from the Consumer.

#### func (Consumer) Remaining

```go
func (c *Consumer) Remaining() int
```

Remaining returns the number of unconsumed bytes.

#### func (Consumer) String

```go
func (c *Consumer) String() string
```

String extracts a length-prefixed string from the Consumer. Uses a uint16 for the length, limiting strings to 65535 bytes.

#### func (Consumer) Time

```go
func (c *Consumer) Time() time.Time
```

Time extracts a time.Time value from the Consumer as Unix nanoseconds.

#### func (Consumer) Uint

```go
func (c *Consumer) Uint() uint
```

Uint extracts a uint value from the Consumer (8 bytes).

#### func (Consumer) Uint16

```go
func (c *Consumer) Uint16() uint16
```

Uint16 extracts a uint16 value from the Consumer (2 bytes, big-endian).

#### func (Consumer) Uint32

```go
func (c *Consumer) Uint32() uint32
```

Uint32 extracts a uint32 value from the Consumer (4 bytes, big-endian).

#### func (Consumer) Uint64

```go
func (c *Consumer) Uint64() uint64
```

Uint64 extracts a uint64 value from the Consumer (8 bytes, big-endian).

#### func (Consumer) Uint8

```go
func (c *Consumer) Uint8() uint8
```

Uint8 extracts a uint8 value from the Consumer.

