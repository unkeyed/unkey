---
title: array
description: "provides generic utility functions for slice generation and manipulation"
---

Package array provides generic utility functions for slice generation and manipulation.

The package implements core operations for test data generation: creating slices with generated values (\[Fill]), selecting random elements (\[Random]), transforming slices (\[Map]), and aggregating slice data (\[Reduce]).

All functions use Go generics for type safety and are optimized for high-frequency use in test data generation scenarios.

### Usage

Generate slices with \[Fill]:

	userIDs := array.Fill(1000, func() string {
	    return fmt.Sprintf("user_%d", rand.Intn(100000))
	})

Select random elements with \[Random]:

	outcomes := []string{"VALID", "INVALID", "EXPIRED"}
	outcome := array.Random(outcomes)

Transform data with \[Map]:

	numbers := []int{1, 2, 3}
	strings := array.Map(numbers, strconv.Itoa)

Aggregate data with \[Reduce]:

	sum := array.Reduce(numbers, func(acc, val int) int { return acc + val }, 0)

### Performance

\[Fill] uses single allocation with O(n) time complexity. \[Random] operates in O(1) constant time. \[Map] and \[Reduce] both use O(n) time with single allocation where applicable.

### Concurrency

All functions are safe for concurrent use when operating on different slices. \[Random] uses Go's global RNG which may become a bottleneck under extreme concurrency.

## Functions

### func Chunk

```go
func Chunk[T any](slice []T, n int) [][]T
```

Chunk splits a slice into chunks of size n.

### func Fill

```go
func Fill[T any](length int, generator func() T) []T
```

Fill creates a new slice with the specified length where each element is generated by calling the provided function.

The generator function is called exactly length times in sequential order. Returns an empty slice for zero or negative length.

Parameters:

  - length: Number of elements to create
  - generator: Function called once per element to generate the value

The returned slice has capacity equal to length for optimal memory allocation.

	// Generate test data
	userIDs := array.Fill(1000, func() string {
	    return fmt.Sprintf("user_%d", rand.Intn(10000))
	})

	// Create structs with varying properties
	testCases := array.Fill(100, func() TestCase {
	    return TestCase{ID: rand.Int(), Created: time.Now()}
	})

### func Map

```go
func Map[T any, R any](arr []T, fn func(T) R) []R
```

Map creates a new slice by applying the transformation function to each element of the input slice.

The transformation function is called exactly once per element in sequential order. The result slice has the same length as the input slice.

Parameters:

  - arr: Input slice to transform

  - fn: Function applied to each element to produce the transformed value

    // Extract fields from structs users := \[]User{{ID: 1, Name: "Alice"}, {ID: 2, Name: "Bob"}} userIDs := array.Map(users, func(u User) int { return u.ID }) // Result: \[]int{1, 2}

    // Convert between types numbers := \[]int{1, 2, 3} strings := array.Map(numbers, func(n int) string { return strconv.Itoa(n) }) // Result: \[]string{"1", "2", "3"}

### func Random

```go
func Random[T any](slice []T) T
```

Random returns a uniformly selected element from the slice.

Uses Go's global random number generator to select with uniform probability distribution. Each element has equal chance of selection regardless of position or value.

Panics if the slice is empty.

	// Select random test outcomes
	outcomes := []string{"VALID", "INVALID", "EXPIRED"}
	outcome := array.Random(outcomes)

	// Use in data generation
	regions := []string{"us-east-1", "us-west-2", "eu-west-1"}
	testData := array.Fill(1000, func() TestCase {
	    return TestCase{Region: array.Random(regions)}
	})

### func Reduce

```go
func Reduce[T any, R any](arr []T, fn func(R, T) R, init R) R
```

Reduce aggregates all elements of a slice into a single value using the reduction function.

Processes each element in order, combining it with the accumulator using the provided function. The reduction function receives the current accumulator and the current element.

Parameters:

  - arr: Input slice to reduce

  - fn: Function that combines the accumulator with each element

  - init: Initial accumulator value, returned if slice is empty

    // Sum numbers numbers := \[]int{1, 2, 3, 4, 5} sum := array.Reduce(numbers, func(acc, val int) int { return acc + val }, 0) // Result: 15

    // Build frequency map words := \[]string{"hello", "world", "hello"} freq := array.Reduce(words, func(acc map\[string]int, word string) map\[string]int { acc\[word]++ return acc }, make(map\[string]int)) // Result: map\[string]int{"hello": 2, "world": 1}

