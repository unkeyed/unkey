// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
)

const allocateIP = `-- name: AllocateIP :one
INSERT INTO ip_allocations (vm_id, ip_addr, network_allocation_id)
VALUES (?, ?, ?)
RETURNING id, vm_id, ip_addr, network_allocation_id, allocated_at
`

type AllocateIPParams struct {
	VmID                string `db:"vm_id" json:"vm_id"`
	IpAddr              string `db:"ip_addr" json:"ip_addr"`
	NetworkAllocationID int64  `db:"network_allocation_id" json:"network_allocation_id"`
}

func (q *Queries) AllocateIP(ctx context.Context, arg AllocateIPParams) (IpAllocation, error) {
	row := q.db.QueryRowContext(ctx, allocateIP, arg.VmID, arg.IpAddr, arg.NetworkAllocationID)
	var i IpAllocation
	err := row.Scan(
		&i.ID,
		&i.VmID,
		&i.IpAddr,
		&i.NetworkAllocationID,
		&i.AllocatedAt,
	)
	return i, err
}

const allocateNetwork = `-- name: AllocateNetwork :one

UPDATE networks
SET is_allocated = 1
WHERE id = (
    SELECT id FROM networks
    WHERE is_allocated = 0
    ORDER BY id
    LIMIT 1
)
RETURNING id, base_network, is_allocated
`

// queries.sql
func (q *Queries) AllocateNetwork(ctx context.Context) (Network, error) {
	row := q.db.QueryRowContext(ctx, allocateNetwork)
	var i Network
	err := row.Scan(&i.ID, &i.BaseNetwork, &i.IsAllocated)
	return i, err
}

const createNetworkAllocation = `-- name: CreateNetworkAllocation :one
INSERT INTO network_allocations (deployment_id, network_id, available_ips)
VALUES (?, ?, ?)
RETURNING id, deployment_id, network_id, available_ips, allocated_at
`

type CreateNetworkAllocationParams struct {
	DeploymentID string `db:"deployment_id" json:"deployment_id"`
	NetworkID    int64  `db:"network_id" json:"network_id"`
	AvailableIps string `db:"available_ips" json:"available_ips"`
}

func (q *Queries) CreateNetworkAllocation(ctx context.Context, arg CreateNetworkAllocationParams) (NetworkAllocation, error) {
	row := q.db.QueryRowContext(ctx, createNetworkAllocation, arg.DeploymentID, arg.NetworkID, arg.AvailableIps)
	var i NetworkAllocation
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.NetworkID,
		&i.AvailableIps,
		&i.AllocatedAt,
	)
	return i, err
}

const deleteIPAllocationsForNetwork = `-- name: DeleteIPAllocationsForNetwork :exec
DELETE FROM ip_allocations
WHERE network_allocation_id = ?
`

func (q *Queries) DeleteIPAllocationsForNetwork(ctx context.Context, networkAllocationID int64) error {
	_, err := q.db.ExecContext(ctx, deleteIPAllocationsForNetwork, networkAllocationID)
	return err
}

const deleteNetworkAllocation = `-- name: DeleteNetworkAllocation :exec
DELETE FROM network_allocations
WHERE deployment_id = ?
`

func (q *Queries) DeleteNetworkAllocation(ctx context.Context, deploymentID string) error {
	_, err := q.db.ExecContext(ctx, deleteNetworkAllocation, deploymentID)
	return err
}

const getAvailableIPCount = `-- name: GetAvailableIPCount :one
SELECT json_array_length(available_ips) as count
FROM network_allocations
WHERE deployment_id = ?
`

func (q *Queries) GetAvailableIPCount(ctx context.Context, deploymentID string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getAvailableIPCount, deploymentID)
	var count interface{}
	err := row.Scan(&count)
	return count, err
}

const getIPAllocation = `-- name: GetIPAllocation :one
SELECT id, vm_id, ip_addr, network_allocation_id, allocated_at FROM ip_allocations WHERE vm_id = ?
`

func (q *Queries) GetIPAllocation(ctx context.Context, vmID string) (IpAllocation, error) {
	row := q.db.QueryRowContext(ctx, getIPAllocation, vmID)
	var i IpAllocation
	err := row.Scan(
		&i.ID,
		&i.VmID,
		&i.IpAddr,
		&i.NetworkAllocationID,
		&i.AllocatedAt,
	)
	return i, err
}

const getNetworkAllocation = `-- name: GetNetworkAllocation :one
SELECT na.id, na.deployment_id, na.network_id, na.available_ips, na.allocated_at, n.base_network
FROM network_allocations na
JOIN networks n ON na.network_id = n.id
WHERE na.deployment_id = ?
`

type GetNetworkAllocationRow struct {
	ID           int64        `db:"id" json:"id"`
	DeploymentID string       `db:"deployment_id" json:"deployment_id"`
	NetworkID    int64        `db:"network_id" json:"network_id"`
	AvailableIps string       `db:"available_ips" json:"available_ips"`
	AllocatedAt  sql.NullTime `db:"allocated_at" json:"allocated_at"`
	BaseNetwork  string       `db:"base_network" json:"base_network"`
}

func (q *Queries) GetNetworkAllocation(ctx context.Context, deploymentID string) (GetNetworkAllocationRow, error) {
	row := q.db.QueryRowContext(ctx, getNetworkAllocation, deploymentID)
	var i GetNetworkAllocationRow
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.NetworkID,
		&i.AvailableIps,
		&i.AllocatedAt,
		&i.BaseNetwork,
	)
	return i, err
}

const getNetworkStats = `-- name: GetNetworkStats :one
SELECT
    (SELECT COUNT(*) FROM networks) as total_networks,
    (SELECT COUNT(*) FROM networks WHERE is_allocated = 0) as available_networks,
    (SELECT COUNT(*) FROM network_allocations) as active_deployments,
    (SELECT COUNT(*) FROM ip_allocations) as allocated_ips
`

type GetNetworkStatsRow struct {
	TotalNetworks     int64 `db:"total_networks" json:"total_networks"`
	AvailableNetworks int64 `db:"available_networks" json:"available_networks"`
	ActiveDeployments int64 `db:"active_deployments" json:"active_deployments"`
	AllocatedIps      int64 `db:"allocated_ips" json:"allocated_ips"`
}

func (q *Queries) GetNetworkStats(ctx context.Context) (GetNetworkStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getNetworkStats)
	var i GetNetworkStatsRow
	err := row.Scan(
		&i.TotalNetworks,
		&i.AvailableNetworks,
		&i.ActiveDeployments,
		&i.AllocatedIps,
	)
	return i, err
}

const popAvailableIPJSON = `-- name: PopAvailableIPJSON :one
UPDATE network_allocations
SET available_ips = json_remove(available_ips, '$[0]')
WHERE deployment_id = ?
AND json_array_length(available_ips) > 0
RETURNING json_extract(available_ips, '$[0]') as allocated_ip, id
`

type PopAvailableIPJSONRow struct {
	JsonExtract interface{} `db:"json_extract" json:"json_extract"`
	ID          int64       `db:"id" json:"id"`
}

func (q *Queries) PopAvailableIPJSON(ctx context.Context, deploymentID string) (PopAvailableIPJSONRow, error) {
	row := q.db.QueryRowContext(ctx, popAvailableIPJSON, deploymentID)
	var i PopAvailableIPJSONRow
	err := row.Scan(&i.JsonExtract, &i.ID)
	return i, err
}

const releaseIP = `-- name: ReleaseIP :exec
DELETE FROM ip_allocations WHERE vm_id = ?
`

func (q *Queries) ReleaseIP(ctx context.Context, vmID string) error {
	_, err := q.db.ExecContext(ctx, releaseIP, vmID)
	return err
}

const releaseNetwork = `-- name: ReleaseNetwork :exec
UPDATE networks
SET is_allocated = 0
WHERE id = ?
`

func (q *Queries) ReleaseNetwork(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, releaseNetwork, id)
	return err
}

const returnIPJSON = `-- name: ReturnIPJSON :exec
UPDATE network_allocations
SET available_ips = json_insert(available_ips, '$[#]', ?)
WHERE deployment_id = ?
`

type ReturnIPJSONParams struct {
	JsonInsert   interface{} `db:"json_insert" json:"json_insert"`
	DeploymentID string      `db:"deployment_id" json:"deployment_id"`
}

func (q *Queries) ReturnIPJSON(ctx context.Context, arg ReturnIPJSONParams) error {
	_, err := q.db.ExecContext(ctx, returnIPJSON, arg.JsonInsert, arg.DeploymentID)
	return err
}
