// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
)

const allocateIP = `-- name: AllocateIP :one
INSERT INTO ip_allocations (vm_id, ip_addr, network_allocation_id)
VALUES (?, ?, ?)
RETURNING id, vm_id, ip_addr, network_allocation_id, allocated_at
`

type AllocateIPParams struct {
	VmID                string `db:"vm_id" json:"vm_id"`
	IpAddr              string `db:"ip_addr" json:"ip_addr"`
	NetworkAllocationID int64  `db:"network_allocation_id" json:"network_allocation_id"`
}

func (q *Queries) AllocateIP(ctx context.Context, arg AllocateIPParams) (IpAllocation, error) {
	row := q.db.QueryRowContext(ctx, allocateIP, arg.VmID, arg.IpAddr, arg.NetworkAllocationID)
	var i IpAllocation
	err := row.Scan(
		&i.ID,
		&i.VmID,
		&i.IpAddr,
		&i.NetworkAllocationID,
		&i.AllocatedAt,
	)
	return i, err
}

const allocateNetwork = `-- name: AllocateNetwork :one

UPDATE networks
SET is_allocated = 1
WHERE id = (
    SELECT id FROM networks
    WHERE is_allocated = 0
    ORDER BY id
    LIMIT 1
)
RETURNING id, base_network, is_allocated
`

// queries.sql
func (q *Queries) AllocateNetwork(ctx context.Context) (Network, error) {
	row := q.db.QueryRowContext(ctx, allocateNetwork)
	var i Network
	err := row.Scan(&i.ID, &i.BaseNetwork, &i.IsAllocated)
	return i, err
}

const createNetworkAllocation = `-- name: CreateNetworkAllocation :one
INSERT INTO network_allocations (deployment_id, network_id, available_ips, bridge_name)
VALUES (?, ?, ?, ?)
RETURNING id, deployment_id, network_id, bridge_name, available_ips, allocated_at
`

type CreateNetworkAllocationParams struct {
	DeploymentID string `db:"deployment_id" json:"deployment_id"`
	NetworkID    int64  `db:"network_id" json:"network_id"`
	AvailableIps string `db:"available_ips" json:"available_ips"`
	BridgeName   string `db:"bridge_name" json:"bridge_name"`
}

func (q *Queries) CreateNetworkAllocation(ctx context.Context, arg CreateNetworkAllocationParams) (NetworkAllocation, error) {
	row := q.db.QueryRowContext(ctx, createNetworkAllocation,
		arg.DeploymentID,
		arg.NetworkID,
		arg.AvailableIps,
		arg.BridgeName,
	)
	var i NetworkAllocation
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.NetworkID,
		&i.BridgeName,
		&i.AvailableIps,
		&i.AllocatedAt,
	)
	return i, err
}

const createVM = `-- name: CreateVM :one
INSERT INTO vms (
    vm_id,
    deployment_id,
    vcpu_count,
    memory_size_mib,
    boot,
    network_config,
    console_config,
    storage_config,
    metadata,
    ip_address,
    bridge_name,
    status
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING vm_id, deployment_id, vcpu_count, memory_size_mib, boot, network_config, console_config, storage_config, metadata, ip_address, bridge_name, status, error_message, created_at, updated_at, started_at, stopped_at
`

type CreateVMParams struct {
	VmID          string         `db:"vm_id" json:"vm_id"`
	DeploymentID  string         `db:"deployment_id" json:"deployment_id"`
	VcpuCount     int64          `db:"vcpu_count" json:"vcpu_count"`
	MemorySizeMib int64          `db:"memory_size_mib" json:"memory_size_mib"`
	Boot          string         `db:"boot" json:"boot"`
	NetworkConfig sql.NullString `db:"network_config" json:"network_config"`
	ConsoleConfig sql.NullString `db:"console_config" json:"console_config"`
	StorageConfig sql.NullString `db:"storage_config" json:"storage_config"`
	Metadata      sql.NullString `db:"metadata" json:"metadata"`
	IpAddress     sql.NullString `db:"ip_address" json:"ip_address"`
	BridgeName    sql.NullString `db:"bridge_name" json:"bridge_name"`
	Status        int64          `db:"status" json:"status"`
}

func (q *Queries) CreateVM(ctx context.Context, arg CreateVMParams) (Vm, error) {
	row := q.db.QueryRowContext(ctx, createVM,
		arg.VmID,
		arg.DeploymentID,
		arg.VcpuCount,
		arg.MemorySizeMib,
		arg.Boot,
		arg.NetworkConfig,
		arg.ConsoleConfig,
		arg.StorageConfig,
		arg.Metadata,
		arg.IpAddress,
		arg.BridgeName,
		arg.Status,
	)
	var i Vm
	err := row.Scan(
		&i.VmID,
		&i.DeploymentID,
		&i.VcpuCount,
		&i.MemorySizeMib,
		&i.Boot,
		&i.NetworkConfig,
		&i.ConsoleConfig,
		&i.StorageConfig,
		&i.Metadata,
		&i.IpAddress,
		&i.BridgeName,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.StoppedAt,
	)
	return i, err
}

const deleteIPAllocationsForNetwork = `-- name: DeleteIPAllocationsForNetwork :exec
DELETE FROM ip_allocations
WHERE network_allocation_id = ?
`

func (q *Queries) DeleteIPAllocationsForNetwork(ctx context.Context, networkAllocationID int64) error {
	_, err := q.db.ExecContext(ctx, deleteIPAllocationsForNetwork, networkAllocationID)
	return err
}

const deleteNetworkAllocation = `-- name: DeleteNetworkAllocation :exec
DELETE FROM network_allocations
WHERE deployment_id = ?
`

func (q *Queries) DeleteNetworkAllocation(ctx context.Context, deploymentID string) error {
	_, err := q.db.ExecContext(ctx, deleteNetworkAllocation, deploymentID)
	return err
}

const getAvailableIPCount = `-- name: GetAvailableIPCount :one
SELECT json_array_length(available_ips) as count
FROM network_allocations
WHERE deployment_id = ?
`

func (q *Queries) GetAvailableIPCount(ctx context.Context, deploymentID string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getAvailableIPCount, deploymentID)
	var count interface{}
	err := row.Scan(&count)
	return count, err
}

const getIPAllocation = `-- name: GetIPAllocation :one
SELECT id, vm_id, ip_addr, network_allocation_id, allocated_at FROM ip_allocations WHERE vm_id = ?
`

func (q *Queries) GetIPAllocation(ctx context.Context, vmID string) (IpAllocation, error) {
	row := q.db.QueryRowContext(ctx, getIPAllocation, vmID)
	var i IpAllocation
	err := row.Scan(
		&i.ID,
		&i.VmID,
		&i.IpAddr,
		&i.NetworkAllocationID,
		&i.AllocatedAt,
	)
	return i, err
}

const getNetworkAllocation = `-- name: GetNetworkAllocation :one
SELECT na.id, na.deployment_id, na.network_id, na.bridge_name, na.available_ips, na.allocated_at, n.base_network
FROM network_allocations na
JOIN networks n ON na.network_id = n.id
WHERE na.deployment_id = ?
`

type GetNetworkAllocationRow struct {
	ID           int64        `db:"id" json:"id"`
	DeploymentID string       `db:"deployment_id" json:"deployment_id"`
	NetworkID    int64        `db:"network_id" json:"network_id"`
	BridgeName   string       `db:"bridge_name" json:"bridge_name"`
	AvailableIps string       `db:"available_ips" json:"available_ips"`
	AllocatedAt  sql.NullTime `db:"allocated_at" json:"allocated_at"`
	BaseNetwork  string       `db:"base_network" json:"base_network"`
}

func (q *Queries) GetNetworkAllocation(ctx context.Context, deploymentID string) (GetNetworkAllocationRow, error) {
	row := q.db.QueryRowContext(ctx, getNetworkAllocation, deploymentID)
	var i GetNetworkAllocationRow
	err := row.Scan(
		&i.ID,
		&i.DeploymentID,
		&i.NetworkID,
		&i.BridgeName,
		&i.AvailableIps,
		&i.AllocatedAt,
		&i.BaseNetwork,
	)
	return i, err
}

const getNetworkStats = `-- name: GetNetworkStats :one
SELECT
    (SELECT COUNT(*) FROM networks) as total_networks,
    (SELECT COUNT(*) FROM networks WHERE is_allocated = 0) as available_networks,
    (SELECT COUNT(*) FROM network_allocations) as active_deployments,
    (SELECT COUNT(*) FROM ip_allocations) as allocated_ips
`

type GetNetworkStatsRow struct {
	TotalNetworks     int64 `db:"total_networks" json:"total_networks"`
	AvailableNetworks int64 `db:"available_networks" json:"available_networks"`
	ActiveDeployments int64 `db:"active_deployments" json:"active_deployments"`
	AllocatedIps      int64 `db:"allocated_ips" json:"allocated_ips"`
}

func (q *Queries) GetNetworkStats(ctx context.Context) (GetNetworkStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getNetworkStats)
	var i GetNetworkStatsRow
	err := row.Scan(
		&i.TotalNetworks,
		&i.AvailableNetworks,
		&i.ActiveDeployments,
		&i.AllocatedIps,
	)
	return i, err
}

const getVM = `-- name: GetVM :one
SELECT vm_id, deployment_id, vcpu_count, memory_size_mib, boot, network_config, console_config, storage_config, metadata, ip_address, bridge_name, status, error_message, created_at, updated_at, started_at, stopped_at FROM vms
WHERE vm_id = ?
`

func (q *Queries) GetVM(ctx context.Context, vmID string) (Vm, error) {
	row := q.db.QueryRowContext(ctx, getVM, vmID)
	var i Vm
	err := row.Scan(
		&i.VmID,
		&i.DeploymentID,
		&i.VcpuCount,
		&i.MemorySizeMib,
		&i.Boot,
		&i.NetworkConfig,
		&i.ConsoleConfig,
		&i.StorageConfig,
		&i.Metadata,
		&i.IpAddress,
		&i.BridgeName,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.StoppedAt,
	)
	return i, err
}

const getVMsByDeployment = `-- name: GetVMsByDeployment :many
SELECT vm_id, deployment_id, vcpu_count, memory_size_mib, boot, network_config, console_config, storage_config, metadata, ip_address, bridge_name, status, error_message, created_at, updated_at, started_at, stopped_at FROM vms
WHERE deployment_id = ?
ORDER BY created_at
`

func (q *Queries) GetVMsByDeployment(ctx context.Context, deploymentID string) ([]Vm, error) {
	rows, err := q.db.QueryContext(ctx, getVMsByDeployment, deploymentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Vm
	for rows.Next() {
		var i Vm
		if err := rows.Scan(
			&i.VmID,
			&i.DeploymentID,
			&i.VcpuCount,
			&i.MemorySizeMib,
			&i.Boot,
			&i.NetworkConfig,
			&i.ConsoleConfig,
			&i.StorageConfig,
			&i.Metadata,
			&i.IpAddress,
			&i.BridgeName,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.StoppedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const popAvailableIPJSON = `-- name: PopAvailableIPJSON :one
UPDATE network_allocations
SET available_ips = json_remove(available_ips, '$[0]')
WHERE deployment_id = ?
AND json_array_length(available_ips) > 0
RETURNING CAST(json_extract(available_ips, '$[0]') AS TEXT) AS ip, id
`

type PopAvailableIPJSONRow struct {
	Column1 string `db:"column_1" json:"column_1"`
	ID      int64  `db:"id" json:"id"`
}

func (q *Queries) PopAvailableIPJSON(ctx context.Context, deploymentID string) (PopAvailableIPJSONRow, error) {
	row := q.db.QueryRowContext(ctx, popAvailableIPJSON, deploymentID)
	var i PopAvailableIPJSONRow
	err := row.Scan(&i.Column1, &i.ID)
	return i, err
}

const releaseIP = `-- name: ReleaseIP :exec
DELETE FROM ip_allocations WHERE vm_id = ?
`

func (q *Queries) ReleaseIP(ctx context.Context, vmID string) error {
	_, err := q.db.ExecContext(ctx, releaseIP, vmID)
	return err
}

const releaseNetwork = `-- name: ReleaseNetwork :exec
UPDATE networks
SET is_allocated = 0
WHERE id = ?
`

func (q *Queries) ReleaseNetwork(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, releaseNetwork, id)
	return err
}

const returnIPJSON = `-- name: ReturnIPJSON :exec
UPDATE network_allocations
SET available_ips = json_insert(available_ips, '$[#]', ?)
WHERE deployment_id = ?
`

type ReturnIPJSONParams struct {
	JsonInsert   interface{} `db:"json_insert" json:"json_insert"`
	DeploymentID string      `db:"deployment_id" json:"deployment_id"`
}

func (q *Queries) ReturnIPJSON(ctx context.Context, arg ReturnIPJSONParams) error {
	_, err := q.db.ExecContext(ctx, returnIPJSON, arg.JsonInsert, arg.DeploymentID)
	return err
}

const updateVMStatus = `-- name: UpdateVMStatus :exec
UPDATE vms
SET status = ?,
    error_message = ?,
    updated_at = ?,
    started_at = ?,
    stopped_at = ?
WHERE vm_id = ?
`

type UpdateVMStatusParams struct {
	Status       int64          `db:"status" json:"status"`
	ErrorMessage sql.NullString `db:"error_message" json:"error_message"`
	UpdatedAt    int64          `db:"updated_at" json:"updated_at"`
	StartedAt    sql.NullInt64  `db:"started_at" json:"started_at"`
	StoppedAt    sql.NullInt64  `db:"stopped_at" json:"stopped_at"`
	VmID         string         `db:"vm_id" json:"vm_id"`
}

func (q *Queries) UpdateVMStatus(ctx context.Context, arg UpdateVMStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateVMStatus,
		arg.Status,
		arg.ErrorMessage,
		arg.UpdatedAt,
		arg.StartedAt,
		arg.StoppedAt,
		arg.VmID,
	)
	return err
}
