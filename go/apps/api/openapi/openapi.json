{
  "info": {
    "title": "Unkey API",
    "version": "2.0.0",
    "description": "Unkey API provides comprehensive API key management services including creation, verification, and management of API keys with fine-grained permissions, rate limiting, and analytics.\n\nThis API uses HTTP Bearer authentication with root keys. Most endpoints require specific permissions associated with your root key. When making requests, include your root key in the Authorization header:\n```\nAuthorization: Bearer your_root_key_here\n```\n\nAll responses follow a consistent structure with a 'meta' object containing request metadata and a 'data' object containing the actual response data. Error responses include detailed information about what went wrong and how to fix it."
  },
  "openapi": "3.0.1",
  "servers": [
    {
      "url": "https://api.unkey.com"
    }
  ],
  "x-speakeasy-retries": {
    "strategy": "backoff",
    "backoff": {
      "initialInterval": 50,
      "maxInterval": 1000,
      "maxElapsedTime": 10000,
      "exponent": 1.5
    },
    "statusCodes": [
      "5XX"
    ],
    "retryConnectionErrors": true
  },
  "security": [
    {
      "rootKey": []
    }
  ],
  "components": {
    "securitySchemes": {
      "rootKey": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "root key",
        "description": "Unkey uses API keys (root keys) for authentication. These keys authorize access to management operations in the API.\n\nTo authenticate, include your root key in the Authorization header of each request:\n```\nAuthorization: Bearer your_root_key_here\n```\n\nRoot keys have specific permissions attached to them, controlling what operations they can perform. Key permissions follow a hierarchical structure with patterns like 'resource.resource_id.action' (e.g., 'apis.*.create_key', 'apis.*.read_api').\n\nSecurity best practices:\n- Keep root keys secure and never expose them in client-side code\n- Use different root keys for different environments\n- Rotate keys periodically, especially after team member departures\n- Create keys with minimal necessary permissions following least privilege principle\n- Monitor key usage with audit logs.",
        "x-speakeasy-example": "UNKEY_ROOT_KEY"
      }
    },
    "schemas": {
      "V2KeysUpdateKeyRequestBody": {
        "type": "object",
        "required": [
          "keyId"
        ],
        "properties": {
          "keyId": {
            "type": "string",
            "minLength": 3,
            "description": "The unique identifier of the key to update (starts with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. Always required for any update operation.",
            "example": "key_2cGKbMxRyIzhCxo1Idjz8q"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "A descriptive name for the key for internal reference. Set to null to remove the name. Omit this field to leave it unchanged. Good naming helps with key organization, especially when managing many keys for different users or services.",
            "example": "Payment Service Production Key"
          },
          "externalId": {
            "type": "string",
            "nullable": true,
            "description": "Your user's unique identifier, creating a link between Unkey and your system. This helps identify which user/entity owns this key during verification. Set to null to disconnect this key from any identity. Omit this field to leave it unchanged. Useful when transferring keys between users or when a user's ID changes in your system.",
            "example": "user_912a841d"
          },
          "meta": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Arbitrary JSON metadata to associate with this key. This data is returned during key verification and can be used to store anything needed during API access: subscription plans, feature flags, user properties, etc. Set to null to remove all metadata. Omit this field to leave it unchanged. This lets you update user context without having to issue new keys.",
            "example": {
              "plan": "enterprise",
              "limits": {
                "storage": "500GB",
                "compute": "1000 minutes/month"
              },
              "hasAcceptedTerms": true,
              "lastBillingDate": "2023-10-15"
            }
          },
          "expires": {
            "type": "integer",
            "nullable": true,
            "format": "int64",
            "description": "Unix timestamp (in milliseconds) when this key will automatically expire. After this time, verification will fail with code=EXPIRED. Set to null to remove an expiration date (making the key permanent). Omit this field to leave it unchanged. Useful for extending trials, adjusting subscription periods, or implementing temporary access.",
            "example": 1704067200000
          },
          "credits": {
            "type": "object",
            "nullable": true,
            "properties": {
              "remaining": {
                "type": "integer",
                "format": "int32",
                "description": "Number of times this key can be used before becoming invalid. Required when specifying credits. Use this to implement usage-based pricing, subscription tiers, or consumption quotas. Each verification reduces this count by the verification cost (default 1).",
                "example": 1000
              },
              "refill": {
                "type": "object",
                "nullable": true,
                "properties": {
                  "interval": {
                    "type": "string",
                    "enum": [
                      "daily",
                      "monthly"
                    ],
                    "description": "How often the credits should be refilled. For 'monthly' refills, you can specify the day of month using 'refillDay'. Use 'daily' for high-frequency use cases (e.g., 100 requests per day) and 'monthly' for subscription-based models."
                  },
                  "amount": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Number of credits to add during each automatic refill. This typically matches your plan's quota (e.g., 1000 API calls per month)."
                  },
                  "refillDay": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 31,
                    "description": "For monthly refills, the day of month when refills occur. Cannot be used with 'daily' interval. Useful for aligning quota refills with billing cycles or subscription renewal dates."
                  }
                },
                "required": [
                  "interval",
                  "amount"
                ],
                "description": "Configuration for automatic credit refills. Set to null to disable automatic refills (creating a one-time credit allocation). Omit this field to leave existing refill settings unchanged. Use refills to implement recurring quotas that reset on a schedule."
              }
            },
            "required": [
              "remaining"
            ],
            "description": "Usage limits configuration for this key. Set to null to disable usage limits entirely (unlimited usage). Omit this field to leave all usage limit settings unchanged. Note: Cannot set refill when credits is null; setting refillDay requires interval to be 'monthly'. Use this to implement usage-based pricing models or to apply different quotas for different subscription tiers."
          },
          "ratelimits": {
            "type": "array",
            "nullable": true,
            "items": {
              "type": "object",
              "required": [
                "name",
                "limit",
                "duration"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "minLength": 1,
                  "description": "Identifier for this rate limit. Names must be unique for this key. Use semantic names reflecting what's being limited, such as 'requests' (overall API calls), 'computations' (intensive operations), or 'write_operations' (data-modifying calls).",
                  "example": "requests"
                },
                "limit": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 1,
                  "description": "Maximum number of operations allowed within the time window. When this limit is reached, verification fails with code=RATE_LIMITED until the window resets. Adjust this based on your API's capacity and the user's expected usage patterns.",
                  "example": 100
                },
                "duration": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 1000,
                  "description": "Duration of the rate limit window in milliseconds. Common values include 60000 (1 minute), 3600000 (1 hour), and 86400000 (24 hours). The rate limit automatically resets after this period elapses.",
                  "example": 60000
                },
                "async": {
                  "type": "boolean",
                  "default": true,
                  "description": "Whether this rate limit uses fast (async=true) or consistent (async=false) mode. Fast mode has lower latency but less accuracy, making it suitable for most use cases. Consistent mode provides stronger guarantees but adds latency to verifications. Use consistent mode only when strict rate limiting is essential."
                }
              }
            },
            "description": "Array of rate limits to apply to this key. Rate limits provide protection against abuse by controlling request frequency. Set to null to remove all rate limits. Omit this field to leave existing rate limits unchanged. Unlike credits (which limit total usage), rate limits are time-based and automatically reset. You can define multiple named rate limits to control different aspects of API usage with different thresholds and time windows."
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether the key is currently active. When set to false, verification attempts will fail with code=DISABLED. This allows temporarily suspending access without deleting the key, which is useful for pausing subscriptions, handling account issues, or during maintenance. Omit this field to leave the enabled status unchanged.",
            "example": true
          }
        },
        "additionalProperties": false
      },
      "KeysUpdateKeyResponseData": {
        "type": "object",
        "properties": {},
        "description": "Empty response object by design. A successful response indicates the key was updated successfully. The endpoint doesn't return the updated key to reduce response size and avoid exposing sensitive information. Changes may take up to 30 seconds to propagate to all regions due to cache invalidation delays. If you need the updated key state, use a subsequent call to keys.getKey."
      },
      "V2KeysUpdateKeyResponseBody": {
        "type": "object",
        "required": [
          "meta"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/KeysUpdateKeyResponseData"
          }
        }
      },
      "V2KeysDeleteKeyRequestBody": {
        "type": "object",
        "required": [
          "keyId"
        ],
        "properties": {
          "keyId": {
            "type": "string",
            "minLength": 3,
            "description": "The unique identifier of the key to delete (starts with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. Once deleted, verification attempts with this key will fail with code=NOT_FOUND and it will no longer appear in key listings.",
            "example": "key_2cGKbMxRyIzhCxo1Idjz8q"
          },
          "permanent": {
            "type": "boolean",
            "default": false,
            "description": "Controls whether the key should be soft-deleted (default) or permanently erased from the database. Soft deletion marks the key as deleted but preserves its data, allowing potential recovery via direct database operations. Permanent deletion completely removes all traces of the key including its hash and metadata. Use permanent=true for regulatory compliance scenarios (like GDPR), resolving hash collisions during migrations, or when you need to reuse the same key string in the future. CAUTION: Permanent deletion cannot be undone.",
            "example": false
          }
        },
        "additionalProperties": false
      },
      "KeysDeleteKeyResponseData": {
        "type": "object",
        "properties": {},
        "description": "Empty response object. A successful response indicates the key was deleted successfully. Deletion triggers cache invalidation across all regions, but it may take up to 30 seconds for the deletion to be fully propagated due to eventual consistency. During this propagation period, some verification attempts might still succeed in certain regions."
      },
      "V2KeysDeleteKeyResponseBody": {
        "type": "object",
        "required": [
          "meta"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/KeysDeleteKeyResponseData"
          }
        }
      },
      "V2KeysGetKeyRequestBody": {
        "type": "object",
        "required": [
          "keyId"
        ],
        "properties": {
          "keyId": {
            "type": "string",
            "minLength": 3,
            "description": "The unique identifier of the key to retrieve (starts with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. You can find this ID in the creation response, key listings, or in the dashboard.",
            "example": "key_2cGKbMxRyIzhCxo1Idjz8q"
          },
          "decrypt": {
            "type": "boolean",
            "default": false,
            "description": "Whether to include the plaintext key in the response. This is only possible for keys created with 'recoverable: true' and requires the 'decrypt_key' permission. SECURITY WARNING: This should be used sparingly and only for legitimate recovery purposes. Keys returned this way must be handled securely and not logged or stored insecurely. Most applications should set this to false."
          }
        },
        "additionalProperties": false
      },
      "KeysGetKeyResponseData": {
        "type": "object",
        "required": [
          "id",
          "start",
          "workspaceId",
          "createdAt",
          "enabled"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier of the key in Unkey's system.",
            "example": "key_2cGKbMxRyIzhCxo1Idjz8q"
          },
          "start": {
            "type": "string",
            "description": "The first few characters of the key to visually identify it without exposing the full key. Used in dashboards and logs to help users recognize which key is being used without revealing sensitive information. Typically includes the prefix if one was specified.",
            "example": "prod_5j1"
          },
          "workspaceId": {
            "type": "string",
            "description": "The ID of the workspace that owns this key.",
            "example": "ws_1234abcd"
          },
          "apiId": {
            "type": "string",
            "description": "The ID of the API this key belongs to.",
            "example": "api_2cGKbMxRjIzhCxo1IdjH3a"
          },
          "name": {
            "type": "string",
            "description": "A descriptive name for the key for internal reference. Shown in dashboards and logs but never exposed to end users.",
            "example": "Payment Service Production Key"
          },
          "externalId": {
            "type": "string",
            "description": "Your user's unique identifier, creating a link between Unkey and your system. This ID is returned during verification so you can identify which customer/entity is making the request without performing additional database lookups. Use consistent identifiers that match your primary user/tenant identifiers for seamless integration.",
            "example": "user_912a841d"
          },
          "meta": {
            "type": "object",
            "additionalProperties": true,
            "description": "Arbitrary JSON metadata associated with this key. This can include additional context like subscription plans, feature flags, or any custom data. Metadata is stored as-is and returned during verification, allowing you to access important information without additional database queries. Consider including data relevant to authorization decisions, usage tracking, and user context.",
            "example": {
              "plan": "enterprise",
              "limits": {
                "storage": "500GB",
                "compute": "1000 minutes/month"
              },
              "contactInfo": {
                "primaryEmail": "admin@example.com",
                "technicalContact": "tech@example.com"
              },
              "integrations": {
                "slack": true,
                "github": {
                  "enabled": true,
                  "repositories": 10
                }
              },
              "lastActivityTimestamp": 1671048264000
            }
          },
          "createdAt": {
            "type": "integer",
            "format": "int64",
            "description": "Unix timestamp (in milliseconds) when the key was created.",
            "example": 1671048264000
          },
          "updatedAt": {
            "type": "integer",
            "format": "int64",
            "description": "Unix timestamp (in milliseconds) when the key was last updated.",
            "example": 1671135600000
          },
          "expires": {
            "type": "integer",
            "format": "int64",
            "description": "Unix timestamp (in milliseconds) when this key will automatically expire. If null, the key has no expiration.",
            "example": 1704067200000
          },
          "credits": {
            "type": "object",
            "properties": {
              "remaining": {
                "type": "integer",
                "format": "int32",
                "description": "The number of times this key can still be used before becoming invalid.",
                "example": 753
              },
              "refill": {
                "type": "object",
                "required": [
                  "interval",
                  "amount"
                ],
                "properties": {
                  "interval": {
                    "type": "string",
                    "enum": [
                      "daily",
                      "monthly"
                    ],
                    "description": "How often the credits are automatically refilled."
                  },
                  "amount": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Number of credits added during each refill."
                  },
                  "refillDay": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 31,
                    "description": "For monthly refills, the day of month when refills occur."
                  },
                  "lastRefillAt": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Unix timestamp (in milliseconds) when credits were last refilled."
                  }
                },
                "description": "Configuration for automatic credit refills."
              }
            },
            "description": "Usage limits configuration for this key. Credits provide a way to limit the number of times a key can be used before becoming invalid. Unlike ratelimits, credits are globally consistent (using database transactions) providing 100% accuracy at the cost of slightly higher latency. Ideal for monetization, usage quotas, or strict limits that must not be exceeded. See the 'refill' field for automatic replenishment options."
          },
          "ratelimits": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "name",
                "limit",
                "duration"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "Identifier for this ratelimit.",
                  "example": "requests"
                },
                "limit": {
                  "type": "integer",
                  "format": "int32",
                  "description": "Maximum number of operations allowed within the time window.",
                  "example": 100
                },
                "duration": {
                  "type": "integer",
                  "format": "int32",
                  "description": "Duration of the ratelimit window in milliseconds.",
                  "example": 60000
                },
                "async": {
                  "type": "boolean",
                  "description": "Whether this ratelimit uses fast (async=true) or consistent (async=false) mode. Fast mode has lower latency but less accuracy.",
                  "default": true
                }
              }
            },
            "description": "Array of ratelimits applied to this key. Multiple named ratelimits can control different aspects of key usage. For example, a 'requests' ratelimit might control overall API calls while a separate 'computations' limit manages access to resource-intensive operations. Ratelimits are optimized for performance and typically add minimal latency to verifications. They can be shared across keys through identities."
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of role names assigned to this key. Roles are collections of permissions.",
            "example": [
              "api_admin",
              "billing_reader"
            ]
          },
          "permissions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of permission names directly assigned to this key.",
            "example": [
              "documents.read",
              "documents.write",
              "settings.view"
            ]
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether the key is currently active. Disabled keys will fail verification with code=DISABLED. Toggling this allows you to temporarily suspend access without deleting the key, which is useful for maintenance, account freezing, or debugging. Can be updated using the updateKey endpoint.",
            "example": true
          },
          "plaintext": {
            "type": "string",
            "description": "The full API key in plaintext. Only included when 'decrypt' is true and the key was created with 'recoverable: true'. SECURITY RISK: This field contains the actual secret key which should never be logged, stored in databases, or exposed in any frontend code. It should only be displayed directly to users through secure channels. Most applications should avoid setting decrypt=true unless absolutely necessary."
          },
          "identity": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "The unique ID of the identity in Unkey's system."
              },
              "externalId": {
                "type": "string",
                "description": "Your identifier for this identity in your system."
              },
              "meta": {
                "type": "object",
                "additionalProperties": true,
                "description": "Additional metadata associated with this identity."
              }
            },
            "required": [
              "id",
              "externalId"
            ],
            "description": "The identity associated with this key, if any. Identities allow resource sharing (like ratelimits) across multiple keys belonging to the same user/entity. This enables scenarios like issuing separate keys for different devices/services while maintaining global usage limits for the user. An identity's externalId typically matches your user ID or tenant ID."
          }
        }
      },
      "V2KeysGetKeyResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/KeysGetKeyResponseData"
          }
        }
      },
      "V2KeysVerifyKeyResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta",
            "description": "Metadata about the API response, including a unique request ID that should be included in any support inquiries related to this verification."
          },
          "data": {
            "$ref": "#/components/schemas/KeysVerifyKeyResponseData",
            "description": "The verification result containing all information about the key's validity, permissions, rate limits, and associated metadata."
          }
        },
        "description": "The standard response format for key verification, containing both request metadata and the verification result. Even when verification fails (invalid key, rate limited, etc.), the response uses this format with a 200 status code - examine data.valid to determine the outcome."
      },
      "V2KeysAddPermissionsRequestBody": {
        "type": "object",
        "required": [
          "keyId",
          "permissions"
        ],
        "properties": {
          "keyId": {
            "type": "string",
            "description": "The ID of the key to which permissions will be added (begins with 'key_')",
            "example": "key_2cGKbMxRyIzhCxo1Idjz8q",
            "minLength": 3
          },
          "permissions": {
            "type": "array",
            "minItems": 1,
            "description": "List of permissions to add to the key. Each permission can be identified by ID or name (if both are provided in the same object, ID takes precedence).\n\nBest practices:\n- Use consistent naming patterns (e.g., 'resource.action' or 'resource.subresouce.action')\n- Group related permissions (e.g., 'documents.read', 'documents.write', 'documents.delete')\n- Use hierarchical naming for verification flexibility\n- Consider creating a permission naming guide for your team\n\nDuplicate permissions are automatically handled (adding the same permission twice has no effect). During verification, hierarchical patterns are matched - a key with 'billing.*' permission will have access to 'billing.invoices.view'.",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "description": "The ID of an existing permission (begins with 'perm_'). Provide either ID or name. Use ID when you know the exact permission identifier and want to ensure you're referencing a specific permission.",
                  "example": "perm_1n9McEIBSqy44Qy7hzWyM5",
                  "minLength": 3
                },
                "name": {
                  "type": "string",
                  "description": "The name of the permission. Provide either ID or name. Permission names typically follow a 'resource.action' format (e.g., 'documents.read', 'users.delete'). Use consistent naming patterns to create logical permission hierarchies.",
                  "example": "documents.write",
                  "minLength": 1
                },
                "create": {
                  "type": "boolean",
                  "description": "When true, if a permission with this name doesn't exist, it will be automatically created on-the-fly. Only works when specifying name, not ID.\n\nSECURITY CONSIDERATIONS:\n- Requires the 'rbac.*.create_permission' permission on your root key\n- Use carefully to avoid permission proliferation\n- Consider centralizing permission creation in a controlled process\n- Typos with create=true can lead to unintended permissions\n- Created permissions are permanent and visible to all API keys in the workspace",
                  "default": false
                }
              },
              "additionalProperties": false
            }
          }
        },
        "additionalProperties": false
      },
      "V2KeysAddPermissionsResponseData": {
        "type": "array",
        "description": "Complete list of all permissions directly assigned to the key (including both newly added permissions and those that were already assigned).\n\nThis response includes:\n- All direct permissions assigned to the key (both pre-existing and newly added)\n- Permissions sorted alphabetically by name for consistent response format\n- Both the permission ID and name for each permission\n\nImportant notes:\n- This list does NOT include permissions granted through roles\n- For a complete permission picture, use /v2/keys.getKey instead\n- An empty array indicates the key has no direct permissions assigned\n- Only includes direct permissions from the same workspace as the key",
        "items": {
          "type": "object",
          "required": [
            "id",
            "name"
          ],
          "properties": {
            "id": {
              "type": "string",
              "description": "The unique identifier of the permission (begins with 'perm_'). This ID can be used in other API calls to reference this specific permission. IDs are guaranteed unique and won't change, making them ideal for scripting and automation. You can store these IDs in your system for consistent reference.",
              "example": "perm_1n9McEIBSqy44Qy7hzWyM5"
            },
            "name": {
              "type": "string",
              "description": "The name of the permission, typically following a 'resource.action' pattern like 'documents.read'. Names are human-readable identifiers used both for assignment and verification.\n\nDuring verification:\n- The exact name is matched (e.g., 'documents.read')\n- Hierarchical wildcards are supported in verification requests\n- A key with permission 'documents.*' grants access to 'documents.read', 'documents.write', etc.\n- Wildcards can appear at any level: 'billing.*.view' matches 'billing.invoices.view' and 'billing.payments.view'\n\nHowever, when adding permissions, you must specify each exact permission - wildcards are not valid for assignment.",
              "example": "documents.write"
            }
          }
        }
      },
      "V2KeysAddPermissionsResponse": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/V2KeysAddPermissionsResponseData"
          }
        }
      },
      "V2KeysRemovePermissionsRequestBody": {
        "type": "object",
        "required": [
          "keyId",
          "permissions"
        ],
        "properties": {
          "keyId": {
            "type": "string",
            "description": "The unique identifier of the key from which permissions will be removed (begins with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. Every operation requires this identifier to specify which key to modify.",
            "example": "key_2cGKbMxRyIzhCxo1Idjz8q",
            "minLength": 3
          },
          "permissions": {
            "type": "array",
            "minItems": 1,
            "description": "List of permissions to remove from the key. Each permission can be identified by ID or name (if both are provided in the same object, ID takes precedence).\n\nImportant details:\n- This operation only affects direct permissions on the key, not permissions granted through roles\n- Removing permissions that aren't assigned to the key is a no-op and doesn't cause an error\n- Removing all permissions doesn't disable the key - it just removes its direct permissions\n- The operation is idempotent - multiple identical requests have the same effect as a single request\n- After removal, any verification checks for these permissions will fail unless granted via roles\n- Each permission must include either id or name - you can't use wildcards for removal",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "description": "The ID of the permission to remove (begins with 'perm_'). Provide either ID or name, not both. Using ID guarantees you're removing the exact permission intended, even if multiple permissions have similar names. The ID is especially useful in automation scripts where precision is important.",
                  "example": "perm_1n9McEIBSqy44Qy7hzWyM5",
                  "minLength": 3
                },
                "name": {
                  "type": "string",
                  "description": "The name of the permission to remove. Provide either ID or name, not both. When using names, the string must match exactly as it was defined - including case sensitivity and full hierarchical path (e.g., 'documents.write', not just 'write'). Name lookup happens within the same workspace as the key.",
                  "example": "documents.write",
                  "minLength": 1
                }
              },
              "additionalProperties": false
            }
          }
        },
        "additionalProperties": false
      },
      "V2KeysRemovePermissionsResponseData": {
        "type": "object",
        "description": "Empty response object by design. A successful response indicates the permissions were successfully removed from the key. Unlike the addPermissions endpoint which returns the current permissions, this endpoint returns an empty object to reduce response size.\n\nImportant post-operation effects:\n- Any cached versions of the key are immediately invalidated to ensure consistency\n- Changes to permissions take effect within seconds for new verifications\n- Existing verification sessions might retain permissions until their cache expires (usually <30 seconds)\n- To get the updated list of permissions, use the keys.getKey endpoint\n- All permission removals are logged to the audit log for security tracking",
        "additionalProperties": false
      },
      "V2KeysRemovePermissionsResponse": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/V2KeysRemovePermissionsResponseData"
          }
        }
      },
      "V2KeysSetPermissionsRequestBody": {
        "type": "object",
        "required": [
          "keyId",
          "permissions"
        ],
        "properties": {
          "keyId": {
            "type": "string",
            "description": "The unique identifier of the key to set permissions on (begins with 'key_'). This ID comes from the createKey response and identifies which key will have its permissions replaced. This is the database ID, not the actual API key string that users authenticate with.",
            "example": "key_2cGKbMxRyIzhCxo1Idjz8q",
            "minLength": 3
          },
          "permissions": {
            "type": "array",
            "description": "The permissions to set for this key. This is a complete replacement operation - it overwrites all existing direct permissions with this new set.\n\nKey behaviors:\n- Providing an empty array removes all direct permissions from the key\n- This only affects direct permissions - permissions granted through roles are not affected\n- All existing direct permissions not included in this list will be removed\n- The complete list approach allows synchronizing permissions with external systems\n- Permission changes take effect immediately for new verifications\n\nUnlike addPermissions (which only adds) or removePermissions (which only removes), this endpoint performs a wholesale replacement of the permission set.",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "description": "The ID of an existing permission (begins with 'perm_'). Provide either ID or name for each permission, not both. Using ID is more precise and guarantees you're referencing the exact permission intended, regardless of name changes or duplicates. IDs are particularly useful in automation scripts and when migrating permissions between environments.",
                  "example": "perm_1n9McEIBSqy44Qy7hzWyM5",
                  "minLength": 3
                },
                "name": {
                  "type": "string",
                  "description": "The name of the permission. Provide either ID or name for each permission, not both. Names must match exactly as defined in your permission system - including case sensitivity and the complete hierarchical path. Names are generally more human-readable but can be ambiguous if not carefully managed across your workspace.",
                  "example": "documents.write",
                  "minLength": 1
                },
                "create": {
                  "type": "boolean",
                  "description": "When true, if a permission with this name doesn't exist, it will be automatically created on-the-fly. Only works when specifying name, not ID.\n\nSECURITY CONSIDERATIONS:\n- Requires the 'rbac.*.create_permission' permission on your root key\n- Created permissions are permanent and visible throughout your workspace\n- Use carefully to avoid permission proliferation and inconsistency\n- Consider using a controlled process for permission creation instead\n- Typos with create=true will create unintended permissions that persist in your system",
                  "default": false
                }
              },
              "additionalProperties": false
            }
          }
        },
        "additionalProperties": false
      },
      "V2KeysSetPermissionsResponseData": {
        "type": "array",
        "description": "Complete list of all permissions now directly assigned to the key after the set operation has completed.\n\nThe response includes:\n- The comprehensive, updated set of direct permissions (reflecting the complete replacement)\n- Both ID and name for each permission for easy reference\n- Permissions sorted alphabetically by name for consistent response format\n\nImportant notes:\n- This only shows direct permissions, not those granted through roles\n- An empty array means the key has no direct permissions assigned\n- For a complete permission picture including roles, use keys.getKey instead\n- All permission changes are logged in the audit log for security tracking",
        "items": {
          "type": "object",
          "required": [
            "id",
            "name"
          ],
          "properties": {
            "id": {
              "type": "string",
              "description": "The unique identifier of the permission",
              "example": "perm_1n9McEIBSqy44Qy7hzWyM5"
            },
            "name": {
              "type": "string",
              "description": "The name of the permission",
              "example": "documents.write"
            }
          }
        }
      },
      "V2KeysSetPermissionsResponse": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/V2KeysSetPermissionsResponseData"
          }
        }
      },
      "V2KeysAddRolesRequestBody": {
        "type": "object",
        "required": [
          "keyId",
          "roles"
        ],
        "properties": {
          "keyId": {
            "type": "string",
            "description": "The ID of the key to which roles will be added (begins with 'key_'). This is the database reference ID for the key, not the actual API key string. This ID uniquely identifies which key will receive the additional roles.",
            "example": "key_2cGKbMxRyIzhCxo1Idjz8q",
            "minLength": 3
          },
          "roles": {
            "type": "array",
            "minItems": 1,
            "description": "List of roles to add to the key. Each role can be identified by ID or name (if both are provided in the same object, ID takes precedence).\n\nKey behaviors:\n- Duplicate roles are automatically handled (adding the same role twice has no effect)\n- The operation is idempotent - running it multiple times produces the same result\n- Roles must already exist - unlike permissions, roles cannot be created on-the-fly\n- All roles must belong to the same workspace as the key\n- Invalid roles will cause the entire operation to fail (atomic transaction)\n\nRoles are collections of permissions that provide a convenient way to assign multiple permissions at once. When a key is verified, all permissions granted through all assigned roles are checked, alongside any direct permissions on the key.",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "description": "The ID of an existing role (begins with 'role_'). Provide either ID or name, not both. Using the ID guarantees you're referencing the exact role intended, regardless of name changes. This is particularly valuable for scripting, automation, and ensuring consistency between environments where role names might differ but IDs are stable references.",
                  "example": "role_1n9McEIBSqy44Qy7hzWyM5",
                  "minLength": 3
                },
                "name": {
                  "type": "string",
                  "description": "The name of the role. Provide either ID or name, not both. Role names must be unique within a workspace, making them generally safe to use as references. Names are more human-readable and easier to work with in configurations and documentation. However, if roles are renamed, any integration using name references will need to be updated.",
                  "example": "admin",
                  "minLength": 1
                }
              },
              "additionalProperties": false
            }
          }
        },
        "additionalProperties": false
      },
      "V2KeysAddRolesResponseData": {
        "type": "array",
        "description": "Complete list of all roles directly assigned to the key after the operation completes.\n\nThe response includes:\n- All roles now assigned to the key (both pre-existing and newly added)\n- Both ID and name of each role for easy reference\n- Roles sorted alphabetically by name for consistent response format\n\nImportant notes:\n- The response shows the complete current state after the addition\n- An empty array means the key has no roles assigned (unlikely after an add operation)\n- This only shows direct role assignments, not inherited or nested roles\n- Role permissions are not expanded in this response - use keys.getKey for full details\n- All role changes are logged in the audit log for security tracking",
        "items": {
          "type": "object",
          "required": [
            "id",
            "name"
          ],
          "properties": {
            "id": {
              "type": "string",
              "description": "The unique identifier of the role (begins with 'role_'). This ID can be used in other API calls to reference this specific role. Role IDs are immutable and guaranteed to be unique within your Unkey workspace, making them reliable reference points for integration and automation systems.",
              "example": "role_1n9McEIBSqy44Qy7hzWyM5"
            },
            "name": {
              "type": "string",
              "description": "The name of the role. This is a human-readable identifier that's unique within your workspace. Role names help identify what access level or function a role provides. Common patterns include naming by access level ('admin', 'editor', 'viewer'), by department ('billing_manager', 'support_agent'), or by feature area ('analytics_user', 'dashboard_admin').",
              "example": "admin"
            }
          }
        }
      },
      "V2KeysAddRolesResponse": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/V2KeysAddRolesResponseData"
          }
        }
      },
      "V2KeysRemoveRolesRequestBody": {
        "type": "object",
        "required": [
          "keyId",
          "roles"
        ],
        "properties": {
          "keyId": {
            "type": "string",
            "description": "The ID of the key from which roles will be removed (begins with 'key_'). This is the database reference for the key, not the actual API key string that users authenticate with. Every operation requires this identifier to specify which key to modify.",
            "example": "key_2cGKbMxRyIzhCxo1Idjz8q",
            "minLength": 3
          },
          "roles": {
            "type": "array",
            "minItems": 1,
            "description": "List of roles to remove from the key. Each role can be identified by ID or name (if both are provided in the same object, ID takes precedence).\n\nKey behaviors:\n- Only affects direct role assignments on the key\n- Removing roles that aren't assigned to the key has no effect (silent no-op)\n- The operation is idempotent - multiple identical requests have the same effect\n- Invalid role references will cause the entire operation to fail (atomic transaction)\n- After removal, the key will lose access to any permissions that were only granted through these roles\n- Inherited roles or permissions from other sources are not affected\n\nThis operation is commonly used when downgrading access levels, removing temporary elevated privileges, or fine-tuning access control for API keys.",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "description": "The ID of an existing role (begins with 'role_'). Provide either ID or name, not both. Using the role ID ensures you're removing exactly the intended role, even if multiple roles have similar or identical names. IDs are especially useful in automation scripts and cross-environment scenarios where consistent references are important.",
                  "example": "role_1n9McEIBSqy44Qy7hzWyM5",
                  "minLength": 3
                },
                "name": {
                  "type": "string",
                  "description": "The name of the role. Provide either ID or name, not both. Role names must exactly match the role's current name in your workspace, including case sensitivity. Names are more human-readable and easier to work with in configurations, but if roles are renamed, any systems using name references will need to be updated.",
                  "example": "admin",
                  "minLength": 1
                }
              },
              "additionalProperties": false
            }
          }
        },
        "additionalProperties": false
      },
      "V2KeysRemoveRolesResponseData": {
        "type": "array",
        "description": "Complete list of all roles directly assigned to the key after the removal operation completes.\n\nThe response includes:\n- The remaining roles still assigned to the key (after removing the specified roles)\n- Both ID and name for each role for easy reference\n- Roles sorted alphabetically by name for consistent response format\n\nImportant notes:\n- The response reflects the current state after the removal operation\n- An empty array indicates the key now has no roles assigned\n- This only shows direct role assignments\n- Role permissions are not expanded in this response - use keys.getKey for full details\n- All role changes are logged in the audit log for security tracking\n- Changes take effect immediately for new verifications but cached sessions may retain old permissions briefly",
        "items": {
          "type": "object",
          "required": [
            "id",
            "name"
          ],
          "properties": {
            "id": {
              "type": "string",
              "description": "The unique identifier of the role (begins with 'role_'). This ID can be used in other API calls to reference this specific role.",
              "example": "role_1n9McEIBSqy44Qy7hzWyM5"
            },
            "name": {
              "type": "string",
              "description": "The name of the role. This is a human-readable identifier that's unique within your workspace.",
              "example": "admin"
            }
          }
        }
      },
      "V2KeysRemoveRolesResponse": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/V2KeysRemoveRolesResponseData"
          }
        }
      },
      "V2KeysSetRolesRequestBody": {
        "type": "object",
        "required": [
          "keyId",
          "roles"
        ],
        "properties": {
          "keyId": {
            "type": "string",
            "description": "The ID of the key for which to set roles (begins with 'key_'). This is the database reference ID for the key, not the actual API key string. This operation will replace all existing direct role assignments for this key.",
            "example": "key_2cGKbMxRyIzhCxo1Idjz8q",
            "minLength": 3
          },
          "roles": {
            "type": "array",
            "description": "Complete list of roles to assign to the key. This is a wholesale replacement operation - it replaces all existing direct role assignments with this new set.\n\nKey behaviors:\n- This operation is a complete replacement, not an incremental update\n- Any existing roles not included in this request will be removed\n- Providing an empty array removes all direct role assignments from the key\n- Roles must already exist - they cannot be created on-the-fly like permissions\n- All roles must belong to the same workspace as the key\n- Invalid role references will cause the entire operation to fail (atomic transaction)\n- Changes take effect immediately for new verifications\n\nThis approach allows you to precisely control the full role set in a single operation, making it ideal for synchronizing roles with external systems or implementing controlled role templates.",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "description": "The ID of an existing role (begins with 'role_'). Provide either ID or name, not both. Using role IDs guarantees you're referencing the exact roles intended, regardless of name changes or duplications. This approach is particularly valuable in automation scripts, cross-environment deployments, and systems where role names might change but IDs remain stable.",
                  "example": "role_1n9McEIBSqy44Qy7hzWyM5",
                  "minLength": 3
                },
                "name": {
                  "type": "string",
                  "description": "The name of the role. Provide either ID or name, not both. Role names must be unique within a workspace, making them generally safe to use as references. Names are more human-readable and easier to work with in configurations, especially when implementing standardized role templates across many keys. However, if roles are renamed, any integrations using name references will need updates.",
                  "example": "admin",
                  "minLength": 1
                }
              },
              "additionalProperties": false
            }
          }
        },
        "additionalProperties": false
      },
      "V2KeysSetRolesResponseData": {
        "type": "array",
        "description": "Complete list of all roles now directly assigned to the key after the set operation has completed.\n\nThe response includes:\n- The comprehensive, updated set of roles (reflecting the complete replacement)\n- Both ID and name for each role for easy reference\n- Roles sorted alphabetically by name for consistent response format\n\nImportant notes:\n- This response shows the final state after the complete replacement\n- If you provided an empty array in the request, this will also be empty\n- This only shows direct role assignments on the key\n- Role permissions are not expanded in this response - use keys.getKey for complete details\n- All role changes are logged in the audit log for security tracking\n- An empty array indicates the key now has no roles assigned at all",
        "items": {
          "type": "object",
          "required": [
            "id",
            "name"
          ],
          "properties": {
            "id": {
              "type": "string",
              "description": "The unique identifier of the role (begins with 'role_'). This ID can be used in other API calls to reference this specific role. Role IDs are immutable and guaranteed to be unique, making them reliable reference points for integration and automation systems.",
              "example": "role_1n9McEIBSqy44Qy7hzWyM5"
            },
            "name": {
              "type": "string",
              "description": "The name of the role. This is a human-readable identifier that's unique within your workspace. Role names are descriptive labels that help identify what access level or function a role provides. Good naming practices include naming by access level ('admin', 'editor'), by department ('billing_team', 'support_staff'), or by feature area ('reporting_user', 'settings_manager').",
              "example": "admin"
            }
          }
        }
      },
      "V2KeysSetRolesResponse": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/V2KeysSetRolesResponseData"
          }
        }
      },
      "V2KeysUpdateRemainingRequestBody": {
        "type": "object",
        "required": [
          "keyId",
          "remaining"
        ],
        "properties": {
          "keyId": {
            "type": "string",
            "description": "The ID of the key to update (begins with 'key_'). This is the database reference ID for the key, not the actual API key string that users authenticate with. This ID uniquely identifies which key's credits will be updated.",
            "example": "key_2cGKbMxRyIzhCxo1Idjz8q",
            "minLength": 3
          },
          "remaining": {
            "type": "integer",
            "format": "int64",
            "description": "The new value for the remaining credits. This is an absolute value replacement, not an increment or decrement operation.\n\nKey behaviors:\n- This completely replaces the current remaining credits value\n- To add credits, first get the current value and then set remaining = current + additional\n- To make a key unlimited, set remaining = -1\n- To make a key with unlimited usage have a specific limit, set remaining to a positive number\n- Credits are decremented each time the key is successfully verified (by the cost value, default 1)\n- When credits reach zero, verification fails with code=USAGE_EXCEEDED\n\nThis field is useful for implementing usage-based pricing, subscription tiers, trial periods, or consumption quotas.",
            "example": 1000
          },
          "overwriteRefillSettings": {
            "type": "boolean",
            "description": "When true, any existing automatic refill settings will be removed from the key.\n\nUse cases:\n- Convert a key with automatic periodic refills to a one-time credit allocation\n- Remove subscription-like behavior in favor of manually controlled credits\n- Downgrade from an automatic plan to a fixed allocation\n- Simplify credit management by removing automated refills\n\nWhen false or omitted, existing refill settings are preserved, and only the current remaining value is updated. This lets you adjust the current balance without changing the refill schedule.",
            "default": false
          }
        },
        "additionalProperties": false
      },
      "KeysUpdateRemainingResponseData": {
        "type": "object",
        "required": [
          "remaining"
        ],
        "properties": {
          "remaining": {
            "type": "integer",
            "format": "int64",
            "description": "The updated remaining credits value for the key after the operation completes. This reflects the exact value that was set in the request. A value of -1 indicates unlimited usage, meaning the key can be used an unlimited number of times without being rejected for credit exhaustion. This field is guaranteed to be present in every response.",
            "example": 1000
          },
          "refillSettings": {
            "type": "object",
            "nullable": true,
            "properties": {
              "interval": {
                "type": "string",
                "enum": [
                  "daily",
                  "weekly",
                  "monthly",
                  "never"
                ],
                "description": "The interval at which credits are automatically refilled. 'daily' resets at midnight UTC, 'weekly' resets on the specified weekday (where 1=Monday, 7=Sunday), 'monthly' resets on the specified day of month, and 'never' means no automatic refills occur."
              },
              "amount": {
                "type": "integer",
                "format": "int64",
                "minimum": 1,
                "description": "The number of credits added during each automatic refill. This is the quota that gets renewed each period, making it useful for implementing subscription tiers with different usage limits (e.g., Basic=100/month, Pro=1000/month)."
              },
              "refillDay": {
                "type": "integer",
                "minimum": 1,
                "maximum": 31,
                "description": "For monthly refills, the day of the month on which to refill (1-31). For weekly refills, the day of the week (1=Monday, 7=Sunday). This allows aligning refills with billing cycles, subscription periods, or other business-relevant schedules."
              },
              "lastRefillAt": {
                "type": "string",
                "format": "date-time",
                "description": "The timestamp when the last automatic refill occurred. This helps track when credits were last replenished and understand when the next refill will occur. The timestamp is in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ)."
              }
            },
            "description": "If the key has automatic refill settings, they are included here with their current configuration. If null, the key does not have automatic refills configured (either because they were removed with overwriteRefillSettings=true or because they were never set up). Refill settings create subscription-like behavior where the key automatically receives new credits on a regular schedule."
          }
        }
      },
      "V2KeysUpdateRemainingResponse": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/KeysUpdateRemainingResponseData"
          }
        }
      },
      "V2KeysCreateKeyRequestBody": {
        "type": "object",
        "required": [
          "apiId"
        ],
        "properties": {
          "apiId": {
            "type": "string",
            "minLength": 3,
            "maxLength": 255,
            "description": "The API ID where this key should be created. Keys are isolated by API, preventing keys from one environment (e.g., development) being used in another (e.g., production). We recommend creating separate APIs for different environments and services.",
            "example": "api_2cGKbMxRjIzhCxo1IdjH3a"
          },
          "prefix": {
            "type": "string",
            "maxLength": 16,
            "description": "Optional prefix for the key that helps visually identify its purpose. The prefix becomes part of the key (e.g., 'prod_xxxxxxxxx') and appears in logs and dashboards. Use prefixes like 'prod', 'dev', 'test', or application names to help users understand what the key is for. Only alphanumeric characters, underscores, and hyphens are allowed.",
            "example": "prod"
          },
          "name": {
            "type": "string",
            "description": "Human-readable name for the key shown in dashboards, logs, and API responses. This helps identify the key's purpose or owner but is never exposed to end users. Good names include the user's name, the specific service, or the access level (e.g., 'Alice's Production Key', 'Payment Service Key', 'Admin Access').",
            "example": "Payment Service Production Key"
          },
          "byteLength": {
            "type": "integer",
            "minimum": 16,
            "maximum": 255,
            "default": 16,
            "description": "Controls the cryptographic strength of the generated key. Higher values increase security but result in longer keys. The default (16 bytes) provides 2^128 possible combinations, which is secure for most applications. For highly sensitive APIs, consider using 24 or 32 bytes.",
            "example": 24
          },
          "externalId": {
            "type": "string",
            "description": "Your system's unique identifier for the user or entity this key belongs to. This ID is returned during verification, allowing you to identify the key owner without additional database lookups. Typically, this should be your user ID, organization ID, or tenant ID - whatever you use to identify entities in your system.",
            "example": "user_912a841d"
          },
          "meta": {
            "type": "object",
            "additionalProperties": true,
            "description": "Arbitrary JSON metadata stored with the key and returned during verification. This is ideal for contextual information needed during API requests like subscription plans, feature flags, or user properties. Storing this data with the key eliminates the need for additional database lookups during verification, improving performance for stateless services.",
            "example": {
              "plan": "enterprise",
              "featureFlags": {
                "betaAccess": true,
                "concurrentConnections": 10
              },
              "customerName": "Acme Corp"
            }
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 512
            },
            "description": "Roles to assign to this key for permission management. Each role represents a collection of permissions that define what actions the key can perform. Roles must already exist in your workspace. During verification, all permissions from these roles are checked against requested permissions. Common role names include 'admin', 'editor', 'viewer', etc.",
            "example": [
              "api_admin",
              "billing_reader"
            ]
          },
          "permissions": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 512
            },
            "description": "Individual permissions to assign directly to this key. Permissions define specific actions the key can perform when verified with the permissions check. Use a hierarchical naming pattern like 'resource.action' (e.g., 'documents.read', 'users.delete') to create logical groupings. During verification, a key with permission 'documents.*' will have access to both 'documents.read' and 'documents.write'.",
            "example": [
              "documents.read",
              "documents.write",
              "settings.view"
            ]
          },
          "expires": {
            "type": "integer",
            "format": "int64",
            "description": "Unix timestamp (milliseconds) when this key should automatically expire. After this time, verification will fail with code=EXPIRED. Use temporary keys for time-limited access, trial periods, emergency access, or one-time operations. Omit this field for keys that should never expire.",
            "example": 1704067200000
          },
          "credits": {
            "type": "object",
            "required": [
              "remaining"
            ],
            "properties": {
              "remaining": {
                "type": "integer",
                "format": "int32",
                "description": "The initial number of credits (or requests) this key can use before becoming invalid. Each verification decrements this counter by the specified cost (default 1). When it reaches zero, verification fails with code=USAGE_EXCEEDED. This provides global consistency for usage limits, making it ideal for paid APIs with strict quotas.",
                "example": 1000
              },
              "refill": {
                "type": "object",
                "properties": {
                  "interval": {
                    "type": "string",
                    "enum": [
                      "daily",
                      "monthly"
                    ],
                    "description": "How frequently credits should be automatically refilled. With 'daily', credits reset at midnight UTC. With 'monthly', credits reset on the specified refillDay (or the 1st if not specified)."
                  },
                  "amount": {
                    "type": "integer",
                    "minimum": 1,
                    "description": "Number of credits to add during each automatic refill. This should typically match the 'remaining' value to provide consistent quota periods."
                  },
                  "refillDay": {
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 31,
                    "description": "For monthly refills, the day of month when credits are replenished. If the month doesn't have this day (e.g., refillDay=31 in February), the refill occurs on the last day of the month."
                  }
                },
                "required": [
                  "interval",
                  "amount"
                ],
                "description": "Configuration for automatic credit refills. This creates a subscription-like recurring quota that resets on a schedule. To implement monthly plans with usage quotas, set interval='monthly' with the appropriate amount and refillDay."
              }
            },
            "description": "Usage limits configuration for this key. Credits provide a way to limit how many times a key can be used, with optional automatic refills. Unlike rate limits (which control frequency), credits control total usage and are globally consistent. This makes them ideal for implementing usage-based pricing, subscription tiers, or hard usage caps."
          },
          "ratelimits": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "name",
                "limit",
                "duration"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "minLength": 1,
                  "description": "Identifier for this rate limit. Multiple named rate limits can control different aspects of API usage. Use descriptive names that reflect what's being limited, like 'requests', 'compute_operations', or 'database_writes'.",
                  "example": "requests"
                },
                "limit": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 1,
                  "description": "Maximum number of operations allowed within the time window. When this limit is reached, verification fails with code=RATE_LIMITED until the window resets.",
                  "example": 100
                },
                "duration": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 1000,
                  "description": "Duration of the rate limit window in milliseconds. Common durations include 60000 (1 minute), 3600000 (1 hour), or 86400000 (1 day). The rate limit resets after this period has elapsed.",
                  "example": 60000
                }
              }
            },
            "description": "Array of rate limits to apply to this key. Rate limits protect against abuse by controlling how frequently operations can be performed. Unlike credits (which limit total usage), rate limits are time-based and automatically reset. They're optimized for performance and typically add minimal latency to verifications.",
            "example": [
              {
                "name": "requests",
                "limit": 100,
                "duration": 60000
              },
              {
                "name": "heavy_operations",
                "limit": 10,
                "duration": 3600000
              }
            ]
          },
          "enabled": {
            "type": "boolean",
            "default": true,
            "description": "Controls whether the key is active upon creation. If false, verification will immediately fail with code=DISABLED. This is useful for preparing keys in advance that will be activated later, or for implementing approval workflows where keys are created disabled until reviewed.",
            "example": true
          },
          "recoverable": {
            "type": "boolean",
            "default": false,
            "description": "If true, the plaintext key is stored in an encrypted vault, allowing it to be retrieved later using keys.getKey with decrypt=true. SECURITY WARNING: This reduces security by storing the key in recoverable format. Use only for development keys, emergency backup, or when absolutely necessary. In production, set this to false (default) for maximum security.",
            "example": false
          }
        },
        "additionalProperties": false
      },
      "KeysCreateKeyResponseData": {
        "type": "object",
        "properties": {
          "keyId": {
            "type": "string",
            "description": "The unique identifier for this key in Unkey's system. This is NOT the actual API key, but a reference ID used for management operations like updating or deleting the key. Store this ID in your database to reference the key later. This ID is not sensitive and can be logged or displayed in dashboards.",
            "example": "key_2cGKbMxRyIzhCxo1Idjz8q"
          },
          "key": {
            "type": "string",
            "description": "The full generated API key that should be securely provided to your user. SECURITY WARNING: This is the only time you'll receive the complete key - Unkey only stores a securely hashed version. Never log or store this value in your own systems; provide it directly to your end user via secure channels. After this API call completes, this value cannot be retrieved again (unless created with recoverable=true).",
            "example": "prod_2cGKbMxRjIzhCxo1IdjH3arELti7Sdyc8w6XYbvtcyuBowPT"
          }
        },
        "required": [
          "keyId",
          "key"
        ]
      },
      "V2KeysCreateKeyResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/KeysCreateKeyResponseData"
          }
        }
      },
      "Meta": {
        "type": "object",
        "required": [
          "requestId"
        ],
        "properties": {
          "requestId": {
            "description": "A unique id for this request. Always include this ID when contacting support about a specific API request. This identifier allows Unkey's support team to trace the exact request through logs and diagnostic systems to provide faster assistance.",
            "example": "req_123",
            "type": "string"
          }
        },
        "additionalProperties": false,
        "description": "Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team."
      },
      "Pagination": {
        "type": "object",
        "properties": {
          "cursor": {
            "description": "Opaque token for retrieving the next set of results",
            "example": "cursor_xyz123",
            "type": "string"
          },
          "hasMore": {
            "description": "Indicates if more results exist beyond this page",
            "example": true,
            "type": "boolean"
          }
        },
        "additionalProperties": false
      },
      "BaseError": {
        "properties": {
          "detail": {
            "description": "A human-readable explanation specific to this occurrence of the problem. This provides detailed information about what went wrong and potential remediation steps. The message is intended to be helpful for developers troubleshooting the issue.",
            "example": "Property foo is required but is missing.",
            "type": "string"
          },
          "instance": {
            "description": "A URI reference that identifies the specific occurrence of the problem. This can be used to look up additional information about this specific error instance in logs or error tracking systems, and is particularly useful when reporting issues to support.",
            "example": "https://example.com/error-log/abc123",
            "format": "uri",
            "type": "string"
          },
          "status": {
            "description": "HTTP status code that corresponds to this error. This will match the status code in the HTTP response. Common codes include 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 409 (Conflict), and 500 (Internal Server Error).",
            "example": 404,
            "format": "int",
            "type": "integer"
          },
          "title": {
            "description": "A short, human-readable summary of the problem type. This is a concise, fixed string that categorizes the error and remains consistent between occurrences of the same error type. It provides a quick way to identify the category of error.",
            "type": "string",
            "example": "Not Found"
          },
          "type": {
            "description": "A URI reference to human-readable documentation for the error. This link points to detailed documentation about this specific error type, including possible causes and solutions. It's designed to help developers understand and resolve the issue.",
            "example": "https://unkey.dev/errors/not-found",
            "format": "uri",
            "type": "string"
          }
        },
        "type": "object",
        "required": [
          "detail",
          "status",
          "title",
          "type"
        ],
        "description": "Standard error structure that provides detailed information about errors encountered during API operations. This follows a problem details format that includes both machine-readable error codes and human-readable explanations. All error responses in the API include this structure to provide consistent, actionable error information."
      },
      "ValidationError": {
        "additionalProperties": false,
        "properties": {
          "location": {
            "description": "JSON path indicating exactly where in the request the error occurred. This helps pinpoint the problematic field or parameter. Examples include:\n- 'body.name' (field in request body)\n- 'body.items[3].tags' (nested array element)\n- 'path.apiId' (path parameter)\n- 'query.limit' (query parameter)\n\nUse this location to identify exactly which part of your request needs correction.",
            "type": "string",
            "example": "body.permissions[0].name"
          },
          "message": {
            "description": "Detailed error message explaining what validation rule was violated. This provides specific information about why the field or parameter was rejected, such as format errors, invalid values, or constraint violations.",
            "type": "string",
            "example": "Must be at least 3 characters long"
          },
          "fix": {
            "description": "A human-readable suggestion describing how to fix the error. This provides practical guidance on what changes would satisfy the validation requirements. Not all validation errors include fix suggestions, but when present, they offer specific remediation advice.",
            "type": "string",
            "example": "Ensure the name uses only alphanumeric characters, underscores, and hyphens"
          }
        },
        "type": "object",
        "required": [
          "message",
          "location"
        ],
        "description": "Detailed information about a specific validation error in a request. Each validation error pinpoints exactly what part of the request failed validation, why it failed, and how to fix it. Multiple validation errors may be returned in a single response when there are issues with multiple fields or parameters."
      },
      "BadRequestErrorDetails": {
        "allOf": [
          {
            "$ref": "#/components/schemas/BaseError"
          },
          {
            "type": "object",
            "properties": {
              "errors": {
                "description": "List of individual validation errors that occurred in the request. Each error provides specific details about what failed validation, where the error occurred in the request, and suggestions for fixing it. This granular information helps developers quickly identify and resolve multiple issues in a single request without having to make repeated API calls.",
                "items": {
                  "$ref": "#/components/schemas/ValidationError"
                },
                "type": "array"
              }
            },
            "required": [
              "errors"
            ]
          }
        ],
        "description": "Extended error details specifically for bad request (400) errors. This builds on the BaseError structure by adding an array of individual validation errors that provide specific information about each validation failure in the request. This is particularly useful for requests with multiple fields that might have different validation issues simultaneously."
      },
      "NotFoundErrorResponse": {
        "type": "object",
        "required": [
          "meta",
          "error"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "error": {
            "$ref": "#/components/schemas/BaseError"
          }
        },
        "description": "Error response when the requested resource cannot be found. This typically indicates that the resource either doesn't exist, has been deleted, or the caller doesn't have permission to see it. Common scenarios include looking up non-existent keys, APIs, permissions, or identities. When receiving this error, verify that the resource identifier is correct and that the resource hasn't been deleted."
      },
      "ConflictErrorResponse": {
        "type": "object",
        "required": [
          "meta",
          "error"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "error": {
            "$ref": "#/components/schemas/BaseError"
          }
        },
        "description": "Error response for conflicts with the current state of a resource. This typically occurs when trying to create a resource that already exists (like an identity with a duplicate externalId) or when performing an operation that conflicts with the resource's current state. When receiving this error, the request should be modified to resolve the conflict before retrying, or a different operation should be used instead."
      },
      "UnauthorizedErrorResponse": {
        "type": "object",
        "required": [
          "meta",
          "error"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "error": {
            "$ref": "#/components/schemas/BaseError"
          }
        },
        "description": "Error response when authentication has failed or credentials are missing. This occurs when:\n\n- The Authorization header is missing\n- The root key is invalid or has been revoked\n- The root key format is incorrect\n- The authentication token has expired\n\nTo fix this error:\n1. Ensure you're including the Authorization header with format: 'Bearer your_root_key'\n2. Verify your root key is valid and has not been revoked in the Unkey dashboard\n3. Check that you're using the correct root key for the environment\n4. If using a new key, ensure it was created successfully\n\nFor security reasons, the specific reason for authentication failure may be intentionally vague in the error message. Check your Unkey dashboard for more detailed information about your root keys."
      },
      "ForbiddenErrorResponse": {
        "type": "object",
        "required": [
          "meta",
          "error"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "error": {
            "$ref": "#/components/schemas/BaseError"
          }
        },
        "description": "Error response when the caller is authenticated but lacks permission to perform the requested operation. This occurs when:\n\n- The root key doesn't have the required permissions for the operation\n- The caller is trying to access resources from a different workspace\n- The caller is attempting to access another user's resources\n- The operation violates a policy restriction\n\nUnlike Unauthorized (401) which indicates authentication issues, Forbidden (403) indicates authorization problems for an authenticated caller.\n\nTo fix this error:\n1. Check the permissions assigned to your root key in the Unkey dashboard\n2. Verify you're operating within the correct workspace\n3. Ensure you have the necessary scope to access the requested resource\n4. Request additional permissions if needed from your workspace administrator\n\nPermission patterns in Unkey follow a hierarchical structure:\n- 'resource.*' grants all permissions for a resource\n- 'resource.read' grants read-only access\n- 'resource.write' grants write access\n\nCommon permission requirements for endpoints include:\n- keys.create - For creating new API keys\n- keys.read - For retrieving key information\n- keys.update - For modifying existing keys\n- keys.delete - For removing keys\n- apis.* - For managing API namespaces"
      },
      "PreconditionFailedErrorResponse": {
        "type": "object",
        "required": [
          "meta",
          "error"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "error": {
            "$ref": "#/components/schemas/BaseError"
          }
        },
        "description": "Error response for when the service is available but in a degraded state. This occurs when preconditions for normal operation aren't fully met. This could happen when dependent services are experiencing issues, when the system is in maintenance mode, or when certain features are temporarily disabled. Clients should proceed with caution and may want to retry non-critical operations later."
      },
      "BadRequestErrorResponse": {
        "type": "object",
        "required": [
          "meta",
          "error"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "error": {
            "$ref": "#/components/schemas/BadRequestErrorDetails"
          }
        },
        "description": "Error response for invalid requests that cannot be processed due to client-side errors. This typically occurs when request parameters are missing, malformed, or fail validation rules. The response includes detailed information about the specific errors in the request, including the location of each error and suggestions for fixing it. When receiving this error, check the 'errors' array in the response for specific validation issues that need to be addressed before retrying."
      },
      "InternalServerErrorResponse": {
        "type": "object",
        "required": [
          "meta",
          "error"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "error": {
            "$ref": "#/components/schemas/BaseError"
          }
        },
        "description": "Error response for unexpected server-side issues that prevented the request from being processed correctly. This is typically caused by problems with the service infrastructure, database connectivity issues, unexpected exceptions, or service failures. When receiving this error, clients should implement appropriate retry strategies with backoff and report the issue if it persists. The requestId in the meta object is essential for troubleshooting and should be included in any support inquiries."
      },
      "Identity": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Identity ID"
          },
          "externalId": {
            "type": "string",
            "description": "External identity ID"
          },
          "meta": {
            "type": "object",
            "description": "Identity metadata"
          }
        },
        "required": [
          "id",
          "externalId"
        ]
      },
      "KeyCredits": {
        "type": "object",
        "description": "Remaining requests for this key",
        "properties": {
          "remaining": {
            "type": "integer",
            "description": "Remaining credits"
          },
          "refill": {
            "$ref": "#/components/schemas/KeyCreditsRefill"
          }
        },
        "required": [
          "remaining"
        ]
      },
      "KeyCreditsRefill": {
        "type": "object",
        "properties": {
          "interval": {
            "type": "string",
            "enum": [
              "daily",
              "monthly"
            ],
            "description": "Refill interval"
          },
          "amount": {
            "type": "integer",
            "description": "Amount to refill"
          },
          "refillDay": {
            "type": "integer",
            "description": "Day of the month when refill happens (for monthly interval)"
          },
          "lastRefillAt": {
            "type": "integer",
            "format": "int64",
            "description": "Last time the key was refilled (Unix timestamp)"
          }
        },
        "required": [
          "interval",
          "amount"
        ]
      },
      "KeyResponse": {
        "type": "object",
        "properties": {
          "keyId": {
            "type": "string",
            "description": "The key ID"
          },
          "start": {
            "type": "string",
            "description": "The first few characters of the key"
          },
          "name": {
            "type": "string",
            "description": "Optional name for the key"
          },
          "meta": {
            "type": "object",
            "description": "Optional metadata for the key"
          },
          "createdAt": {
            "type": "integer",
            "format": "int64",
            "description": "When the key was created (Unix timestamp)"
          },
          "updatedAt": {
            "type": "integer",
            "format": "int64",
            "description": "When the key was last updated (Unix timestamp)"
          },
          "expires": {
            "type": "integer",
            "format": "int64",
            "description": "When the key expires (Unix timestamp)"
          },
          "credits": {
            "$ref": "#/components/schemas/KeyCredits"
          },
          "environment": {
            "type": "string",
            "description": "Optional environment tag"
          },
          "plaintext": {
            "type": "string",
            "description": "The decrypted key value (only included if decrypt=true)"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Roles assigned to this key"
          },
          "permissions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Permissions assigned to this key"
          },
          "identity": {
            "$ref": "#/components/schemas/Identity"
          }
        },
        "required": [
          "keyId",
          "start",
          "createdAt"
        ]
      },
      "LivenessResponseData": {
        "type": "object",
        "properties": {
          "message": {
            "description": "Status message indicating the health of the service. A value of 'OK' indicates that the service is functioning properly and ready to accept requests. Any other value indicates a potential issue with the service health.",
            "example": "OK",
            "type": "string"
          }
        },
        "required": [
          "message"
        ],
        "description": "Response data for the liveness check endpoint. This provides a simple indication of whether the Unkey API service is running and able to process requests. Monitoring systems can use this endpoint to track service availability and trigger alerts if the service becomes unhealthy."
      },
      "V2LivenessResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/LivenessResponseData"
          }
        }
      },
      "V2RatelimitSetOverrideRequestBody": {
        "description": "Sets a new or overwrites an existing rate limit override. Overrides allow you to apply special rate limit rules to specific identifiers, providing custom limits that differ from the default.\n\nOverrides are useful for:\n- Granting higher limits to premium users or trusted partners\n- Implementing stricter limits for suspicious or abusive users\n- Creating tiered access levels with different quotas\n- Implementing temporary rate limit adjustments\n- Prioritizing important clients with higher limits",
        "additionalProperties": false,
        "properties": {
          "namespaceId": {
            "description": "The unique ID of the rate limit namespace. Either namespaceId or namespaceName must be provided, but not both. Using namespaceId guarantees you're targeting the exact namespace intended, even if names change, making it ideal for automation and scripts.",
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          },
          "namespaceName": {
            "description": "The name of the rate limit namespace. Either namespaceId or namespaceName must be provided, but not both. Using namespaceName is more human-readable and convenient for manual operations and configurations.",
            "type": "string"
          },
          "duration": {
            "description": "The duration in milliseconds for the rate limit window. This defines how long the rate limit counter accumulates before resetting to zero.\n\nConsiderations:\n- This can differ from the default duration for the namespace\n- Longer durations create stricter limits that take longer to reset\n- Shorter durations allow more frequent bursts of activity\n- Common values: 60000 (1 minute), 3600000 (1 hour), 86400000 (1 day)",
            "format": "int64",
            "type": "integer",
            "minimum": 1000
          },
          "identifier": {
            "description": "Identifier of the entity receiving this custom rate limit. This can be:\n\n- A specific user ID for individual custom limits\n- An IP address for location-based rules\n- An email domain for organization-wide policies\n- Any other string that identifies the target entity\n\nWildcards (*) can be used to create pattern-matching rules that apply to multiple identifiers. For example:\n- 'premium_*' would match all identifiers starting with 'premium_'\n- '*_admin' would match all identifiers ending with '_admin'\n- '*suspicious*' would match any identifier containing 'suspicious'\n\nMore detailed information on wildcard pattern rules is available at https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules",
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          },
          "limit": {
            "description": "The maximum number of requests allowed for this override. This defines the custom quota for the specified identifier(s).\n\nSpecial values:\n- Higher than default: For premium or trusted entities\n- Lower than default: For suspicious or abusive entities\n- 0: To completely block access (useful for ban implementation)\n\nThis limit entirely replaces the default limit for matching identifiers.",
            "format": "int64",
            "type": "integer",
            "minimum": 0
          }
        },
        "required": [
          "identifier",
          "limit",
          "duration"
        ],
        "type": "object"
      },
      "RatelimitSetOverrideResponseData": {
        "type": "object",
        "properties": {
          "overrideId": {
            "description": "The unique identifier for the newly created or updated rate limit override. This ID can be used to:\n\n- Reference this specific override in subsequent API calls\n- Delete or modify this override later\n- Track which override is being applied in rate limit responses\n- Associate override effects with specific rules in analytics\n\nStore this ID if you need to manage the override in the future.",
            "type": "string"
          }
        },
        "required": [
          "overrideId"
        ]
      },
      "V2RatelimitSetOverrideResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/RatelimitSetOverrideResponseData"
          }
        }
      },
      "V2RatelimitGetOverrideRequestBody": {
        "description": "Gets the configuration of an existing rate limit override. Use this to retrieve details about custom rate limit rules that have been created for specific identifiers within a namespace.\n\nThis endpoint is useful for:\n- Verifying override configurations\n- Checking current limits for specific entities\n- Auditing rate limit policies\n- Debugging rate limiting behavior\n- Retrieving override settings for modification",
        "additionalProperties": false,
        "properties": {
          "namespaceId": {
            "description": "The unique ID of the rate limit namespace. Either namespaceId or namespaceName must be provided, but not both. Using namespaceId is more precise and less prone to naming conflicts, making it ideal for scripts and automated operations.",
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          },
          "namespaceName": {
            "description": "The name of the rate limit namespace. Either namespaceId or namespaceName must be provided, but not both. Using namespaceName is more human-readable and easier to work with for manual operations and configurations.",
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          },
          "identifier": {
            "description": "The exact identifier pattern for the override you want to retrieve. This must match exactly as it was specified when creating the override.\n\nImportant notes:\n- This is case-sensitive and must match exactly\n- Include any wildcards (*) that were part of the original pattern\n- For example, if the override was created for 'premium_*', you must use 'premium_*' here, not a specific ID like 'premium_user1'\n\nThis field is used to look up the specific override configuration for this pattern.",
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          }
        },
        "required": [
          "identifier"
        ],
        "type": "object"
      },
      "V2RatelimitGetOverrideResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/RatelimitOverride"
          }
        }
      },
      "V2RatelimitListOverridesRequestBody": {
        "additionalProperties": false,
        "properties": {
          "namespaceId": {
            "description": "The unique ID of the rate limit namespace to list overrides for. Either namespaceId or namespaceName must be provided, but not both. Using namespaceId guarantees you're targeting the exact namespace intended, even if names change over time.",
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          },
          "namespaceName": {
            "description": "The name of the rate limit namespace to list overrides for. Either namespaceId or namespaceName must be provided, but not both. Using namespaceName is more human-readable and convenient for manual operations and dashboards.",
            "type": "string"
          },
          "cursor": {
            "description": "Pagination cursor from a previous response. Include this when fetching subsequent pages of results. Each response containing more results than the requested limit will include a cursor value in the pagination object that can be used here.",
            "type": "string"
          },
          "limit": {
            "description": "Maximum number of override entries to return in a single response. Use this to control response size and loading performance.\n\n- Lower values (10-20): Better for UI displays and faster response times\n- Higher values (50-100): Better for data exports or bulk operations\n- Default (10): Suitable for most dashboard views\n\nResults exceeding this limit will be paginated, with a cursor provided for fetching subsequent pages.",
            "type": "integer",
            "default": 10,
            "minimum": 1,
            "maximum": 100
          }
        },
        "type": "object"
      },
      "RatelimitListOverridesResponseData": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/RatelimitOverride"
        }
      },
      "V2RatelimitListOverridesResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/RatelimitListOverridesResponseData"
          },
          "pagination": {
            "$ref": "#/components/schemas/Pagination"
          }
        }
      },
      "V2RatelimitLimitRequestBody": {
        "additionalProperties": false,
        "properties": {
          "namespace": {
            "description": "The namespace name for the rate limit. Namespaces provide a way to organize and segment different rate limits in your application.\n\nBest practices for namespaces:\n- Use descriptive, hierarchical names (e.g., 'auth.login', 'api.requests', 'media.uploads')\n- Create separate namespaces for different resources or operations\n- Keep naming conventions consistent across your application\n- Consider service or feature-based namespaces for easier monitoring\n\nNamespaces are unique within your workspace, so choose names that clearly indicate their purpose.",
            "type": "string",
            "example": "sms.sign_up",
            "minLength": 1,
            "maxLength": 255
          },
          "cost": {
            "description": "The cost of the request against the rate limit. This allows different operations to consume varying amounts of the rate limit quota.\n\nCommon use cases:\n- Set to 1 (default) for standard operations\n- Set higher values (e.g., 5, 10) for resource-intensive operations\n- Set to 0 for operations that should be tracked but not count against limits\n- Use weighted costs to implement fair queuing or priority systems\n\nWhen the total accrued cost exceeds the limit within the duration window, subsequent requests will be rejected.",
            "format": "int64",
            "type": "integer",
            "default": 1,
            "minimum": 0
          },
          "duration": {
            "description": "The duration in milliseconds for the rate limit window. After this period elapses, the rate limit counter resets.\n\nCommon values:\n- 1000 (1 second): For very strict, per-second limits\n- 60000 (1 minute): For standard API rate limiting\n- 3600000 (1 hour): For less frequent but resource-intensive operations\n- 86400000 (24 hours): For daily quotas\n\nThe duration affects how quickly users can retry after hitting limits. Shorter durations allow faster recovery but may be less effective against certain abuse patterns.",
            "format": "int64",
            "type": "integer",
            "minimum": 1000,
            "maximum": 86400000
          },
          "identifier": {
            "description": "The unique identifier for the entity being rate limited. This defines the scope of the rate limit and is typically:\n\n- A user ID for per-user limits\n- An IP address for anonymous rate limiting\n- An API key ID for per-key limits\n- A session ID for per-session limits\n- A tenant/organization ID for organizational limits\n\nThe same identifier can be used across different namespaces to apply multiple types of limits to the same entity.",
            "type": "string"
          },
          "limit": {
            "description": "The maximum number of operations (adjusted by cost) allowed within the time window. When this limit is reached, subsequent requests will be rejected with a RATE_LIMITED response.\n\nConsiderations for setting limits:\n- Balance between user experience and resource protection\n- Different limits for different user tiers or subscription levels\n- Higher limits for authenticated vs. unauthenticated requests\n- System capacity and scaling limitations\n- Business requirements and fair usage policies",
            "format": "int64",
            "type": "integer",
            "minimum": 1
          }
        },
        "required": [
          "namespace",
          "identifier",
          "limit",
          "duration"
        ],
        "type": "object"
      },
      "RatelimitLimitResponseData": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "The maximum number of operations allowed within the time window. This reflects either the default limit specified in the request or an override limit if one exists for this identifier.\n\nThis value helps clients understand their total quota for the current window.",
            "format": "int64",
            "type": "integer"
          },
          "remaining": {
            "description": "The number of operations remaining in the current window before the rate limit is exceeded. Applications should use this value to:\n\n- Implement client-side throttling before hitting limits\n- Display usage information to end users\n- Trigger alerts when approaching limits\n- Adjust request patterns based on available capacity\n\nWhen this reaches zero, requests will be rejected until the window resets.",
            "format": "int64",
            "type": "integer"
          },
          "reset": {
            "description": "The Unix timestamp in milliseconds when the rate limit window will reset and 'remaining' will return to 'limit'.\n\nThis timestamp enables clients to:\n- Calculate and display wait times to users\n- Implement intelligent retry mechanisms\n- Schedule requests to resume after the reset\n- Implement exponential backoff when needed\n\nThe reset time is based on a sliding window from the first request in the current window.",
            "format": "int64",
            "type": "integer"
          },
          "success": {
            "description": "Whether the request passed the rate limit check. If true, the request is allowed to proceed. If false, the request has exceeded the rate limit and should be blocked or rejected.\n\nYou MUST check this field to determine if the request should proceed, as the endpoint always returns HTTP 200 even when rate limited.",
            "type": "boolean"
          },
          "overrideId": {
            "description": "If a rate limit override was applied for this identifier, this field contains the ID of the override that was used. Empty when no override is in effect.\n\nThis can be useful for:\n- Debugging which override rule was matched\n- Tracking the effects of specific overrides\n- Understanding why limits differ from default values\n- Audit logging of special rate limit rules",
            "type": "string"
          }
        },
        "required": [
          "limit",
          "remaining",
          "reset",
          "success"
        ]
      },
      "V2RatelimitLimitResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/RatelimitLimitResponseData"
          }
        }
      },
      "V2RatelimitDeleteOverrideRequestBody": {
        "description": "Deletes an existing rate limit override. This permanently removes a custom rate limit rule, reverting affected identifiers back to the default rate limits for the namespace.\n\nUse this endpoint when you need to:\n- Remove special rate limit rules that are no longer needed\n- Reset entities back to standard rate limits\n- Clean up temporary overrides\n- Remove outdated tiering or custom limit rules\n- Fix misconfigured overrides\n\nOnce deleted, the override cannot be recovered, and the operation takes effect immediately.",
        "additionalProperties": false,
        "properties": {
          "namespaceId": {
            "description": "The unique ID of the rate limit namespace containing the override. Either namespaceId or namespaceName must be provided, but not both. Using namespaceId is more precise and less prone to naming conflicts, making it ideal for automation and scripts.",
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          },
          "namespaceName": {
            "description": "The name of the rate limit namespace containing the override. Either namespaceId or namespaceName must be provided, but not both. Using namespaceName is more human-readable and convenient for manual operations and configurations.",
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          },
          "identifier": {
            "description": "The exact identifier pattern of the override to delete. This must match exactly as it was specified when creating the override.\n\nImportant notes:\n- This is case-sensitive and must match exactly\n- Include any wildcards (*) that were part of the original pattern\n- For example, if the override was created for 'premium_*', you must use 'premium_*' here, not a specific ID\n\nAfter deletion, any identifiers previously affected by this override will immediately revert to using the default rate limit for the namespace.",
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          }
        },
        "required": [
          "identifier"
        ],
        "type": "object"
      },
      "RatelimitDeleteOverrideResponseData": {
        "type": "object",
        "additionalProperties": false,
        "description": "Empty response object. A successful response indicates the override was successfully deleted. The operation is immediate - as soon as this response is received, the override no longer exists and affected identifiers have reverted to using the default rate limit for the namespace. No other data is returned as part of the deletion operation."
      },
      "V2RatelimitDeleteOverrideResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/RatelimitDeleteOverrideResponseData"
          }
        }
      },
      "V2IdentitiesCreateIdentityRequestBody": {
        "type": "object",
        "required": [
          "externalId"
        ],
        "properties": {
          "externalId": {
            "type": "string",
            "minLength": 3,
            "description": "The id of this identity in your system.\n\nThis should be a stable, unique identifier that represents a user, organization, or entity in your application. Common sources include:\n- User IDs from your authentication system\n- Organization/tenant IDs\n- Customer IDs from your database\n- Email addresses (if they serve as stable identifiers)\n\nBest practices:\n- Use consistent identifier types across your application\n- Prefer UUIDs or opaque IDs over sequential numbers\n- Ensure the ID remains stable even if other user properties change\n- Consider namespace prefixing (e.g., 'user_123', 'org_456') for clarity\n\n`externalId`s are unique across your workspace and therefore a `CONFLICT` error is returned when you try to create duplicates.\n",
            "example": "user_123"
          },
          "meta": {
            "type": "object",
            "description": "Attach metadata to this identity that you need to have access to when verifying a key.\n\nMetadata lets you store context with the identity that will be accessible during key verification without additional database lookups. This improves performance and reduces dependencies.\n\nCommon metadata uses:\n- User profile information (name, email, etc.)\n- Subscription or plan details\n- Feature flags and entitlements\n- Usage limits or quotas\n- Organization information\n- Region or localization preferences\n\nThis data is returned as-is in the `verifyKey` response when verifying any key associated with this identity.\n\nNote: Metadata should be kept reasonably small as it affects verification performance. For large data sets, consider storing only identifiers or essential information.\n"
          },
          "ratelimits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Ratelimit"
            },
            "description": "Attach ratelimits to this identity.\n\nIdentity-based rate limits provide shared rate limiting across all keys belonging to the same identity. This is essential for:\n\n- Implementing fair usage policies across multiple API keys\n- Preventing abuse by users with multiple keys\n- Enforcing consistent limits regardless of how many keys a user creates\n- Creating tiered access levels with different rate limits\n\nHow it works:\n- Rate limits defined here apply to all keys that share this identity\n- During verification, specify which named limits to check\n- Counters are shared across all keys with this identity\n- Each named limit can have different thresholds and windows\n\nWhen verifying keys, you can specify which limits you want to use and all keys attached to this identity will share the limits, regardless of which specific key is used.\n"
          }
        }
      },
      "Ratelimit": {
        "type": "object",
        "required": [
          "name",
          "limit",
          "duration"
        ],
        "properties": {
          "name": {
            "description": "The name of this rate limit. This name is used to identify which limit to check during key verification.\n\nBest practices for limit names:\n- Use descriptive, semantic names like 'api_requests', 'heavy_operations', or 'downloads'\n- Be consistent with naming conventions across your application\n- Create separate limits for different resource types or operation costs\n- Consider using namespaced names for better organization (e.g., 'files.downloads', 'compute.training')\n\nYou will reference this exact name when verifying keys to check against this specific limit.",
            "type": "string",
            "example": "api",
            "minLength": 3,
            "maxLength": 128
          },
          "limit": {
            "description": "The maximum number of operations allowed within the specified time window.\n\nWhen this limit is reached, verification requests will fail with code=RATE_LIMITED until the window resets. The limit should reflect:\n- Your infrastructure capacity and scaling limitations\n- Fair usage expectations for your service\n- Different tier levels for various user types\n- The relative cost of the operations being limited\n\nHigher values allow more frequent access but may impact service performance.",
            "type": "integer",
            "format": "int64"
          },
          "duration": {
            "description": "The duration for each ratelimit window in milliseconds.\n\nThis controls how long the rate limit counter accumulates before resetting. Common values include:\n- 1000 (1 second): For strict per-second limits on high-frequency operations\n- 60000 (1 minute): For moderate API usage control\n- 3600000 (1 hour): For less frequent but costly operations\n- 86400000 (24 hours): For daily quotas\n\nShorter windows provide more frequent resets but may allow large burst usage. Longer windows provide more consistent usage patterns but take longer to reset after limit exhaustion.",
            "type": "integer",
            "format": "int64"
          }
        }
      },
      "IdentitiesCreateIdentityResponseData": {
        "type": "object",
        "properties": {
          "identityId": {
            "description": "The unique identifier for this identity in Unkey's system (begins with 'id_').\n\nThis ID is generated automatically and used internally by Unkey to reference this identity. While you typically don't need to store this value (your externalId is sufficient), it can be useful to record it for:\n- Debugging purposes\n- Advanced API operations\n- Integration with Unkey's analytics\n\nUnlike externalId which comes from your system, this ID is guaranteed unique across all Unkey workspaces.",
            "type": "string"
          }
        },
        "required": [
          "identityId"
        ]
      },
      "V2IdentitiesCreateIdentityResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/IdentitiesCreateIdentityResponseData"
          }
        }
      },
      "V2IdentitiesGetIdentityRequestBody": {
        "type": "object",
        "properties": {
          "identityId": {
            "type": "string",
            "minLength": 3,
            "description": "The Unkey identity ID to retrieve (begins with 'id_'). Use either identityId or externalId to specify which identity to fetch. If both are provided, identityId takes precedence.",
            "example": "id_1234567890abcdef"
          },
          "externalId": {
            "type": "string",
            "minLength": 1,
            "description": "The external ID of the identity to retrieve. This is the ID from your own system that was used during identity creation. Use either identityId or externalId to specify which identity to fetch. If both are provided, identityId takes precedence.",
            "example": "user_abc123"
          }
        },
        "additionalProperties": false,
        "oneOf": [
          {
            "required": [
              "identityId"
            ]
          },
          {
            "required": [
              "externalId"
            ]
          }
        ]
      },
      "IdentitiesGetIdentityResponseData": {
        "type": "object",
        "required": [
          "id",
          "externalId"
        ],
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier for this identity in Unkey's system (begins with 'id_').",
            "example": "id_1234567890abcdef"
          },
          "externalId": {
            "type": "string",
            "description": "The external identifier for this identity in your system. This is the ID you provided during identity creation.",
            "example": "user_abc123"
          },
          "meta": {
            "type": "object",
            "additionalProperties": true,
            "description": "Custom metadata associated with this identity. This can include any JSON-serializable data you stored with the identity during creation or updates.",
            "example": {
              "name": "Alice Smith",
              "email": "alice@example.com",
              "plan": "premium"
            }
          },
          "ratelimits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Ratelimit"
            },
            "description": "Rate limits associated with this identity. These limits are shared across all API keys linked to this identity, providing consistent rate limiting regardless of which key is used."
          }
        }
      },
      "V2IdentitiesGetIdentityResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/IdentitiesGetIdentityResponseData"
          }
        }
      },
      "V2IdentitiesDeleteIdentityRequestBody": {
        "additionalProperties": false,
        "type": "object",
        "properties": {
          "externalId": {
            "type": "string",
            "minLength": 3,
            "description": "The id of this identity in your system.\n\nThis should match the externalId value you used when creating the identity. You can use this field when you know the specific externalId but don't have the Unkey identityId. Only one of externalId or identityId is required.\n\nThis identifier typically comes from your authentication system and could be a userId, organizationId, or any other stable unique identifier in your application.\n",
            "example": "user_123"
          },
          "identityId": {
            "type": "string",
            "minLength": 3,
            "description": "The Unkey Identity ID (begins with 'id_').\n\nThis is the internal unique identifier generated by Unkey when the identity was created. Use this when you have the specific Unkey ID and want to ensure you're targeting the exact identity. This is especially useful in automation scripts or when you need to guarantee you're operating on a specific identity regardless of externalId changes.\n\nOnly one of externalId or identityId is required.",
            "example": "id_123"
          }
        },
        "oneOf": [
          {
            "required": [
              "externalId"
            ],
            "description": "Identify by external ID from your system"
          },
          {
            "required": [
              "identityId"
            ],
            "description": "Identify by Unkey's internal identity ID"
          }
        ]
      },
      "V2IdentitiesDeleteIdentityResponseBody": {
        "type": "object",
        "description": "Empty response object. A successful response indicates the identity was deleted successfully. The operation is immediate and permanent - the identity and all its associated data are removed from the system. Any API keys previously associated with this identity remain valid but are no longer linked to this identity.",
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          }
        },
        "required": [
          "meta"
        ]
      },
      "Permission": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier for the permission"
          },
          "name": {
            "type": "string",
            "description": "The unique name of the permission"
          },
          "description": {
            "type": "string",
            "description": "A description of what this permission grants access to"
          },
          "workspaceId": {
            "type": "string",
            "description": "The workspace this permission belongs to"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the permission was created"
          }
        },
        "required": [
          "id",
          "name",
          "workspaceId"
        ]
      },
      "V2PermissionsCreatePermissionRequestBody": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "minLength": 1,
            "description": "The unique name of your permission",
            "example": "record.write"
          },
          "description": {
            "type": "string",
            "description": "Explain what this permission does. This is just for your team, your users will not see this.",
            "example": "record.write can create new dns records for our domains."
          }
        },
        "additionalProperties": false
      },
      "PermissionsCreatePermissionResponseData": {
        "type": "object",
        "properties": {
          "permissionId": {
            "type": "string",
            "description": "The id of the permission. This is used internally",
            "example": "perm_123"
          }
        },
        "required": [
          "permissionId"
        ]
      },
      "V2PermissionsCreatePermissionResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/PermissionsCreatePermissionResponseData"
          }
        }
      },
      "V2PermissionsGetPermissionRequestBody": {
        "type": "object",
        "required": [
          "permissionId"
        ],
        "properties": {
          "permissionId": {
            "type": "string",
            "minLength": 1,
            "description": "The id of the permission to retrieve",
            "example": "perm_123"
          }
        },
        "additionalProperties": false
      },
      "PermissionsGetPermissionResponseData": {
        "type": "object",
        "properties": {
          "permission": {
            "$ref": "#/components/schemas/Permission"
          }
        },
        "required": [
          "permission"
        ]
      },
      "V2PermissionsGetPermissionResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/PermissionsGetPermissionResponseData"
          }
        }
      },
      "V2PermissionsListPermissionsRequestBody": {
        "type": "object",
        "properties": {
          "limit": {
            "type": "integer",
            "format": "int32",
            "description": "The maximum number of permissions to return",
            "default": 100,
            "minimum": 1,
            "maximum": 100
          },
          "cursor": {
            "type": "string",
            "description": "Cursor for pagination"
          }
        },
        "additionalProperties": false
      },
      "PermissionsListPermissionsResponseData": {
        "type": "object",
        "properties": {
          "permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Permission"
            }
          },
          "cursor": {
            "type": "string",
            "description": "Cursor for pagination"
          },
          "total": {
            "type": "integer",
            "description": "Total number of permissions"
          }
        },
        "required": [
          "permissions",
          "total"
        ]
      },
      "V2PermissionsListPermissionsResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/PermissionsListPermissionsResponseData"
          }
        }
      },
      "V2PermissionsListRolesRequestBody": {
        "type": "object",
        "properties": {
          "limit": {
            "type": "integer",
            "format": "int32",
            "description": "The maximum number of roles to return",
            "default": 100,
            "minimum": 1,
            "maximum": 100
          },
          "cursor": {
            "type": "string",
            "description": "Cursor for pagination"
          }
        },
        "additionalProperties": false
      },
      "PermissionsListRolesResponseData": {
        "type": "object",
        "properties": {
          "roles": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RoleWithPermissions"
            }
          },
          "cursor": {
            "type": "string",
            "description": "Cursor for pagination"
          },
          "total": {
            "type": "integer",
            "description": "Total number of roles"
          }
        },
        "required": [
          "roles",
          "total"
        ]
      },
      "V2PermissionsDeleteRoleRequestBody": {
        "type": "object",
        "required": [
          "roleId"
        ],
        "properties": {
          "roleId": {
            "type": "string",
            "minLength": 1,
            "description": "The id of the role to delete",
            "example": "role_123"
          }
        },
        "additionalProperties": false
      },
      "V2PermissionsDeleteRoleResponseBody": {
        "type": "object",
        "required": [
          "meta"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          }
        }
      },
      "V2PermissionsListRolesResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/PermissionsListRolesResponseData"
          }
        }
      },
      "V2PermissionsDeletePermissionRequestBody": {
        "type": "object",
        "required": [
          "permissionId"
        ],
        "properties": {
          "permissionId": {
            "type": "string",
            "minLength": 1,
            "description": "The id of the permission to delete",
            "example": "perm_123"
          }
        },
        "additionalProperties": false
      },
      "V2PermissionsDeletePermissionResponseBody": {
        "type": "object",
        "required": [
          "meta"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          }
        }
      },
      "V2PermissionsCreateRoleRequestBody": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "minLength": 1,
            "description": "The unique name of your role",
            "example": "dns.records.manager"
          },
          "description": {
            "type": "string",
            "description": "Explain what this role does. This is just for your team, your users will not see this.",
            "example": "dns.records.manager can read and write dns records for our domains."
          },
          "permissionIds": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The permission IDs to assign to this role"
          }
        },
        "additionalProperties": false
      },
      "PermissionsCreateRoleResponseData": {
        "type": "object",
        "properties": {
          "roleId": {
            "type": "string",
            "description": "The id of the role. This is used internally",
            "example": "role_123"
          }
        },
        "required": [
          "roleId"
        ]
      },
      "V2PermissionsCreateRoleResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/PermissionsCreateRoleResponseData"
          }
        }
      },
      "Role": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier for the role"
          },
          "name": {
            "type": "string",
            "description": "The unique name of the role"
          },
          "description": {
            "type": "string",
            "description": "A description of what this role represents"
          },
          "workspaceId": {
            "type": "string",
            "description": "The workspace this role belongs to"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the role was created"
          }
        },
        "required": [
          "id",
          "name",
          "workspaceId"
        ]
      },
      "RoleWithPermissions": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier for the role"
          },
          "name": {
            "type": "string",
            "description": "The unique name of the role"
          },
          "description": {
            "type": "string",
            "description": "A description of what this role represents"
          },
          "workspaceId": {
            "type": "string",
            "description": "The workspace this role belongs to"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "description": "When the role was created"
          },
          "permissions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Permission"
            },
            "description": "The permissions assigned to this role"
          }
        },
        "required": [
          "id",
          "name",
          "workspaceId",
          "permissions"
        ]
      },
      "V2PermissionsGetRoleRequestBody": {
        "type": "object",
        "required": [
          "roleId"
        ],
        "properties": {
          "roleId": {
            "type": "string",
            "minLength": 1,
            "description": "The id of the role to retrieve",
            "example": "role_123"
          }
        },
        "additionalProperties": false
      },
      "PermissionsGetRoleResponseData": {
        "type": "object",
        "properties": {
          "role": {
            "$ref": "#/components/schemas/RoleWithPermissions"
          }
        },
        "required": [
          "role"
        ]
      },
      "V2PermissionsGetRoleResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/PermissionsGetRoleResponseData"
          }
        }
      },
      "V2ApisCreateApiRequestBody": {
        "type": "object",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "minLength": 3,
            "description": "The name for your API. This is an internal identifier used for organization and not shown to end users. APIs are containers for groups of keys and provide isolation between different environments or services.\n\nBest practices for API names:\n- Use descriptive names that identify the purpose or environment\n- Include environment indicators (e.g., 'payment-service-production', 'auth-service-staging')\n- Use consistent naming conventions across your organization\n- Keep names relatively short but informative\n\nCommon patterns include:\n- Environment separation: 'production-api', 'staging-api', 'development-api'\n- Service-based: 'payment-service', 'user-management', 'data-analytics'\n- Product-based: 'premium-tier', 'free-tier', 'internal-tools'",
            "example": "payment-service-production"
          }
        },
        "additionalProperties": false
      },
      "ApisCreateApiResponseData": {
        "type": "object",
        "properties": {
          "apiId": {
            "description": "The unique identifier for the newly created API (begins with 'api_'). This ID is used in all subsequent operations related to this API, including key creation, key verification, and API management. Store this ID securely as it's required when creating keys within this API namespace.",
            "type": "string",
            "example": "api_2cGKbMxRjIzhCxo1IdjH3a"
          }
        },
        "required": [
          "apiId"
        ]
      },
      "V2ApisDeleteApiRequestBody": {
        "type": "object",
        "required": [
          "apiId"
        ],
        "properties": {
          "apiId": {
            "type": "string",
            "minLength": 3,
            "description": "The id of the API you want to delete (begins with 'api_').\n\nWARNING: Deleting an API has significant consequences:\n- All keys associated with this API will be invalidated immediately\n- Verification attempts for these keys will fail with code=NOT_FOUND\n- This action cannot be undone\n\nBefore deletion, ensure that:\n- You have the correct API ID (check the environment/service)\n- You have migrated any needed keys to a new API\n- You have updated all client applications to use new keys\n- You have backed up any important metadata or analytics",
            "example": "api_VNcuGfVjUkrVcWJmda0A"
          }
        },
        "additionalProperties": false
      },
      "V2ApisGetApiRequestBody": {
        "type": "object",
        "required": [
          "apiId"
        ],
        "properties": {
          "apiId": {
            "type": "string",
            "minLength": 1,
            "description": "The ID of the API to retrieve (begins with 'api_'). This identifier uniquely references a specific API in your workspace. Use this endpoint to verify an API exists, check its name, or retrieve its ID when you only have the name stored.",
            "example": "api_1234"
          }
        },
        "additionalProperties": false
      },
      "ApisGetApiResponseData": {
        "type": "object",
        "properties": {
          "id": {
            "description": "The unique identifier of the API (begins with 'api_'). This ID is used in all operations related to this API, including key creation, key verification, and API management.",
            "type": "string",
            "example": "api_1234567890abcdef"
          },
          "name": {
            "description": "The name of the API as specified during creation. This is an internal identifier used for organization and is not shown to end users. The name helps identify the purpose or environment of this API.",
            "type": "string",
            "example": "payment-service-production"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "V2ApisCreateApiResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/ApisCreateApiResponseData"
          }
        }
      },
      "V2ApisDeleteApiResponseBody": {
        "type": "object",
        "required": [
          "meta"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          }
        }
      },
      "V2ApisGetApiResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/ApisGetApiResponseData"
          }
        }
      },
      "V2ApisListKeysRequestBody": {
        "type": "object",
        "required": [
          "apiId"
        ],
        "properties": {
          "apiId": {
            "type": "string",
            "minLength": 1,
            "description": "The ID of the API whose keys you want to list (begins with 'api_'). This endpoint returns all keys associated with this specific API, subject to pagination and any additional filters provided.",
            "example": "api_1234"
          },
          "limit": {
            "type": "integer",
            "description": "The maximum number of keys to return in a single request. Use this to control response size and loading performance. Higher values return more keys but may increase response time. Lower values may require more pagination requests but provide faster initial loading.",
            "default": 100,
            "minimum": 1,
            "maximum": 100
          },
          "cursor": {
            "type": "string",
            "description": "Pagination cursor from a previous response. Use this to fetch subsequent pages of results when the response contains hasMore=true. Each response containing additional results will include a new cursor value in the pagination object.",
            "example": "cursor_eyJsYXN0S2V5SWQiOiJrZXlfMjNld3MiLCJsYXN0Q3JlYXRlZEF0IjoxNjcyNTI0MjM0MDAwfQ=="
          },
          "externalId": {
            "type": "string",
            "minLength": 3,
            "description": "Optional filter to return only keys associated with a specific external ID. This is useful when you need to find all keys belonging to a particular user, organization, or entity in your system. The value must exactly match the externalId set during key creation.",
            "example": "user_5bf93ab218e"
          },
          "decrypt": {
            "type": "boolean",
            "description": "When true, attempts to include the plaintext key value in the response. SECURITY WARNING:\n- This requires special permissions on the calling root key\n- Only works for keys created with 'recoverable: true'\n- Exposes sensitive key material in the response\n- Should only be used in secure administrative contexts\n- Never enable this in user-facing applications",
            "default": false
          },
          "revalidateKeysCache": {
            "type": "boolean",
            "default": false,
            "description": "EXPERIMENTAL: Skip the cache and fetch the keys directly from the database. This ensures you see the most recent state, including keys created moments ago. Use this when:\n- You've just created a key and need to display it immediately\n- You need absolute certainty about the current key state\n- You're debugging cache consistency issues\n\nThis parameter comes with a performance cost and should be used sparingly."
          }
        },
        "additionalProperties": false
      },
      "ApisListKeysResponseData": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/KeyResponse"
        }
      },
      "V2ApisListKeysResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/ApisListKeysResponseData"
          },
          "pagination": {
            "$ref": "#/components/schemas/Pagination"
          }
        }
      },
      "RatelimitOverride": {
        "type": "object",
        "additionalProperties": false,
        "properties": {
          "namespaceId": {
            "description": "The unique identifier of the rate limit namespace this override belongs to. This links the override to a specific namespace context, ensuring the override only applies within that namespace.",
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          },
          "overrideId": {
            "description": "The unique identifier of this specific rate limit override. This ID is generated when the override is created and can be used for management operations like updating or deleting the override.",
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          },
          "duration": {
            "description": "The duration in milliseconds for this override's rate limit window. This may differ from the default duration for the namespace, allowing custom time windows for specific entities. After this duration elapses, the rate limit counter for affected identifiers resets to zero.",
            "format": "int64",
            "type": "integer",
            "minimum": 1000
          },
          "identifier": {
            "description": "The identifier pattern this override applies to. This determines which entities receive the custom rate limit.\n\nThis can be:\n- An exact identifier for a specific entity\n- A pattern with wildcards for matching multiple entities\n\nWildcard examples:\n- 'admin_*' matches any identifier starting with 'admin_'\n- '*_test' matches any identifier ending with '_test'\n- '*premium*' matches any identifier containing 'premium'\n\nMore complex patterns can combine multiple wildcards. Detailed documentation on pattern matching rules is available at https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules",
            "type": "string",
            "minLength": 1,
            "maxLength": 255
          },
          "limit": {
            "description": "The maximum number of requests allowed for entities matching this override. This replaces the default limit for the namespace when applied.\n\nCommon use cases:\n- Higher limits for premium customers\n- Reduced limits for abusive or suspicious entities\n- Zero limit to completely block specific patterns\n- Custom tier-based limits for different customer segments",
            "format": "int64",
            "type": "integer",
            "minimum": 0
          }
        },
        "required": [
          "namespaceId",
          "overrideId",
          "duration",
          "identifier",
          "limit"
        ]
      },
      "V2KeysWhoamiRequestBody": {
        "type": "object",
        "required": [
          "key"
        ],
        "properties": {
          "key": {
            "type": "string",
            "description": "The API key to identify and retrieve information about",
            "example": "sk_1234567890abcdef",
            "minLength": 1
          }
        },
        "additionalProperties": false
      },
      "KeyWhoamiData": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier of the key",
            "example": "key_1234567890abcdef"
          },
          "name": {
            "type": "string",
            "nullable": true,
            "description": "The human-readable name of the key (optional)",
            "example": "Production API Key"
          },
          "remaining": {
            "type": "integer",
            "nullable": true,
            "format": "int64",
            "description": "The remaining number of requests for the key (null means unlimited)",
            "example": 1000
          },
          "identity": {
            "type": "object",
            "nullable": true,
            "properties": {
              "id": {
                "type": "string",
                "description": "The unique identity ID associated with the key",
                "example": "id_1234567890abcdef"
              },
              "externalId": {
                "type": "string",
                "description": "The external identity ID associated with the key (e.g., user ID in your system)",
                "example": "user_12345"
              }
            },
            "required": [
              "id",
              "externalId"
            ],
            "description": "The identity object associated with the key (null if no identity is associated)"
          },
          "meta": {
            "type": "object",
            "nullable": true,
            "additionalProperties": true,
            "description": "Custom metadata associated with the key (null if no metadata is present)",
            "example": {
              "role": "admin",
              "plan": "premium",
              "teamId": "team_12345"
            }
          },
          "createdAt": {
            "type": "integer",
            "format": "int64",
            "description": "The timestamp in milliseconds when the key was created",
            "example": 1620000000000
          },
          "enabled": {
            "type": "boolean",
            "description": "Whether the key is enabled and can be used",
            "example": true
          },
          "environment": {
            "type": "string",
            "nullable": true,
            "description": "The environment the key is associated with (e.g., production, staging, development)",
            "example": "production"
          }
        },
        "required": [
          "id",
          "createdAt",
          "enabled"
        ]
      },
      "V2KeysWhoamiResponse": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/KeyWhoamiData"
          }
        }
      },
      "V2KeysVerifyKeyRequestBody": {
        "type": "object",
        "required": [
          "apiId",
          "key"
        ],
        "properties": {
          "apiId": {
            "type": "string",
            "minLength": 3,
            "maxLength": 255,
            "description": "The ID of the API this key belongs to. This is required to ensure keys from different environments (dev/staging/prod) or different services don't leak between contexts. You should store this API ID alongside your service configuration.",
            "example": "api_1234"
          },
          "key": {
            "type": "string",
            "minLength": 1,
            "description": "The API key to verify. This is the full string provided by your user - including any prefix. Unkey uses a secure hashing algorithm to verify the key without storing the plaintext value. SECURITY NOTICE: Never log or store API keys in your system.",
            "example": "prefix_f4cc2d765275c206b7d76ff0e92e583067c4e33603fb4055d7ba3031cd7ce36a"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string",
              "minLength": 1,
              "maxLength": 128
            },
            "maxItems": 10,
            "description": "Optional metadata tags for analytics and monitoring. These don't affect verification outcomes but let you segment API usage in analytics dashboards. Good uses include tracking endpoints, client versions, regions, or request details. Format as 'key=value' for best compatibility with analytics tools.",
            "example": [
              "endpoint=/users/profile",
              "method=GET",
              "region=us-east-1",
              "clientVersion=2.3.0"
            ]
          },
          "permissions": {
            "oneOf": [
              {
                "type": "string",
                "description": "A single permission to check. The key is valid only if it has this exact permission. Permission checks are hierarchical - a key with permission 'documents.*' will have access to 'documents.read' and 'documents.write'."
              },
              {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": [
                      "and",
                      "or"
                    ],
                    "description": "Logical operator to apply to the permissions. 'and' requires all permissions to be present, 'or' requires at least one."
                  },
                  "permissions": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "List of permissions to check against the key's assigned permissions and roles."
                  }
                },
                "required": [
                  "type",
                  "permissions"
                ]
              }
            ],
            "description": "Optional RBAC permission checks to verify the key has the required permissions. If provided, the verification will only succeed if the key has the specified permissions (either directly or through roles). This is the recommended way to implement authorization in your API."
          },
          "credits": {
            "type": "object",
            "properties": {
              "cost": {
                "type": "integer",
                "format": "int32",
                "default": 1,
                "description": "The number of credits to deduct for this verification. Set to 0 to validate the key without consuming credits (useful for read-only or free operations). Set higher for premium/expensive operations. This allows implementing tiered usage within a single API."
              }
            },
            "description": "Optional configuration for how this request should affect the key's remaining usage credits. Credits provide a globally consistent mechanism for limiting key usage, ideal for paid APIs with strict usage limits."
          },
          "ratelimits": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "minLength": 1,
                  "description": "The name of the ratelimit to check. This must match a ratelimit configured for the key or identity. Use semantic names like 'requests', 'computations', or 'heavy_operations'.",
                  "example": "api_requests"
                },
                "cost": {
                  "type": "integer",
                  "format": "int32",
                  "minimum": 0,
                  "default": 1,
                  "description": "The cost of this operation against the ratelimit. Higher values consume more of the ratelimit quota. Use this to model operations with different weights."
                },
                "limit": {
                  "type": "integer",
                  "format": "int32",
                  "description": "Temporarily override the configured limit for this request only. This won't change the stored configuration."
                },
                "duration": {
                  "type": "integer",
                  "format": "int32",
                  "description": "Temporarily override the ratelimit window duration in milliseconds for this request only. This won't change the stored configuration."
                }
              }
            },
            "description": "Optional array of ratelimits to check during verification. Ratelimits provide protection against abuse by limiting the frequency of operations. Multiple named ratelimits can be used to control different aspects of your API. Unlike credits, ratelimits are optimized for performance with eventual consistency."
          }
        },
        "additionalProperties": false
      },
      "KeysVerifyKeyResponseData": {
        "type": "object",
        "properties": {
          "valid": {
            "type": "boolean",
            "description": "The primary verification result. If true, the key is valid and can be used. If false, check the 'code' field to understand why verification failed. Your application should always check this field first before proceeding."
          },
          "code": {
            "type": "string",
            "enum": [
              "VALID",
              "NOT_FOUND",
              "FORBIDDEN",
              "USAGE_EXCEEDED",
              "RATE_LIMITED",
              "UNAUTHORIZED",
              "DISABLED",
              "INSUFFICIENT_PERMISSIONS",
              "EXPIRED"
            ],
            "description": "A machine-readable code indicating the verification status or failure reason. Values: VALID (key is valid), NOT_FOUND (key doesn't exist), FORBIDDEN (key exists but belongs to a different API), USAGE_EXCEEDED (key has no more credits), RATE_LIMITED (key exceeded rate limits), UNAUTHORIZED (key can't be used for this action), DISABLED (key was explicitly disabled), INSUFFICIENT_PERMISSIONS (key lacks required permissions), EXPIRED (key has passed its expiration date)."
          },
          "keyId": {
            "type": "string",
            "description": "The unique identifier of the verified key in Unkey's system. Use this ID for operations like updating or revoking the key. This field is returned for both valid and invalid keys (except when code=NOT_FOUND)."
          },
          "name": {
            "type": "string",
            "description": "The human-readable name assigned to this key during creation. This is useful for displaying in logs or admin interfaces to identify the key's purpose or owner."
          },
          "externalId": {
            "type": "string",
            "description": "Your user/tenant identifier that was associated with this key during creation. This allows you to connect the key back to your user without additional database lookups, making it ideal for implementing user-based authorization in stateless services."
          },
          "meta": {
            "type": "object",
            "additionalProperties": true,
            "description": "Custom metadata associated with the key. This can include any JSON-serializable data you stored with the key during creation or updates, such as plan information, feature flags, or user details. Use this to avoid additional database lookups for contextual information needed during API calls."
          },
          "expires": {
            "type": "integer",
            "format": "int64",
            "description": "Unix timestamp (in milliseconds) when the key will expire. If null or not present, the key has no expiration. You can use this to warn users about upcoming expirations or to understand the validity period."
          },
          "credits": {
            "type": "integer",
            "format": "int32",
            "description": "The number of requests/credits remaining for this key. If null or not present, the key has unlimited usage. This value decreases with each verification (based on the 'cost' parameter) unless explicit credit refills are configured."
          },
          "enabled": {
            "type": "boolean",
            "description": "Indicates if the key is currently enabled. Disabled keys will always fail verification with code=DISABLED. This is useful for implementing temporary suspensions without deleting the key."
          },
          "permissions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of all permission names assigned to this key, either directly or through roles. These permissions determine what actions the key can perform. Only returned when permissions were checked during verification or when the key fails with code=INSUFFICIENT_PERMISSIONS."
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of all role names assigned to this key. Roles are collections of permissions that grant access to specific functionality. Only returned when permissions were checked during verification."
          },
          "environment": {
            "type": "string",
            "description": "The environment tag associated with the key (e.g., 'production', 'staging', 'development'). Use this to further segment keys within an API beyond just the apiId separation."
          },
          "identity": {
            "$ref": "#/components/schemas/Identity",
            "description": "Information about the identity associated with this key. Identities allow multiple keys to share resources (like rate limits) and represent the same user or entity across different applications or devices."
          },
          "ratelimits": {
            "type": "array",
            "items": {
              "type": "object",
              "required": [
                "name",
                "limit",
                "remaining",
                "reset"
              ],
              "properties": {
                "name": {
                  "type": "string",
                  "description": "The name of the rate limit that was checked. This matches the name provided in the request."
                },
                "limit": {
                  "type": "integer",
                  "format": "int32",
                  "description": "The maximum number of operations allowed within the current time window for this rate limit."
                },
                "remaining": {
                  "type": "integer",
                  "format": "int32",
                  "description": "The number of operations still allowed within the current time window after this verification. Your application can use this to inform users about remaining capacity or to implement your own backoff strategies."
                },
                "reset": {
                  "type": "integer",
                  "format": "int64",
                  "description": "Unix timestamp in milliseconds when the rate limit window will reset and 'remaining' will return to 'limit'. Use this to implement retry-after logic or to display wait times to users."
                }
              }
            },
            "description": "Information about the rate limits applied during verification. Only included when rate limits were checked. If verification failed with code=RATE_LIMITED, this will show which specific rate limit was exceeded."
          }
        },
        "required": [
          "valid",
          "code"
        ]
      },
      "V2KeysVerifyKeyResponseBody": {
        "type": "object",
        "required": [
          "meta",
          "data"
        ],
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/Meta"
          },
          "data": {
            "$ref": "#/components/schemas/KeysVerifyKeyResponseData"
          }
        }
      }
    }
  },
  "paths": {
    "/v2/keys.whoami": {
      "post": {
        "tags": [
          "keys"
        ],
        "summary": "Get information about an API key",
        "description": "Retrieves detailed information about an API key without incrementing its usage counter",
        "operationId": "whoami",
        "x-speakeasy-name-override": "whoami",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysWhoamiRequestBody"
              },
              "examples": {
                "basic": {
                  "summary": "Basic key lookup",
                  "value": {
                    "key": "sk_1234567890abcdef"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Key information successfully retrieved",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysWhoamiResponse"
                },
                "examples": {
                  "full": {
                    "summary": "Complete key information",
                    "value": {
                      "meta": {
                        "requestId": "req_1234567890abcdef"
                      },
                      "data": {
                        "id": "key_1234567890abcdef",
                        "name": "Production API Key",
                        "remaining": 1000,
                        "identity": {
                          "id": "id_1234567890abcdef",
                          "externalId": "user_12345"
                        },
                        "meta": {
                          "role": "admin",
                          "plan": "premium",
                          "teamId": "team_12345"
                        },
                        "createdAt": 1620000000000,
                        "enabled": true,
                        "environment": "production"
                      }
                    }
                  },
                  "minimal": {
                    "summary": "Key with minimal information",
                    "value": {
                      "meta": {
                        "requestId": "req_1234567890abcdef"
                      },
                      "data": {
                        "id": "key_1234567890abcdef",
                        "createdAt": 1620000000000,
                        "enabled": true
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Missing required parameters or invalid format",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                },
                "examples": {
                  "missingApiId": {
                    "summary": "Missing apiId",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "error": {
                        "title": "Bad Request",
                        "detail": "apiId is required",
                        "status": 400,
                        "type": "https://unkey.dev/errors/bad-request",
                        "errors": [
                          {
                            "message": "apiId is required",
                            "location": "body.apiId"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - Specified API ID doesn't exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal server error. This may occur if there are connection issues with the database or if the verification service is experiencing problems. Implement proper retry logic with backoff in your clients to handle these situations."
          }
        }
      }
    },
    "/v2/keys.setPermissions": {
      "post": {
        "tags": [
          "keys"
        ],
        "summary": "Set (replace) all permissions on an API key",
        "description": "Sets the permissions for an existing API key by replacing all existing direct permissions with the provided set. This is a complete replacement operation - permissions not specified in the request will be removed.\n\nUse this endpoint when you want to:\n- Synchronize API key permissions with an external system\n- Reset a key's permissions to a known state\n- Apply a standardized permission template to a key\n- Remove all permissions from a key (by providing an empty array)\n- Fix over-permissioned keys by applying the precise set needed\n\nKey differences from other endpoints:\n- Unlike addPermissions, this replaces all permissions instead of just adding\n- Unlike removePermissions, this sets the complete state rather than removing specific permissions\n- The advantage is atomic replacement in a single operation versus multiple incremental changes\n\nOnly direct permissions are affected - permissions granted through roles remain unchanged. Changes take effect immediately for new verifications, though existing authorized sessions may continue until their cache expires (typically under 30 seconds).",
        "operationId": "setPermissions",
        "x-speakeasy-name-override": "setPermissions",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysSetPermissionsRequestBody"
              },
              "examples": {
                "removeAll": {
                  "summary": "Remove all permissions from key",
                  "description": "This example won't work as expected! The permissions array must contain at least one permission to remove. To remove all permissions, use the setPermissions endpoint with an empty permissions array instead.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": []
                  }
                },
                "basic": {
                  "summary": "Set permissions using IDs",
                  "description": "Using permission IDs is the most precise approach for setting permissions, especially in automation scripts where exact references are important.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "id": "perm_1n9McEIBSqy44Qy7hzWyM5"
                      },
                      {
                        "id": "perm_2zF4mNyP9BsRj2aQwDxVkT"
                      }
                    ]
                  }
                },
                "withNames": {
                  "summary": "Add permissions using names",
                  "description": "Using permission names is more readable and maintainable. Names must be unique within your workspace.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "name": "documents.write"
                      },
                      {
                        "name": "documents.delete"
                      }
                    ]
                  }
                },
                "withCreation": {
                  "summary": "Set with permission creation",
                  "description": "This example demonstrates setting permissions while simultaneously creating new ones that don't exist yet. Requires the rbac.*.create_permission permission on your root key.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "name": "documents.write"
                      },
                      {
                        "name": "reports.export",
                        "create": true
                      },
                      {
                        "name": "reports.schedule",
                        "create": true
                      }
                    ]
                  }
                },
                "mixed": {
                  "summary": "Mix of ID and name references",
                  "description": "You can combine different reference methods in a single request - some permissions by ID, others by name, and even create new ones on the fly.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "id": "perm_1n9McEIBSqy44Qy7hzWyM5"
                      },
                      {
                        "name": "documents.delete"
                      },
                      {
                        "name": "reports.view",
                        "create": true
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Permissions successfully set on the key. The previous direct permission set has been completely replaced with the new set specified in the request.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysSetPermissionsResponse"
                },
                "examples": {
                  "standard": {
                    "summary": "Complete list of permissions",
                    "value": {
                      "meta": {
                        "requestId": "req_2cGKbMxRyIzhCxo1Idjz8q"
                      },
                      "data": [
                        {
                          "id": "perm_1n9McEIBSqy44Qy7hzWyM5",
                          "name": "documents.write"
                        },
                        {
                          "id": "perm_2zF4mNyP9BsRj2aQwDxVkT",
                          "name": "documents.delete"
                        },
                        {
                          "id": "perm_3qRsTu2vWxYzAbCdEfGhIj",
                          "name": "reports.view"
                        }
                      ]
                    }
                  },
                  "empty": {
                    "summary": "All permissions removed",
                    "value": {
                      "meta": {
                        "requestId": "req_3qRsTu2vWxYzAbCdEfGhIj"
                      },
                      "data": []
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid keyId format, missing required fields, or malformed permission entries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                },
                "examples": {
                  "invalidKeyId": {
                    "summary": "Invalid keyId format",
                    "value": {
                      "meta": {
                        "requestId": "req_5zAbCdEfGhIjKlMnOpQrSt"
                      },
                      "error": {
                        "title": "Bad Request",
                        "detail": "keyId must start with 'key_'",
                        "status": 400,
                        "type": "bad_request"
                      }
                    }
                  },
                  "emptyPermissions": {
                    "summary": "Empty permissions array",
                    "value": {
                      "meta": {
                        "requestId": "req_6aBcDeFgHiJkLmNoPqRsT"
                      },
                      "error": {
                        "title": "Bad Request",
                        "detail": "At least one permission must be specified",
                        "status": 400,
                        "type": "bad_request"
                      }
                    }
                  },
                  "missingIdentifier": {
                    "summary": "Permission missing both id and name",
                    "value": {
                      "meta": {
                        "requestId": "req_7bCdEfGhIjKlMnOpQrStUv"
                      },
                      "error": {
                        "title": "Bad Request",
                        "detail": "Each permission must include either id or name",
                        "status": 400,
                        "type": "bad_request"
                      }
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Missing or invalid authentication credentials",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                },
                "examples": {
                  "invalidRootKey": {
                    "summary": "Invalid root key provided",
                    "value": {
                      "meta": {
                        "requestId": "req_9tUv3wXyZaAbCdEfGhIjKl"
                      },
                      "error": {
                        "title": "Unauthorized",
                        "detail": "The root key provided is invalid or has been revoked.",
                        "status": 401,
                        "type": "unauthorized"
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - Insufficient permissions (requires 'rbac.*.add_permission_to_key' and 'rbac.*.remove_permission_from_key' and potentially 'rbac.*.create_permission')",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                },
                "examples": {
                  "missingAddPermission": {
                    "summary": "Missing add permission",
                    "value": {
                      "meta": {
                        "requestId": "req_0uVwX4yZaAbCdEfGhIjKl"
                      },
                      "error": {
                        "title": "Forbidden",
                        "detail": "Your root key requires the 'rbac.*.add_permission_to_key' permission to perform this operation",
                        "status": 403,
                        "type": "forbidden"
                      }
                    }
                  },
                  "missingRemovePermission": {
                    "summary": "Missing remove permission",
                    "value": {
                      "meta": {
                        "requestId": "req_1vWxYzAbCdEfGhIjKlMnOp"
                      },
                      "error": {
                        "title": "Forbidden",
                        "detail": "Your root key requires the 'rbac.*.remove_permission_from_key' permission to perform this operation",
                        "status": 403,
                        "type": "forbidden"
                      }
                    }
                  },
                  "missingCreatePermission": {
                    "summary": "Cannot create new permissions",
                    "value": {
                      "meta": {
                        "requestId": "req_4bVcWdXeYfZgHiJkLmNoPq"
                      },
                      "error": {
                        "title": "Forbidden",
                        "detail": "Your root key requires the 'rbac.*.create_permission' permission to create new permissions",
                        "status": 403,
                        "type": "forbidden"
                      }
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Not Found - Key not found or specified permission IDs don't exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                },
                "examples": {
                  "keyNotFound": {
                    "summary": "Key not found",
                    "value": {
                      "meta": {
                        "requestId": "req_2wXyZaAbCdEfGhIjKlMnOp"
                      },
                      "error": {
                        "title": "Not Found",
                        "detail": "Key key_2cGKbMxRyIzhCxo1Idjz8q not found",
                        "status": 404,
                        "type": "not_found"
                      }
                    }
                  },
                  "permissionNotFound": {
                    "summary": "Permission not found",
                    "value": {
                      "meta": {
                        "requestId": "req_3xYzAbCdEfGhIjKlMnOpQr"
                      },
                      "error": {
                        "title": "Not Found",
                        "detail": "Permission perm_1n9McEIBSqy44Qy7hzWyM5 not found and not allowed to create",
                        "status": 404,
                        "type": "not_found"
                      }
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - An unexpected error occurred while processing the request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                },
                "examples": {
                  "databaseError": {
                    "summary": "Database error",
                    "value": {
                      "meta": {
                        "requestId": "req_4yZaAbCdEfGhIjKlMnOpQrS"
                      },
                      "error": {
                        "title": "Internal Server Error",
                        "detail": "An unexpected error occurred while processing your request. Please try again later.",
                        "status": 500,
                        "type": "internal_server_error"
                      }
                    }
                  },
                  "cachingError": {
                    "summary": "Cache invalidation error",
                    "value": {
                      "meta": {
                        "requestId": "req_5zAbCdEfGhIjKlMnOpQrSt"
                      },
                      "error": {
                        "title": "Internal Server Error",
                        "detail": "The permissions were successfully set but there was an error invalidating cached keys. Some systems may temporarily see stale data.",
                        "status": 500,
                        "type": "internal_server_error"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v2/keys.removePermissions": {
      "post": {
        "tags": [
          "keys"
        ],
        "summary": "Remove permissions from an API key",
        "description": "Removes one or more permissions from an existing API key. This endpoint is used to selectively revoke access rights from a key without deleting it or affecting other permissions.\n\nKey features:\n- Selective removal - revoke specific permissions while leaving others intact\n- Direct permissions only - doesn't affect permissions granted through roles\n- Idempotent operation - removing permissions multiple times has no additional effect\n- Atomic transaction - all permissions are removed or none are (rollback on failure)\n- Immediate effect - new verifications will see changes within seconds\n- Cache invalidation - all regions eventually reflect the changes\n\nUse cases:\n- Downgrading user access privileges\n- Removing temporary elevated permissions\n- Implementing granular permission adjustments\n- Revoking access to specific resources\n\nThis endpoint complements addPermissions (for granting) and setPermissions (for complete replacement). Use this when you need to selectively remove capabilities without altering other permissions.",
        "operationId": "removePermissions",
        "x-speakeasy-name-override": "removePermissions",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysRemovePermissionsRequestBody"
              },
              "examples": {
                "removeAll": {
                  "summary": "Remove all permissions from key",
                  "description": "Setting an empty permissions array removes all direct permissions from the key. This doesn't remove permissions granted through roles. The key remains valid but will have no direct permissions.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": []
                  }
                },
                "basic": {
                  "summary": "Remove permissions using IDs",
                  "description": "Using permission IDs is the most precise way to remove permissions, guaranteeing you're removing exactly what you intend regardless of name changes.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "id": "perm_1n9McEIBSqy44Qy7hzWyM5"
                      },
                      {
                        "id": "perm_2zF4mNyP9BsRj2aQwDxVkT"
                      }
                    ]
                  }
                },
                "withNames": {
                  "summary": "Remove permissions using names",
                  "description": "Using permission names is more human-readable but requires exact name matches, including full path and correct case sensitivity.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "name": "documents.write"
                      },
                      {
                        "name": "documents.delete"
                      }
                    ]
                  }
                },
                "mixed": {
                  "summary": "Mix of ID and name references",
                  "description": "You can combine ID-based and name-based references in a single request. This is useful when you have exact IDs for some permissions but only names for others.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "id": "perm_1n9McEIBSqy44Qy7hzWyM5"
                      },
                      {
                        "name": "reports.export"
                      }
                    ]
                  }
                },
                "removeAccessGroup": {
                  "summary": "Remove all permissions for a resource group",
                  "description": "A common pattern is removing all permissions related to a specific resource (e.g., 'documents') when revoking access to that resource type.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "name": "documents.read"
                      },
                      {
                        "name": "documents.write"
                      },
                      {
                        "name": "documents.delete"
                      },
                      {
                        "name": "documents.share"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Permissions successfully removed from the key. All requested permissions have been removed if they were present. Any permissions that weren't assigned to the key were simply ignored without causing an error.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysRemovePermissionsResponse"
                },
                "examples": {
                  "standard": {
                    "summary": "Successful removal",
                    "description": "The response body contains only metadata and an empty data object. This minimalist response structure is by design - if you receive a 200 status code, all requested permissions have been successfully removed (or weren't present to begin with).",
                    "value": {
                      "meta": {
                        "requestId": "req_2cGKbMxRyIzhCxo1Idjz8q"
                      },
                      "data": {}
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid keyId format, missing required fields, or malformed permission entries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                },
                "examples": {
                  "invalidKeyId": {
                    "summary": "Invalid keyId format",
                    "value": {
                      "meta": {
                        "requestId": "req_5zAbCdEfGhIjKlMnOpQrSt"
                      },
                      "error": {
                        "title": "Bad Request",
                        "detail": "keyId must start with 'key_'",
                        "status": 400,
                        "type": "bad_request"
                      }
                    }
                  },
                  "emptyPermissions": {
                    "summary": "Empty permissions array",
                    "value": {
                      "meta": {
                        "requestId": "req_6aBcDeFgHiJkLmNoPqRsT"
                      },
                      "error": {
                        "title": "Bad Request",
                        "detail": "At least one permission must be specified",
                        "status": 400,
                        "type": "bad_request"
                      }
                    }
                  },
                  "missingIdentifier": {
                    "summary": "Permission missing both id and name",
                    "value": {
                      "meta": {
                        "requestId": "req_7bCdEfGhIjKlMnOpQrStUv"
                      },
                      "error": {
                        "title": "Bad Request",
                        "detail": "Each permission must include either id or name",
                        "status": 400,
                        "type": "bad_request"
                      }
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Missing or invalid authentication credentials",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                },
                "examples": {
                  "invalidRootKey": {
                    "summary": "Invalid root key provided",
                    "value": {
                      "meta": {
                        "requestId": "req_9tUv3wXyZaAbCdEfGhIjKl"
                      },
                      "error": {
                        "title": "Unauthorized",
                        "detail": "The root key provided is invalid or has been revoked.",
                        "status": 401,
                        "type": "unauthorized"
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - Insufficient permissions (requires 'rbac.*.remove_permission_from_key')",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                },
                "examples": {
                  "missingPermission": {
                    "summary": "Missing required permission",
                    "value": {
                      "meta": {
                        "requestId": "req_0uVwX4yZaAbCdEfGhIjKl"
                      },
                      "error": {
                        "title": "Forbidden",
                        "detail": "Your root key requires the 'rbac.*.remove_permission_from_key' permission to perform this operation",
                        "status": 403,
                        "type": "forbidden"
                      }
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Not Found - Key not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                },
                "examples": {
                  "keyNotFound": {
                    "summary": "Key not found",
                    "value": {
                      "meta": {
                        "requestId": "req_2wXyZaAbCdEfGhIjKlMnOp"
                      },
                      "error": {
                        "title": "Not Found",
                        "detail": "Key key_2cGKbMxRyIzhCxo1Idjz8q not found",
                        "status": 404,
                        "type": "not_found"
                      }
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - An unexpected error occurred while processing the request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                },
                "examples": {
                  "databaseError": {
                    "summary": "Database error",
                    "value": {
                      "meta": {
                        "requestId": "req_4yZaAbCdEfGhIjKlMnOpQrS"
                      },
                      "error": {
                        "title": "Internal Server Error",
                        "detail": "An unexpected error occurred while processing your request. Please try again later.",
                        "status": 500,
                        "type": "internal_server_error"
                      }
                    }
                  },
                  "cachingError": {
                    "summary": "Cache invalidation error",
                    "value": {
                      "meta": {
                        "requestId": "req_5zAbCdEfGhIjKlMnOpQrSt"
                      },
                      "error": {
                        "title": "Internal Server Error",
                        "detail": "The permissions were successfully removed but there was an error invalidating cached keys. Some systems may temporarily see stale data.",
                        "status": 500,
                        "type": "internal_server_error"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v2/keys.addRoles": {
      "post": {
        "tags": [
          "keys"
        ],
        "summary": "Add roles to an API key",
        "description": "Assigns one or more roles to an existing API key, incrementally adding to any existing roles already assigned.\n\nRoles are collections of permissions that provide a convenient and manageable way to assign multiple permissions at once. Rather than assigning individual permissions one by one, roles let you bundle related permissions together and assign them as a unit.\n\nKey features:\n- Idempotent operation - adding the same role multiple times has no additional effect\n- Atomic transaction - all roles are added or none are (with rollback on failure)\n- Immediate effect - new verifications will see changes within seconds\n- Cache invalidation - all regions eventually reflect the changes\n- Permission aggregation - during verification, permissions from all roles are combined\n\nUse cases:\n- Promoting users to higher access levels\n- Adding specialized function access to existing keys\n- Implementing role-based access control (RBAC)\n- Standardizing permission bundles across many keys\n\nUnlike setRoles (which replaces all roles), this endpoint only adds to the existing set of roles assigned to a key.",
        "operationId": "addRoles",
        "x-speakeasy-name-override": "addRoles",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysAddRolesRequestBody"
              },
              "examples": {
                "basic": {
                  "summary": "Adding roles by ID",
                  "description": "Adding roles using their IDs is the most precise method, ensuring you're adding exactly the intended roles regardless of name changes.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "roles": [
                      {
                        "id": "role_1n9McEIBSqy44Qy7hzWyM5"
                      },
                      {
                        "id": "role_2a8NdFJCTrz55Ry8Jdkz9r"
                      }
                    ]
                  }
                },
                "withNames": {
                  "summary": "Adding roles by name",
                  "description": "Adding roles by name is more human-readable and convenient when working with well-known role names in your system.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "roles": [
                      {
                        "name": "admin"
                      },
                      {
                        "name": "billing_manager"
                      }
                    ]
                  }
                },
                "mixed": {
                  "summary": "Adding roles by mixed identifiers",
                  "description": "You can mix both ID and name references in a single request, using whichever is more convenient for each role.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "roles": [
                      {
                        "id": "role_1n9McEIBSqy44Qy7hzWyM5"
                      },
                      {
                        "name": "billing_manager"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Roles successfully added to the key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysAddRolesResponse"
                },
                "examples": {
                  "standard": {
                    "summary": "Complete list of roles",
                    "value": {
                      "meta": {
                        "requestId": "req_1234567890abcdef"
                      },
                      "data": [
                        {
                          "id": "role_1n9McEIBSqy44Qy7hzWyM5",
                          "name": "admin"
                        },
                        {
                          "id": "role_2a8NdFJCTrz55Ry8Jdkz9r",
                          "name": "billing_manager"
                        },
                        {
                          "id": "role_3b9OeGKDUsy66Sz9Kelz0s",
                          "name": "developer"
                        }
                      ]
                    }
                  },
                  "empty": {
                    "summary": "No roles assigned",
                    "value": {
                      "meta": {
                        "requestId": "req_1234567890abcdef"
                      },
                      "data": []
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Invalid parameters or configuration",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                },
                "examples": {
                  "invalidPrefix": {
                    "summary": "Invalid prefix format",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "error": {
                        "title": "Bad Request",
                        "detail": "Prefix must contain only alphanumeric characters, underscores, and hyphens",
                        "status": 400,
                        "type": "https://unkey.dev/errors/bad-request",
                        "errors": [
                          {
                            "message": "Prefix must contain only alphanumeric characters, underscores, and hyphens",
                            "location": "body.prefix"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - Key doesn't exist or was deleted",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v2/keys.addPermissions": {
      "post": {
        "tags": [
          "keys"
        ],
        "summary": "Add permissions to an API key",
        "description": "Assigns one or more permissions to an existing API key. This endpoint is used to incrementally add permissions without removing existing ones.\n\nPermissions define access control capabilities that are validated during key verification. Each permission typically follows a 'resource.action' naming pattern (e.g., 'documents.read', 'users.create'). A key can have both direct permissions (added via this endpoint) and indirect permissions (granted through roles).\n\nKey features:\n- Idempotent operation - adding the same permission multiple times has no additional effect\n- Atomic transaction - all permissions are added or none are (rollback on failure)\n- Permission creation - optionally create new permissions if they don't exist (with 'create: true')\n- Cache invalidation - changes take effect immediately for new verifications\n- Hierarchical permissions - during verification, 'documents.*' grants access to both 'documents.read' and 'documents.write'\n\nUnlike setPermissions (which replaces all permissions), this endpoint only adds to the existing set. Use this when incrementally granting new capabilities to existing keys.",
        "operationId": "addPermissions",
        "x-speakeasy-name-override": "addPermissions",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysAddPermissionsRequestBody"
              },
              "examples": {
                "basic": {
                  "summary": "Add permissions using IDs",
                  "description": "When you know the exact permission IDs, referencing them directly is the most precise approach. Permission IDs are guaranteed to be unique.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "id": "perm_1n9McEIBSqy44Qy7hzWyM5"
                      },
                      {
                        "id": "perm_2zF4mNyP9BsRj2aQwDxVkT"
                      }
                    ]
                  }
                },
                "withNames": {
                  "summary": "Add permissions using names",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "name": "documents.write"
                      },
                      {
                        "name": "documents.delete"
                      }
                    ]
                  }
                },
                "withCreation": {
                  "summary": "Add and create new permissions",
                  "description": "Setting create=true dynamically creates permissions if they don't exist yet. This requires the rbac.*.create_permission permission on your root key.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "name": "reports.export",
                        "create": true
                      },
                      {
                        "name": "reports.schedule",
                        "create": true
                      }
                    ]
                  }
                },
                "mixed": {
                  "summary": "Mix ID and name references",
                  "description": "You can combine ID references, name references, and creation in a single request. If both id and name are provided for any permission, the id takes precedence.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "id": "perm_1n9McEIBSqy44Qy7hzWyM5"
                      },
                      {
                        "name": "documents.publish"
                      },
                      {
                        "name": "analytics.view",
                        "create": true
                      }
                    ]
                  }
                },
                "hierarchical": {
                  "summary": "Using hierarchical permission naming",
                  "description": "Permissions can use hierarchical naming with dots as separators. During verification, a request for 'billing.invoices.*' will match both 'billing.invoices.create' and 'billing.invoices.view'.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "name": "billing.invoices.create",
                        "create": true
                      },
                      {
                        "name": "billing.invoices.view",
                        "create": true
                      },
                      {
                        "name": "billing.payments.process",
                        "create": true
                      }
                    ]
                  }
                },
                "completeBilling": {
                  "summary": "Complete billing system permissions",
                  "description": "Creating a structured set of permissions for a complete subsystem like billing",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "permissions": [
                      {
                        "name": "billing.invoices.create",
                        "create": true
                      },
                      {
                        "name": "billing.invoices.view",
                        "create": true
                      },
                      {
                        "name": "billing.invoices.update",
                        "create": true
                      },
                      {
                        "name": "billing.payments.process",
                        "create": true
                      },
                      {
                        "name": "billing.payments.refund",
                        "create": true
                      },
                      {
                        "name": "billing.settings.view",
                        "create": true
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Permissions successfully added to the key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysAddPermissionsResponse"
                },
                "examples": {
                  "standard": {
                    "summary": "Complete list of permissions",
                    "description": "After adding new permissions, the response includes the full list of all permissions now assigned to the key, sorted alphabetically by name.",
                    "value": {
                      "meta": {
                        "requestId": "req_2cGKbMxRyIzhCxo1Idjz8q"
                      },
                      "data": [
                        {
                          "id": "perm_1n9McEIBSqy44Qy7hzWyM5",
                          "name": "documents.write"
                        },
                        {
                          "id": "perm_2zF4mNyP9BsRj2aQwDxVkT",
                          "name": "documents.delete"
                        },
                        {
                          "id": "perm_3qRsTu2vWxYzAbCdEfGhIj",
                          "name": "documents.read"
                        },
                        {
                          "id": "perm_4bVcWdXeYfZgHiJkLmNoPq",
                          "name": "reports.export"
                        },
                        {
                          "id": "perm_5sTu2vWxYzAbCdEfGhIjKl",
                          "name": "reports.schedule"
                        }
                      ]
                    }
                  },
                  "hierarchical": {
                    "summary": "Key with hierarchical permissions",
                    "value": {
                      "meta": {
                        "requestId": "req_7zF4mNyP9BsRj2aQwDxVkT"
                      },
                      "data": [
                        {
                          "id": "perm_1n9McEIBSqy44Qy7hzWyM5",
                          "name": "billing.invoices.create"
                        },
                        {
                          "id": "perm_2zF4mNyP9BsRj2aQwDxVkT",
                          "name": "billing.invoices.view"
                        },
                        {
                          "id": "perm_3qRsTu2vWxYzAbCdEfGhIj",
                          "name": "billing.payments.process"
                        },
                        {
                          "id": "perm_4bVcWdXeYfZgHiJkLmNoPq",
                          "name": "billing.settings.read"
                        },
                        {
                          "id": "perm_5sTu2vWxYzAbCdEfGhIjKl",
                          "name": "billing.settings.write"
                        }
                      ]
                    }
                  },
                  "empty": {
                    "summary": "Key with no permissions",
                    "value": {
                      "meta": {
                        "requestId": "req_8sTu2vWxYzAbCdEfGhIjKl"
                      },
                      "data": []
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad Request - Invalid keyId format, missing required fields, or malformed permission entries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                },
                "examples": {
                  "invalidKeyId": {
                    "summary": "Invalid keyId format",
                    "value": {
                      "meta": {
                        "requestId": "req_5zAbCdEfGhIjKlMnOpQrSt"
                      },
                      "error": {
                        "title": "Bad Request",
                        "detail": "keyId must start with 'key_'",
                        "status": 400,
                        "type": "bad_request"
                      }
                    }
                  },
                  "emptyPermissions": {
                    "summary": "Empty permissions array",
                    "value": {
                      "meta": {
                        "requestId": "req_6aBcDeFgHiJkLmNoPqRsT"
                      },
                      "error": {
                        "title": "Bad Request",
                        "detail": "At least one permission must be specified",
                        "status": 400,
                        "type": "bad_request"
                      }
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Missing or invalid authentication credentials",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                },
                "examples": {
                  "invalidRootKey": {
                    "summary": "Invalid root key provided",
                    "value": {
                      "meta": {
                        "requestId": "req_9tUv3wXyZaAbCdEfGhIjKl"
                      },
                      "error": {
                        "title": "Unauthorized",
                        "detail": "The root key provided is invalid or has been revoked.",
                        "status": 401,
                        "type": "unauthorized"
                      }
                    }
                  }
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - Insufficient permissions (requires 'rbac.*.add_permission_to_key' and potentially 'rbac.*.create_permission')",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                },
                "examples": {
                  "missingPermission": {
                    "summary": "Missing required permission",
                    "value": {
                      "meta": {
                        "requestId": "req_0uVwX4yZaAbCdEfGhIjKl"
                      },
                      "error": {
                        "title": "Forbidden",
                        "detail": "Your root key requires the 'rbac.*.add_permission_to_key' permission to perform this operation",
                        "status": 403,
                        "type": "forbidden"
                      }
                    }
                  },
                  "missingCreatePermission": {
                    "summary": "Cannot create new permissions",
                    "value": {
                      "meta": {
                        "requestId": "req_1vWxYzAbCdEfGhIjKlMnOp"
                      },
                      "error": {
                        "title": "Forbidden",
                        "detail": "Your root key requires the 'rbac.*.create_permission' permission to create new permissions",
                        "status": 403,
                        "type": "forbidden"
                      }
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Not Found - Key not found or specified permission IDs don't exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                },
                "examples": {
                  "keyNotFound": {
                    "summary": "Key not found",
                    "value": {
                      "meta": {
                        "requestId": "req_2wXyZaAbCdEfGhIjKlMnOp"
                      },
                      "error": {
                        "title": "Not Found",
                        "detail": "Key key_2cGKbMxRyIzhCxo1Idjz8q not found",
                        "status": 404,
                        "type": "not_found"
                      }
                    }
                  },
                  "permissionNotFound": {
                    "summary": "Permission not found",
                    "value": {
                      "meta": {
                        "requestId": "req_3xYzAbCdEfGhIjKlMnOpQr"
                      },
                      "error": {
                        "title": "Not Found",
                        "detail": "Permission perm_1n9McEIBSqy44Qy7hzWyM5 not found",
                        "status": 404,
                        "type": "not_found"
                      }
                    }
                  }
                }
              }
            }
          },
          "500": {
            "description": "Internal Server Error - An unexpected error occurred while processing the request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                },
                "examples": {
                  "databaseError": {
                    "summary": "Database error",
                    "value": {
                      "meta": {
                        "requestId": "req_4yZaAbCdEfGhIjKlMnOpQrS"
                      },
                      "error": {
                        "title": "Internal Server Error",
                        "detail": "An unexpected error occurred while processing your request. Please try again later.",
                        "status": 500,
                        "type": "internal_server_error"
                      }
                    }
                  },
                  "cachingError": {
                    "summary": "Cache invalidation error",
                    "value": {
                      "meta": {
                        "requestId": "req_5zAbCdEfGhIjKlMnOpQrSt"
                      },
                      "error": {
                        "title": "Internal Server Error",
                        "detail": "The permissions were successfully added but there was an error invalidating cached keys. Some systems may temporarily see stale data.",
                        "status": 500,
                        "type": "internal_server_error"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/v2/keys.removeRoles": {
      "post": {
        "tags": [
          "keys"
        ],
        "summary": "Remove roles from an API key",
        "description": "Removes one or more roles from an existing API key. This endpoint is used to selectively revoke role-based access without affecting other assigned roles.\n\nWhen a role is removed:\n- All permissions granted exclusively through that role are revoked\n- Permissions that are also granted through remaining roles or direct assignments remain accessible\n- The change is effective immediately for new verifications\n- Cached sessions may retain old permissions briefly (typically <30 seconds)\n\nKey features:\n- Selective removal - revoke specific roles while leaving others intact\n- Idempotent operation - removing roles multiple times has no additional effect\n- Atomic transaction - all specified roles are removed or none are (rollback on failure)\n- Cache invalidation - all regions eventually reflect the changes\n- Permission recalculation - verification immediately uses updated role assignments\n\nThis endpoint complements addRoles (for granting) and setRoles (for complete replacement). Use this when you need to selectively remove roles without altering other role assignments.",
        "operationId": "removeRoles",
        "x-speakeasy-name-override": "removeRoles",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysRemoveRolesRequestBody"
              },
              "examples": {
                "basic": {
                  "summary": "Removing roles by ID",
                  "description": "Removing roles by their exact IDs ensures precision in revoking the exact intended roles, regardless of name changes.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "roles": [
                      {
                        "id": "role_1n9McEIBSqy44Qy7hzWyM5"
                      },
                      {
                        "id": "role_2a8NdFJCTrz55Ry8Jdkz9r"
                      }
                    ]
                  }
                },
                "withNames": {
                  "summary": "Removing roles by name",
                  "description": "Removing roles by name is more human-readable but requires exact name matches, including correct capitalization.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "roles": [
                      {
                        "name": "admin"
                      },
                      {
                        "name": "billing_manager"
                      }
                    ]
                  }
                },
                "mixed": {
                  "summary": "Removing roles by mixed identifiers",
                  "description": "You can combine both ID and name references in a single request to remove multiple roles using whichever reference method is most convenient for each role.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "roles": [
                      {
                        "id": "role_1n9McEIBSqy44Qy7hzWyM5"
                      },
                      {
                        "name": "billing_manager"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Roles successfully removed from the key. The response shows all remaining roles still assigned to the key after the removal operation.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysRemoveRolesResponse"
                },
                "examples": {
                  "standard": {
                    "summary": "Remaining roles after removal",
                    "value": {
                      "meta": {
                        "requestId": "req_1234567890abcdef"
                      },
                      "data": [
                        {
                          "id": "role_3b9OeGKDUsy66Sz9Kelz0s",
                          "name": "developer"
                        }
                      ]
                    }
                  },
                  "empty": {
                    "summary": "No roles remaining",
                    "value": {
                      "meta": {
                        "requestId": "req_1234567890abcdef"
                      },
                      "data": []
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Invalid parameters or configuration",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                },
                "examples": {
                  "invalidKeyId": {
                    "summary": "Invalid key ID format",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQZ"
                      },
                      "error": {
                        "title": "Bad Request",
                        "detail": "keyId must be a valid key ID starting with 'key_'",
                        "status": 400,
                        "type": "https://unkey.dev/errors/bad-request",
                        "errors": [
                          {
                            "message": "keyId must be a valid key ID starting with 'key_'",
                            "location": "body.keyId"
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - The specified identity doesn't exist. This error occurs when no identity matches the provided externalId or identityId. This might happen if the identity was already deleted, never existed, or if there's a typo in the identifier. Verify the identity exists before attempting deletion.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v2/keys.updateRemaining": {
      "post": {
        "tags": [
          "keys"
        ],
        "summary": "Update remaining credits for an API key",
        "description": "Sets the remaining number of credits for a key. This endpoint provides precise control over usage limits and is essential for implementing usage-based business models.\n\nKey use cases:\n- Adding credits when a customer makes a purchase\n- Resetting credits for subscription renewals\n- Adjusting credits for refunds or promotions\n- Converting between subscription models (automatic to fixed or vice versa)\n- Implementing free trial extensions\n- Granting bonus credits as incentives\n- Converting a limited key to unlimited usage or vice versa\n\nThe credits feature provides a globally consistent way to limit how many times a key can be used. Each successful verification decrements the counter (by the 'cost' value, default 1). When credits reach zero, verification fails with code=USAGE_EXCEEDED.\n\nUnlike rate limits (which control frequency), credits control total usage with high consistency but slightly higher latency, making them ideal for monetization models where accuracy is critical.\n\nThis endpoint complements createKey (which sets initial credits) and the automatic refill system (which replenishes credits on a schedule). You can also optionally remove any automatic refill settings from the key, effectively converting it from a key with periodic refills to one with a fixed credit allocation.",
        "operationId": "updateRemaining",
        "x-speakeasy-name-override": "updateRemaining",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysUpdateRemainingRequestBody"
              },
              "examples": {
                "setCredits": {
                  "summary": "Set remaining credits",
                  "description": "This sets an absolute value of 1000 credits for the key. If the key previously had 200 credits, it will now have 1000 (not 1200). If it previously had unlimited usage, it will now be limited to 1000 credits.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "remaining": 1000
                  }
                },
                "setUnlimited": {
                  "summary": "Set unlimited usage",
                  "description": "Setting remaining to -1 makes the key usable an unlimited number of times. This is useful for premium tiers, trusted partners, or internal applications where usage counting isn't needed.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "remaining": -1
                  }
                },
                "removeRefills": {
                  "summary": "Remove refill settings",
                  "description": "This sets 500 credits and removes any automatic refill configuration, effectively converting a key from a subscription-like model to a one-time credit allocation. Useful when downgrading from an automatic plan to a fixed allocation.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "remaining": 500,
                    "overwriteRefillSettings": true
                  }
                },
                "addPurchasedCredits": {
                  "summary": "Add purchased credits",
                  "description": "To add credits to the existing balance, first get the current value using keys.getKey, then add the purchased amount. Any existing refill settings are preserved.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "remaining": 2500
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Remaining credits successfully updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysUpdateRemainingResponse"
                },
                "examples": {
                  "withRefills": {
                    "summary": "Updated with refill settings preserved",
                    "value": {
                      "meta": {
                        "requestId": "req_1234567890abcdef"
                      },
                      "data": {
                        "remaining": 1000,
                        "refillSettings": {
                          "interval": "monthly",
                          "amount": 1000,
                          "refillDay": 1,
                          "lastRefillAt": "2023-01-01T00:00:00Z"
                        }
                      }
                    }
                  },
                  "withoutRefills": {
                    "summary": "Updated with refills removed",
                    "value": {
                      "meta": {
                        "requestId": "req_1234567890abcdef"
                      },
                      "data": {
                        "remaining": 500,
                        "refillSettings": null
                      }
                    }
                  },
                  "unlimited": {
                    "summary": "Set to unlimited usage",
                    "value": {
                      "meta": {
                        "requestId": "req_1234567890abcdef"
                      },
                      "data": {
                        "remaining": -1,
                        "refillSettings": null
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Invalid or missing parameters. This error occurs when the request body is malformed, missing required fields, or contains invalid values. Verify that you've provided either a valid externalId or identityId, and that the format of each field meets the requirements.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v2/keys.setRoles": {
      "post": {
        "tags": [
          "keys"
        ],
        "summary": "Set roles for an API key",
        "description": "Replaces all existing direct role assignments on a key with the provided set of roles. This endpoint offers complete control over a key's role assignments in a single operation.\n\nUnlike incremental endpoints like addRoles or removeRoles, setRoles performs a wholesale replacement, making it ideal for:\n- Synchronizing key roles with an external system\n- Applying standardized role templates to keys\n- Completely resetting a key's roles to a known state\n- Implementing role-based access control (RBAC) with predictable outcomes\n- Removing all roles from a key (by providing an empty array)\n\nKey behaviors:\n- All existing direct role assignments not included in the request will be removed\n- This is a complete replacement operation, not an incremental update\n- Only direct role assignments are affected, not roles granted through other mechanisms\n- The operation is atomic - all roles are set or none are (with rollback on failure)\n- Changes take effect immediately for new verifications\n- All role changes are logged in the audit log for security tracking\n\nAfter roles are set, any cached versions of the key are immediately invalidated to ensure consistency, though existing verification sessions may retain old roles briefly (typically under 30 seconds).",
        "operationId": "setRoles",
        "x-speakeasy-name-override": "setRoles",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysSetRolesRequestBody"
              },
              "examples": {
                "standard": {
                  "summary": "Setting multiple roles",
                  "description": "This example shows setting a mix of roles by both ID and name. After this operation, the key will have exactly these two roles - any other roles previously assigned will be removed.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "roles": [
                      {
                        "id": "role_1n9McEIBSqy44Qy7hzWyM5"
                      },
                      {
                        "name": "developer"
                      }
                    ]
                  }
                },
                "removeAll": {
                  "summary": "Removing all roles",
                  "description": "By providing an empty roles array, you can remove all direct role assignments from a key. This doesn't affect the key's validity, but removes all role-based permissions.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "roles": []
                  }
                },
                "standardTemplate": {
                  "summary": "Applying a standard role template",
                  "description": "A common pattern is applying a standard set of roles to maintain consistency across keys for users with similar access needs.",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "roles": [
                      {
                        "name": "basic_user"
                      },
                      {
                        "name": "analytics_viewer"
                      },
                      {
                        "name": "self_service"
                      }
                    ]
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Roles successfully set for the key",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysSetRolesResponse"
                },
                "examples": {
                  "standard": {
                    "summary": "Roles after update",
                    "value": {
                      "meta": {
                        "requestId": "req_1234567890abcdef"
                      },
                      "data": [
                        {
                          "id": "role_1n9McEIBSqy44Qy7hzWyM5",
                          "name": "admin"
                        },
                        {
                          "id": "role_3b9OeGKDUsy66Sz9Kelz0s",
                          "name": "developer"
                        }
                      ]
                    }
                  },
                  "empty": {
                    "summary": "All roles removed",
                    "value": {
                      "meta": {
                        "requestId": "req_1234567890abcdef"
                      },
                      "data": []
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v2/keys.updateKey": {
      "post": {
        "tags": [
          "keys"
        ],
        "summary": "Update API key properties without changing the key itself",
        "description": "Modifies the properties of an existing API key without changing the key string itself. This endpoint supports partial updates - you only need to include the fields you want to change.\n\nYou can use this endpoint to:\n- Rename keys for better organization\n- Update metadata to reflect changes in user status, plan, or properties\n- Modify usage limits or rate limits\n- Enable or disable keys temporarily\n- Change key expiration dates\n- Add or update user identifiers\n\nTo explicitly remove/disable a feature, set its field to null. Fields not included in the request remain unchanged. For managing permissions or roles, use the specialized endpoints (keys.addPermissions, keys.removePermissions, etc.) instead.\n\nChanges may take up to 30 seconds to propagate to all regions due to cache invalidation. For immediate effect in the current region, follow the update with a verification request.",
        "operationId": "updateKey",
        "x-speakeasy-name-override": "updateKey",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysUpdateKeyRequestBody"
              },
              "examples": {
                "disableKey": {
                  "summary": "Temporarily disable a key",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "enabled": false
                  }
                },
                "updateMetadata": {
                  "summary": "Update key metadata",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "meta": {
                      "plan": "enterprise",
                      "features": {
                        "advancedAnalytics": true,
                        "customReports": true
                      },
                      "updatedAt": "2023-07-15T12:30:45Z"
                    }
                  }
                },
                "changeExpiration": {
                  "summary": "Change expiration date",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "expires": 1735689600000
                  }
                },
                "updateLimits": {
                  "summary": "Modify usage limits",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "credits": {
                      "remaining": 5000,
                      "refill": {
                        "interval": "monthly",
                        "amount": 5000,
                        "refillDay": 1
                      }
                    },
                    "ratelimits": [
                      {
                        "name": "requests",
                        "limit": 200,
                        "duration": 60000
                      }
                    ]
                  }
                },
                "removeFeature": {
                  "summary": "Remove a feature",
                  "value": {
                    "keyId": "key_2cGKbMxRyIzhCxo1Idjz8q",
                    "expires": null,
                    "meta": null
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysUpdateKeyResponseBody"
                },
                "examples": {
                  "success": {
                    "summary": "Successful update",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQY"
                      },
                      "data": {}
                    }
                  }
                }
              }
            },
            "description": "Key successfully updated. Changes may take up to 30 seconds to propagate to all regions due to cache invalidation. The response is empty by design - use keys.getKey to retrieve the current state if needed."
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal server error - Problem with key generation or database operations"
          }
        }
      }
    },
    "/v2/keys.deleteKey": {
      "post": {
        "tags": [
          "keys"
        ],
        "summary": "Delete an API key",
        "description": "Permanently deletes an API key, preventing it from being used for future verification attempts. This endpoint is used when a key is no longer needed, has been compromised, or needs to be revoked.\n\nWhen a key is deleted:\n- Verification attempts will fail with code=NOT_FOUND\n- The key no longer appears in API key listings\n- Historical verification data is preserved for analytics\n\nThis endpoint supports two deletion modes:\n- Soft deletion (default): Marks the key as deleted but preserves its data\n- Permanent deletion: Completely removes all traces of the key from the database\n\nPermanent deletion is useful for regulatory compliance (e.g., GDPR), resolving hash collisions during migrations, or when you need to reuse the same key string in the future.",
        "operationId": "deleteKey",
        "x-speakeasy-name-override": "deleteKey",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysDeleteKeyRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysDeleteKeyResponseBody"
                }
              }
            },
            "description": "Successfully deleted key. The key will immediately fail verification in the current region, but it may take up to 30 seconds for deletion to propagate to all regions due to eventual consistency. After deletion, the key will no longer appear in key listings, and verification attempts will return code=NOT_FOUND. Soft-deleted keys (permanent=false) remain in the database but are marked as deleted, while permanently deleted keys are completely removed."
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal server error - Problem with database operations or cache invalidation"
          }
        }
      }
    },
    "/v2/keys.getKey": {
      "post": {
        "tags": [
          "keys"
        ],
        "summary": "Retrieve detailed information about an API key",
        "description": "Retrieves comprehensive information about a specific API key by its ID. This endpoint provides access to all key properties, metadata, permissions, and usage limits.\n\nThis is particularly useful for:\n- Displaying key details in administrative interfaces\n- Checking key configuration before making updates\n- Retrieving metadata associated with a key\n- Verifying permissions and role assignments\n- Checking expiration dates and usage limits\n\nWith appropriate permissions and if the key was created with the recoverable option, this endpoint can also return the complete plaintext key value, though this should be used with caution for security reasons.",
        "operationId": "getKey",
        "x-speakeasy-name-override": "getKey",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysGetKeyRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysGetKeyResponseBody"
                }
              }
            },
            "description": "Successfully retrieved key"
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal server error"
          }
        }
      }
    },
    "/v2/keys.createKey": {
      "post": {
        "tags": [
          "keys"
        ],
        "summary": "Create a new API key with customizable security features",
        "description": "Creates a new API key with configurable security properties, usage limits, and metadata. This endpoint generates a cryptographically secure key that you can distribute to your users for authenticating with your API.\n\nThe key is only returned once in the response - Unkey stores only a secure hash of the key, not the key itself. You must provide this key directly to your end user; it cannot be retrieved later (unless created with `recoverable: true`, which is less secure).\n\nKeys are associated with a specific API (via `apiId`), which helps isolate environments (dev/staging/prod) and prevents keys from being used across different services. Keys can be further configured with:\n- Optional prefixes for visual identification\n- Expiration dates for temporary access\n- Usage limits (credits) for consumption-based APIs\n- Rate limits for abuse prevention\n- Permissions and roles for granular access control\n- Metadata for storing context with the key\n\nBest practices include using environment-specific API IDs, meaningful prefixes, appropriate byte length for security needs, and avoiding storing keys in your databases.",
        "operationId": "createKey",
        "x-speakeasy-name-override": "createKey",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysCreateKeyRequestBody"
              },
              "examples": {
                "simple": {
                  "summary": "Basic key creation",
                  "value": {
                    "apiId": "api_1234567890abcdef",
                    "prefix": "prod"
                  }
                },
                "withMeta": {
                  "summary": "Key with user-specific metadata",
                  "value": {
                    "apiId": "api_1234567890abcdef",
                    "prefix": "prod",
                    "name": "User API Key",
                    "externalId": "user_12345",
                    "meta": {
                      "plan": "premium",
                      "features": {
                        "analytics": true,
                        "exports": true
                      },
                      "teamId": "team_abc123"
                    }
                  }
                },
                "withLimits": {
                  "summary": "Key with usage limits",
                  "value": {
                    "apiId": "api_1234567890abcdef",
                    "prefix": "prod",
                    "externalId": "user_12345",
                    "expires": 1735689600000,
                    "credits": {
                      "remaining": 1000,
                      "refill": {
                        "interval": "monthly",
                        "amount": 1000,
                        "refillDay": 1
                      }
                    },
                    "ratelimits": [
                      {
                        "name": "requests",
                        "limit": 100,
                        "duration": 60000
                      },
                      {
                        "name": "heavy_operations",
                        "limit": 10,
                        "duration": 3600000
                      }
                    ]
                  }
                },
                "withPermissions": {
                  "summary": "Key with access control",
                  "value": {
                    "apiId": "api_1234567890abcdef",
                    "prefix": "prod",
                    "externalId": "user_12345",
                    "permissions": [
                      "documents.read",
                      "documents.write",
                      "profile.view"
                    ],
                    "roles": [
                      "editor"
                    ]
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysCreateKeyResponseBody"
                },
                "examples": {
                  "standard": {
                    "summary": "Successfully created key",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "data": {
                        "keyId": "key_01H9TQP8NP8JN3X8HWSKPW43JE",
                        "key": "prod_f4cc2d765275c206b7d76ff0e92e583067c4e33603fb4055d7ba3031cd7ce36a"
                      }
                    }
                  }
                }
              }
            },
            "description": "Successfully created a new API key. The response includes both the keyId (for reference in your system) and the full key string. IMPORTANT: This is the only time the complete key is available - it cannot be retrieved later. You must securely provide this key to your end user immediately."
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal server error"
          }
        }
      }
    },
    "/v2/ratelimit.limit": {
      "post": {
        "tags": [
          "ratelimit"
        ],
        "summary": "Apply rate limiting to any identifier",
        "description": "Checks and enforces rate limits for any identifier in your application. This is the core rate limiting endpoint that provides flexible, namespace-based rate limiting for any entity in your system.\n\nUnlike API key-based rate limiting, this endpoint can be used to limit any identifiable entity:\n- Anonymous users by IP address\n- Authenticated users by user ID\n- Organizations by organization ID\n- API clients by client ID\n- Specific actions or resources by custom identifiers\n\nThe endpoint is designed for high-performance rate limiting with predictable behavior. It returns information about limit status, remaining capacity, and reset times that can be communicated to consumers of your API or service.\n\nFeatures:\n- Namespace-based organization for different limit types\n- Custom costs for variable-weight operations\n- Flexible time windows (1 second to 24 hours)\n- Override support for custom limits for specific identifiers\n- Consistent sliding window implementation\n\nImplementation tips:\n- Always check the 'success' field to determine if the request should proceed\n- Use the 'reset' time to implement intelligent client-side retry logic\n- Leverage the 'remaining' count to display usage information to users\n- Store the namespaceId after first use to avoid name lookups in high-volume scenarios\n- Consider using smaller durations for security-critical operations",
        "operationId": "ratelimit.limit",
        "x-speakeasy-name-override": "limit",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2RatelimitLimitRequestBody"
              },
              "examples": {
                "basic": {
                  "summary": "Basic rate limit check",
                  "value": {
                    "namespace": "api.requests",
                    "identifier": "user_abc123",
                    "limit": 100,
                    "duration": 60000
                  }
                },
                "ipLimit": {
                  "summary": "IP-based rate limiting",
                  "value": {
                    "namespace": "auth.login",
                    "identifier": "203.0.113.42",
                    "limit": 5,
                    "duration": 60000
                  }
                },
                "weightedCost": {
                  "summary": "Operation with variable cost",
                  "value": {
                    "namespace": "api.heavy_operations",
                    "identifier": "user_def456",
                    "limit": 50,
                    "duration": 3600000,
                    "cost": 5
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2RatelimitLimitResponseBody"
                },
                "examples": {
                  "allowed": {
                    "summary": "Request allowed",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "data": {
                        "limit": 100,
                        "remaining": 99,
                        "reset": 1714582980000,
                        "success": true
                      }
                    }
                  },
                  "limitReached": {
                    "summary": "Rate limit exceeded",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQY"
                      },
                      "data": {
                        "limit": 100,
                        "remaining": 0,
                        "reset": 1714582980000,
                        "success": false
                      }
                    }
                  },
                  "withOverride": {
                    "summary": "With custom override applied",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQZ"
                      },
                      "data": {
                        "limit": 1000,
                        "remaining": 995,
                        "reset": 1714582980000,
                        "success": true,
                        "overrideId": "ovr_2cGKbMxRyIzhCxo1Idjz8q"
                      }
                    }
                  }
                }
              }
            },
            "description": "Rate limit check completed. Even when the rate limit is exceeded, this endpoint returns HTTP 200 OK - you must check the 'success' field in the response to determine if the request is allowed. When success=false, the client should be prevented from proceeding with their request."
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal server error - An unexpected error occurred while processing the request. This could be due to database connectivity issues, validation errors not caught by the schema, or internal service problems. Check the error details and requestId for troubleshooting."
          }
        }
      }
    },
    "/v2/permissions.listRoles": {
      "post": {
        "tags": [
          "permissions"
        ],
        "summary": "List all roles in a workspace",
        "description": "Retrieves a paginated list of all roles defined in the workspace, including their assigned permissions. This endpoint is essential for role-based access control (RBAC) administration.\n\nRoles are collections of permissions that can be assigned to API keys, providing a convenient way to manage access control at scale. This endpoint allows you to:\n- View all available roles for assignment\n- Inspect which permissions are granted by each role\n- Build role management interfaces\n- Audit your RBAC configuration\n\nResults are paginated and sorted alphabetically by role name. Each role includes its complete set of assigned permissions.",
        "operationId": "listRoles",
        "x-speakeasy-name-override": "ListRoles",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2PermissionsListRolesRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2PermissionsListRolesResponseBody"
                }
              }
            },
            "description": "Successfully listed roles"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/v2/ratelimit.setOverride": {
      "post": {
        "tags": [
          "ratelimit"
        ],
        "summary": "Create or update a custom rate limit for specific identifiers",
        "description": "Creates a new or updates an existing rate limit override for specific identifiers within a namespace.\n\nOverrides allow you to implement special rate limiting rules that differ from the default limits. This is essential for:\n\n- Creating tiered rate limits for different customer segments\n- Implementing premium tiers with higher limits\n- Applying stricter limits to suspicious or abusive users\n- Setting emergency limits during system stress\n- Creating customized rate limiting policies\n\nWhen an override exists, it completely replaces the default rate limit for matching identifiers. The override takes effect immediately and will be applied to the very next rate limit check that matches the identifier pattern.\n\nWildcard patterns can be used to create powerful matching rules that apply to groups of identifiers without having to create individual overrides for each one.",
        "operationId": "ratelimit.setOverride",
        "x-speakeasy-name-override": "setOverride",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2RatelimitSetOverrideRequestBody"
              },
              "examples": {
                "premium": {
                  "summary": "Higher limit for premium user",
                  "value": {
                    "namespaceName": "api.requests",
                    "identifier": "premium_user_123",
                    "limit": 1000,
                    "duration": 60000
                  }
                },
                "wildcardPattern": {
                  "summary": "Pattern matching with wildcard",
                  "value": {
                    "namespaceId": "ns_1234567890abcdef",
                    "identifier": "premium_*",
                    "limit": 500,
                    "duration": 60000
                  }
                },
                "blockAbusive": {
                  "summary": "Block abusive user",
                  "value": {
                    "namespaceName": "api.requests",
                    "identifier": "abusive_user_456",
                    "limit": 0,
                    "duration": 3600000
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2RatelimitSetOverrideResponseBody"
                }
              }
            },
            "description": "Identity successfully deleted. The operation has permanently removed the identity from your workspace. Any API keys previously associated with this identity remain functional but no longer share resources through this identity. The externalId can now be reused for a new identity if needed."
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Error"
          }
        }
      }
    },
    "/v2/ratelimit.getOverride": {
      "post": {
        "tags": [
          "ratelimit"
        ],
        "summary": "Retrieve a specific rate limit override",
        "description": "Retrieves the details of a specific rate limit override by its identifier pattern.\n\nThis endpoint allows you to inspect the current configuration of an override, including:\n- The exact identifier pattern it matches\n- The custom limit value applied\n- The duration of the rate limit window\n- The namespace it belongs to\n\nThis is particularly useful for:\n- Auditing your rate limiting policies\n- Verifying override configurations\n- Retrieving settings before making modifications\n- Debugging rate limiting behavior\n\nThe identifier must match exactly as it was specified when creating the override, including any wildcard patterns.",
        "operationId": "ratelimit.getOverride",
        "x-speakeasy-name-override": "getOverride",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2RatelimitGetOverrideRequestBody"
              },
              "examples": {
                "byNameAndId": {
                  "summary": "Get specific override",
                  "value": {
                    "namespaceName": "api.requests",
                    "identifier": "premium_user_123"
                  }
                },
                "wildcardPattern": {
                  "summary": "Get wildcard pattern override",
                  "value": {
                    "namespaceId": "ns_1234567890abcdef",
                    "identifier": "premium_*"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2RatelimitGetOverrideResponseBody"
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Error"
          }
        }
      }
    },
    "/v2/ratelimit.listOverrides": {
      "post": {
        "tags": [
          "ratelimit"
        ],
        "summary": "List all rate limit overrides for a namespace",
        "description": "Retrieves a paginated list of all rate limit overrides defined for a specific namespace.\n\nThis endpoint is essential for:\n- Auditing your rate limiting policies\n- Reviewing all custom rate limit rules\n- Building administrative dashboards\n- Finding patterns in your override configurations\n- Managing and cleaning up overrides\n\nThe response includes detailed information about each override, including the identifier patterns, limits, and durations. For namespaces with many overrides, results are paginated and can be retrieved in chunks using the cursor parameter.",
        "operationId": "ratelimit.listOverrides",
        "x-speakeasy-name-override": "listOverrides",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2RatelimitListOverridesRequestBody"
              },
              "examples": {
                "byNamespaceName": {
                  "summary": "List all overrides by namespace name",
                  "value": {
                    "namespaceName": "api.requests",
                    "limit": 20
                  }
                },
                "byNamespaceId": {
                  "summary": "List overrides by namespace ID",
                  "value": {
                    "namespaceId": "ns_1234567890abcdef",
                    "limit": 50
                  }
                },
                "pagination": {
                  "summary": "Fetch next page of results",
                  "value": {
                    "namespaceId": "ns_1234567890abcdef",
                    "cursor": "cursor_eyJsYXN0SWQiOiJvdnJfM2RITGNOeVN6SnppRHlwMkpla2E5ciJ9"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2RatelimitListOverridesResponseBody"
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Error"
          }
        }
      }
    },
    "/v2/ratelimit.deleteOverride": {
      "post": {
        "tags": [
          "ratelimit"
        ],
        "summary": "Delete a rate limit override",
        "description": "Permanently removes a rate limit override from a namespace. Once deleted, the affected identifiers will immediately revert to using the default rate limits for that namespace.\n\nThis endpoint is useful for:\n- Removing temporary overrides that are no longer needed\n- Resetting entities back to standard rate limits\n- Cleaning up outdated rate limiting rules\n- Removing emergency rate limit adjustments\n- Correcting misconfigured overrides\n\nThe deletion operation is immediate and permanent - once an override is deleted, it cannot be recovered. If you need to reinstate an override after deletion, you must create it again using the setOverride endpoint.",
        "operationId": "ratelimit.deleteOverride",
        "x-speakeasy-name-override": "deleteOverride",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2RatelimitDeleteOverrideRequestBody"
              },
              "examples": {
                "specificOverride": {
                  "summary": "Delete specific identifier override",
                  "value": {
                    "namespaceName": "api.requests",
                    "identifier": "premium_user_123"
                  }
                },
                "wildcardPattern": {
                  "summary": "Delete wildcard pattern override",
                  "value": {
                    "namespaceId": "ns_1234567890abcdef",
                    "identifier": "premium_*"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2RatelimitDeleteOverrideResponseBody"
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Error"
          }
        }
      }
    },
    "/v2/identities.createIdentity": {
      "post": {
        "tags": [
          "identities"
        ],
        "summary": "Create a new identity for resource sharing across keys",
        "description": "Creates a new identity that can be associated with multiple API keys to enable resource sharing.\n\nIdentities are a powerful concept in Unkey that allow multiple API keys to share resources like rate limits and to be associated with the same entity (user, organization, etc.). This is essential for:\n\n- Implementing consistent rate limiting across multiple API keys\n- Associating multiple keys with the same user or organization\n- Sharing metadata across all keys for an entity\n- Enabling user-based analytics across multiple keys\n- Simplifying key management for multi-device or multi-service users\n\nWhen you create keys with the same externalId, they'll share rate limits and appear grouped in analytics. This enables scenarios like letting users generate multiple API keys for different devices while still treating them as a single entity for usage limits.\n\nThe identity concept creates a separation between your user entities and their authentication credentials (API keys), similar to how users can have multiple passwords or sessions.",
        "operationId": "identities.createIdentity",
        "x-speakeasy-name-override": "createIdentity",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2IdentitiesCreateIdentityRequestBody"
              },
              "examples": {
                "basic": {
                  "summary": "Basic identity creation",
                  "value": {
                    "externalId": "user_abc123"
                  }
                },
                "withMetadata": {
                  "summary": "Identity with user metadata",
                  "value": {
                    "externalId": "user_abc123",
                    "meta": {
                      "name": "Alice Smith",
                      "email": "alice@example.com",
                      "plan": "premium",
                      "accountCreated": "2023-01-15T08:30:00Z",
                      "region": "eu-west"
                    }
                  }
                },
                "withRatelimits": {
                  "summary": "Identity with shared rate limits",
                  "value": {
                    "externalId": "org_xyz456",
                    "meta": {
                      "name": "Acme Corporation",
                      "planTier": "enterprise"
                    },
                    "ratelimits": [
                      {
                        "name": "requests",
                        "limit": 10000,
                        "duration": 3600000
                      },
                      {
                        "name": "heavy_compute",
                        "limit": 100,
                        "duration": 86400000
                      }
                    ]
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2IdentitiesCreateIdentityResponseBody"
                },
                "examples": {
                  "success": {
                    "summary": "Successfully created identity",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "data": {
                        "identityId": "id_01H9TQP8NP8JN3X8HWSKPW43JE"
                      }
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "409": {
            "description": "Conflict - An identity with this externalId already exists. Each externalId must be unique within your workspace. This error occurs when you attempt to create an identity with an externalId that's already in use. To update an existing identity, use the updateIdentity endpoint instead. If you're implementing automatic identity creation, you may want to handle this error by falling back to getting the existing identity.",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ConflictErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Error"
          }
        }
      }
    },
    "/v2/identities.getIdentity": {
      "post": {
        "tags": [
          "identities"
        ],
        "summary": "Retrieve identity information",
        "description": "Retrieves detailed information about a specific identity by its Unkey ID or external ID.\n\nIdentities in Unkey represent entities in your system (users, organizations, etc.) that can be associated with multiple API keys. This endpoint provides access to:\n- Identity metadata that was stored during creation\n- Rate limiting configurations that apply across all keys for this identity\n- Mapping between your system's external IDs and Unkey's internal IDs\n\nThis endpoint is useful for:\n- Checking if an identity exists\n- Retrieving metadata associated with an identity\n- Viewing rate limit configurations\n- Finding the Unkey ID for an identity when you only have the external ID\n\nYou must provide either the identityId or externalId parameter to identify which identity to retrieve.",
        "operationId": "identities.getIdentity",
        "x-speakeasy-name-override": "getIdentity",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2IdentitiesGetIdentityRequestBody"
              },
              "examples": {
                "byIdentityId": {
                  "summary": "Retrieve by Unkey identity ID",
                  "value": {
                    "identityId": "id_1234567890abcdef"
                  }
                },
                "byExternalId": {
                  "summary": "Retrieve by external ID",
                  "value": {
                    "externalId": "user_abc123"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successfully retrieved the identity information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2IdentitiesGetIdentityResponseBody"
                },
                "examples": {
                  "standard": {
                    "summary": "Identity with metadata and rate limits",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "data": {
                        "id": "id_1234567890abcdef",
                        "externalId": "user_abc123",
                        "meta": {
                          "name": "Alice Smith",
                          "email": "alice@example.com",
                          "plan": "premium",
                          "companyId": "company_xyz"
                        },
                        "ratelimits": [
                          {
                            "name": "api_requests",
                            "limit": 1000,
                            "duration": 60000
                          },
                          {
                            "name": "heavy_operations",
                            "limit": 100,
                            "duration": 3600000
                          }
                        ]
                      }
                    }
                  }
                }
              }
            }
          },
          "400": {
            "description": "Bad request - Missing both identityId and externalId, or other validation issues",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden - Insufficient permissions to access this identity",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found - The specified identity doesn't exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v2/identities.deleteIdentity": {
      "post": {
        "tags": [
          "identities"
        ],
        "summary": "Delete an existing identity",
        "description": "Permanently removes an identity from your workspace. This operation cannot be undone.\n\nDeleting an identity has several important effects:\n- All metadata associated with the identity is permanently removed\n- Any rate limit history for this identity is cleared\n- The identity's externalId becomes available for reuse\n- Keys remain functional but lose their identity association\n\nImportant notes:\n- This operation does NOT delete or disable any API keys associated with this identity\n- After deletion, keys previously linked to this identity will function independently\n- Rate limits that were shared across keys via this identity will no longer be shared\n- The externalId can be reused immediately after deletion\n\nUse this endpoint for compliance with data deletion requirements, cleaning up test data, or when an entity (user, organization) is permanently removed from your system.",
        "operationId": "v2.identities.deleteIdentity",
        "x-speakeasy-name-override": "deleteIdentity",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2IdentitiesDeleteIdentityRequestBody"
              },
              "examples": {
                "byExternalId": {
                  "summary": "Delete by external ID",
                  "description": "Deleting using your system's identifier",
                  "value": {
                    "externalId": "user_abc123"
                  }
                },
                "byIdentityId": {
                  "summary": "Delete by Unkey identity ID",
                  "description": "Deleting using Unkey's internal identifier",
                  "value": {
                    "identityId": "id_01H9TQP8NP8JN3X8HWSKPW43JE"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2IdentitiesDeleteIdentityResponseBody"
                },
                "examples": {
                  "success": {
                    "summary": "Successful deletion",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      }
                    }
                  }
                }
              }
            },
            "description": "OK"
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/problem+json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Error"
          }
        }
      }
    },
    "/v2/permissions.createPermission": {
      "post": {
        "tags": [
          "permissions"
        ],
        "summary": "Delete a permission",
        "description": "Permanently removes a permission from the workspace. This endpoint is used when a permission is no longer needed or when cleaning up unused permissions.\n\nWhen a permission is deleted:\n- All direct assignments to API keys are removed\n- The permission is removed from any roles it was assigned to\n- The permission's name becomes available for reuse\n\nImportant: This operation cannot be undone, and it immediately affects all API keys and roles that had this permission assigned. Consider carefully before deleting permissions that are actively in use.",
        "operationId": "deletePermission",
        "x-speakeasy-name-override": "DeletePermission",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2PermissionsCreatePermissionRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2PermissionsCreatePermissionResponseBody"
                }
              }
            },
            "description": "Successfully created permission"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "409": {
            "description": "Conflict - permission with that name already exists",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConflictErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/v2/permissions.getPermission": {
      "post": {
        "tags": [
          "permissions"
        ],
        "summary": "Retrieve details about a specific permission",
        "description": "Retrieves detailed information about a specific permission by its ID. This endpoint allows you to inspect a permission's properties, including its name, description, and workspace association.\n\nThis is useful for:\n- Verifying a permission exists before assigning it\n- Retrieving permission details for display in administrative interfaces\n- Checking permission configuration before making updates\n- Building permission management tools\n\nPermissions are the fundamental building blocks of access control in Unkey's RBAC system, representing specific capabilities that can be granted to API keys either directly or through roles.",
        "operationId": "getPermission",
        "x-speakeasy-name-override": "GetPermission",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2PermissionsGetPermissionRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2PermissionsGetPermissionResponseBody"
                }
              }
            },
            "description": "Successfully retrieved permission"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/v2/permissions.listPermissions": {
      "post": {
        "tags": [
          "permissions"
        ],
        "summary": "List all permissions in a workspace",
        "description": "Retrieves a paginated list of all permissions defined in the workspace. This endpoint is essential for permission management and RBAC administration.\n\nPermissions are the fundamental building blocks of access control in Unkey, representing specific actions or capabilities that can be granted to API keys either directly or through roles.\n\nThis endpoint allows you to:\n- View all available permissions for assignment\n- Build permission management interfaces\n- Audit your RBAC configuration\n- Identify existing permissions before creating new ones\n\nResults are paginated and typically sorted alphabetically by permission name.",
        "operationId": "listPermissions",
        "x-speakeasy-name-override": "ListPermissions",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2PermissionsListPermissionsRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2PermissionsListPermissionsResponseBody"
                }
              }
            },
            "description": "Successfully listed permissions"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/v2/permissions.deleteRole": {
      "post": {
        "tags": [
          "permissions"
        ],
        "summary": "Delete a role",
        "description": "Permanently removes a role from the workspace. This endpoint is used when a role is no longer needed or needs to be replaced with a different role structure.\n\nWhen a role is deleted:\n- All keys that had this role assigned will lose the permissions granted by this role\n- The role will no longer appear in role listings\n- The role's name becomes available for reuse\n\nImportant: This operation cannot be undone, and it immediately affects all API keys that had this role assigned. Consider carefully before deleting roles that are actively in use by many keys.",
        "operationId": "deleteRole",
        "x-speakeasy-name-override": "DeleteRole",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2PermissionsDeleteRoleRequestBody"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2PermissionsDeleteRoleResponseBody"
                }
              }
            },
            "description": "Successfully deleted role"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "409": {
            "description": "Conflict - role with that name already exists",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConflictErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/v2/apis.createApi": {
      "post": {
        "tags": [
          "apis"
        ],
        "summary": "Create a new API namespace for organizing keys",
        "description": "Creates a new API namespace that serves as a container for related API keys.\n\nAPIs in Unkey provide important functionality:\n- They organize keys into logical groups for easier management\n- They isolate keys between different environments (dev/staging/production)\n- They enforce security boundaries between services or products\n- They provide a foundation for permission scoping and access control\n\nCommon use cases for creating separate APIs include:\n- Separating development, staging, and production environments\n- Isolating different services or microservices from each other\n- Creating boundaries between different products or teams\n- Implementing multi-tenant isolation for SaaS applications\n\nYou'll use the resulting API ID when creating keys to associate them with this API namespace. During key verification, you must provide the same API ID to ensure keys can't be used across different environments or services.",
        "operationId": "createApi",
        "x-speakeasy-name-override": "createApi",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2ApisCreateApiRequestBody"
              },
              "examples": {
                "production": {
                  "summary": "Production API",
                  "value": {
                    "name": "payment-service-production"
                  }
                },
                "staging": {
                  "summary": "Staging environment",
                  "value": {
                    "name": "payment-service-staging"
                  }
                },
                "serviceSpecific": {
                  "summary": "Service-specific API",
                  "value": {
                    "name": "analytics-service"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2ApisCreateApiResponseBody"
                },
                "examples": {
                  "success": {
                    "summary": "Successfully created API",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "data": {
                        "apiId": "api_2cGKbMxRjIzhCxo1IdjH3a"
                      }
                    }
                  }
                }
              }
            },
            "description": "Successfully created a new API namespace. The response includes the unique API ID that you'll need for creating keys within this namespace. This ID should be stored securely as it's required for all operations related to this API."
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal server error"
          }
        }
      }
    },
    "/v2/apis.deleteApi": {
      "post": {
        "tags": [
          "apis"
        ],
        "summary": "Delete an API and invalidate all its associated keys",
        "description": "Permanently deletes an API namespace and invalidates all keys associated with it.\n\nWARNING: This is a destructive operation with significant consequences:\n- All keys associated with this API will be invalidated immediately\n- Verification attempts for these keys will fail with code=NOT_FOUND\n- Historical analytics data for the API and its keys will be preserved\n- This action cannot be undone\n\nCommon reasons to delete an API include:\n- Removing test or development environments no longer needed\n- Retiring deprecated services or products\n- Cleaning up unused resources\n- Implementing security isolation after compromise\n\nBefore deletion, ensure that:\n- You have the correct API ID (check the environment/service)\n- You have migrated any needed keys to a new API\n- You have updated all client applications to use new keys\n- You have backed up any important metadata or analytics",
        "operationId": "deleteApi",
        "x-speakeasy-name-override": "deleteApi",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2ApisDeleteApiRequestBody"
              },
              "examples": {
                "basic": {
                  "summary": "Delete an API",
                  "value": {
                    "apiId": "api_VNcuGfVjUkrVcWJmda0A"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2ApisDeleteApiResponseBody"
                },
                "examples": {
                  "success": {
                    "summary": "Successful deletion",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      }
                    }
                  }
                }
              }
            },
            "description": "API successfully deleted. All keys associated with this API have been invalidated and will no longer work for verification. The API ID can no longer be used for any operations, and new keys cannot be created with this API ID. This operation is immediate and cannot be undone."
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal server error"
          }
        }
      }
    },
    "/v2/apis.getApi": {
      "post": {
        "tags": [
          "apis"
        ],
        "summary": "Retrieve information about an API namespace",
        "description": "Retrieves detailed information about a specific API namespace.\n\nThis endpoint is useful for:\n- Verifying an API exists before attempting to use it\n- Retrieving the name of an API when you only have its ID\n- Checking if you have access to a particular API\n- Confirming API details before performing operations on it\n\nThe information returned is minimal by design, as APIs are primarily organizational containers. Most of the valuable data lies in the keys associated with an API, which can be retrieved using the apis.listKeys endpoint.",
        "operationId": "getApi",
        "x-speakeasy-name-override": "getApi",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2ApisGetApiRequestBody"
              },
              "examples": {
                "basic": {
                  "summary": "Retrieve API by ID",
                  "value": {
                    "apiId": "api_1234"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2ApisGetApiResponseBody"
                },
                "examples": {
                  "standard": {
                    "summary": "API details response",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "data": {
                        "id": "api_1234567890abcdef",
                        "name": "payment-service-production"
                      }
                    }
                  }
                }
              }
            },
            "description": "Successfully retrieved API information. The response includes the API's unique identifier and its name. This confirms the API exists and provides its basic details."
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal server error"
          }
        }
      }
    },
    "/v2/apis.listKeys": {
      "post": {
        "tags": [
          "apis"
        ],
        "summary": "List all keys associated with an API namespace",
        "description": "Retrieves a paginated list of all API keys associated with a specific API namespace.\n\nThis endpoint is essential for:\n- Building admin dashboards for API key management\n- Auditing active keys for security reviews\n- Finding keys associated with specific users or organizations\n- Monitoring key usage and distribution\n- Identifying keys that need rotation or updates\n\nThe response includes detailed information about each key, including its metadata, permissions, and usage limits. For large APIs with many keys, results are paginated and can be filtered by externalId to find keys for specific users or entities.\n\nNote that for security reasons, the full key values are never returned unless specifically requested with decrypt=true, and then only for keys created with recoverable=true and when the caller has sufficient permissions.",
        "operationId": "listKeys",
        "x-speakeasy-name-override": "listKeys",
        "security": [
          {
            "rootKey": []
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2ApisListKeysRequestBody"
              },
              "examples": {
                "basicListing": {
                  "summary": "List all keys for an API",
                  "value": {
                    "apiId": "api_1234"
                  }
                },
                "filteredListing": {
                  "summary": "List keys for specific user",
                  "value": {
                    "apiId": "api_1234",
                    "externalId": "user_5bf93ab218e",
                    "limit": 50
                  }
                },
                "paginatedRequest": {
                  "summary": "Fetch next page of results",
                  "value": {
                    "apiId": "api_1234",
                    "cursor": "cursor_eyJsYXN0S2V5SWQiOiJrZXlfMjNld3MiLCJsYXN0Q3JlYXRlZEF0IjoxNjcyNTI0MjM0MDAwfQ=="
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2ApisListKeysResponseBody"
                },
                "examples": {
                  "standardResponse": {
                    "summary": "Successful key listing",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "data": [
                        {
                          "keyId": "key_1a2b3c4d5e6f",
                          "start": "prod_abc",
                          "name": "Production Admin Key",
                          "createdAt": 1671048264000,
                          "permissions": [
                            "admin.read",
                            "admin.write"
                          ],
                          "meta": {
                            "owner": "alice@example.com",
                            "department": "Engineering"
                          }
                        },
                        {
                          "keyId": "key_2b3c4d5e6f7g",
                          "start": "prod_def",
                          "name": "CI/CD Pipeline Key",
                          "createdAt": 1671135600000,
                          "permissions": [
                            "deploy.trigger",
                            "logs.read"
                          ]
                        }
                      ],
                      "pagination": {
                        "cursor": "cursor_eyJsYXN0S2V5SWQiOiJrZXlfMmIzYzRkNWU2ZjdnIiwibGFzdENyZWF0ZWRBdCI6MTY3MTEzNTYwMDAwMH0=",
                        "hasMore": true
                      }
                    }
                  }
                }
              }
            },
            "description": "Successfully retrieved the list of keys for this API. The response includes key details such as IDs, names, creation dates, and associated metadata. For security, the actual key values are not included unless specifically requested with decrypt=true. If there are more keys than the requested limit, the pagination object will include a cursor for fetching the next page and hasMore=true."
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not Found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal Server Error"
          }
        }
      }
    },
    "/v2/liveness": {
      "get": {
        "x-speakeasy-ignore": "true",
        "tags": [
          "liveness"
        ],
        "security": [],
        "operationId": "liveness",
        "description": "Checks if the Unkey API service is functioning correctly and ready to handle requests. This endpoint provides a simple health check mechanism that can be used by load balancers, monitoring tools, and orchestration systems to verify service availability.\n\nUnlike other endpoints, this one:\n- Does not require authentication\n- Has minimal processing overhead\n- Responds quickly with a simple status\n- Performs basic internal health verification\n\nBest practices for using this endpoint:\n- Include in automated monitoring systems\n- Use for health checks in container orchestration\n- Set appropriate alerting thresholds on failures\n- Implement exponential backoff when retrying after failures",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2LivenessResponseBody"
                },
                "examples": {
                  "healthy": {
                    "summary": "Healthy service",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "data": {
                        "message": "OK"
                      }
                    }
                  }
                }
              }
            },
            "description": "Service is healthy and ready to process requests. The response includes a simple 'OK' message indicating normal operation. Monitoring systems can use this as confirmation that the service is functioning properly."
          },
          "412": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PreconditionFailedErrorResponse"
                },
                "examples": {
                  "degraded": {
                    "summary": "Service in degraded state",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "error": {
                        "title": "Precondition Failed",
                        "detail": "Service is in a degraded state. Some functionality may be limited.",
                        "status": 412,
                        "type": "https://unkey.dev/errors/precondition-failed"
                      }
                    }
                  }
                }
              }
            },
            "description": "Service is operational but in a degraded state. Some functionality may be limited or running with reduced performance. While the core service is running, some dependent systems or features might be unavailable. This status suggests caution when using the service."
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                },
                "examples": {
                  "unhealthy": {
                    "summary": "Service unhealthy",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQY"
                      },
                      "error": {
                        "title": "Internal Server Error",
                        "detail": "The service is currently experiencing issues and may not be fully operational.",
                        "status": 500,
                        "type": "https://unkey.dev/errors/internal-server-error"
                      }
                    }
                  }
                }
              }
            },
            "description": "Service is unhealthy and unable to process requests properly. This indicates a significant issue with the service that requires attention. Clients should refrain from making other API calls as they are likely to fail. Monitoring systems should trigger alerts when receiving this response."
          }
        },
        "summary": "Check service health and availability"
      }
    },
    "/v2/keys.verifyKey": {
      "post": {
        "tags": [
          "keys"
        ],
        "security": [
          {
            "rootKey": []
          }
        ],
        "summary": "Verify an API key's validity and permissions",
        "description": "This is the core endpoint for authenticating and authorizing API key usage in your application. It checks if a key is valid, hasn't expired, has sufficient remaining credits, isn't rate limited, and has the required permissions.\n\nWhen a key is verified, several checks occur:\n- Key existence and format validation\n- Expiration check\n- Enabled/disabled status verification\n- Credits deduction (if configured)\n- Rate limit enforcement (if configured)\n- Permission verification (if requested)\n\nThis endpoint is designed for high-performance verification with global edge caching. Use it in your API authentication middleware to protect your endpoints. For high-volume applications, consider enabling async rate limiting for improved performance at the cost of slightly reduced accuracy.\n\nUnlike most other endpoints, this one does not require authentication with a root key.",
        "operationId": "verifyKey",
        "x-speakeasy-name-override": "verifyKey",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/V2KeysVerifyKeyRequestBody"
              },
              "examples": {
                "basic": {
                  "summary": "Basic verification",
                  "value": {
                    "apiId": "api_1234567890abcdef",
                    "key": "my_prefix_1234567890abcdef"
                  }
                },
                "withPermissions": {
                  "summary": "Verification with permission check",
                  "value": {
                    "apiId": "api_1234567890abcdef",
                    "key": "my_prefix_1234567890abcdef",
                    "permissions": {
                      "type": "and",
                      "permissions": [
                        "users.read",
                        "users.edit"
                      ]
                    }
                  }
                },
                "withRatelimits": {
                  "summary": "Verification with custom rate limits",
                  "value": {
                    "apiId": "api_1234567890abcdef",
                    "key": "my_prefix_1234567890abcdef",
                    "ratelimits": [
                      {
                        "name": "requests",
                        "cost": 1
                      },
                      {
                        "name": "heavy_operations",
                        "cost": 5
                      }
                    ]
                  }
                },
                "withAllOptions": {
                  "summary": "Comprehensive verification",
                  "value": {
                    "apiId": "api_1234567890abcdef",
                    "key": "my_prefix_1234567890abcdef",
                    "permissions": "admin.access",
                    "credits": {
                      "cost": 2
                    },
                    "ratelimits": [
                      {
                        "name": "api_calls",
                        "cost": 1
                      }
                    ],
                    "tags": [
                      "path=/api/resources",
                      "method=POST",
                      "ip=203.0.113.42"
                    ]
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/V2KeysVerifyKeyResponseBody"
                },
                "examples": {
                  "valid": {
                    "summary": "Valid key with full details",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "data": {
                        "valid": true,
                        "code": "VALID",
                        "keyId": "key_01H9TQP8NP8JN3X8HWSKPW43JE",
                        "externalId": "user_123456",
                        "meta": {
                          "plan": "premium",
                          "teamId": "team_abc123"
                        },
                        "ratelimits": [
                          {
                            "name": "requests",
                            "limit": 100,
                            "remaining": 99,
                            "reset": 1714582980000
                          }
                        ],
                        "permissions": [
                          "documents.read",
                          "documents.write"
                        ],
                        "roles": [
                          "editor"
                        ]
                      }
                    }
                  },
                  "invalid": {
                    "summary": "Invalid key (usage exceeded)",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "data": {
                        "valid": false,
                        "code": "USAGE_EXCEEDED",
                        "keyId": "key_01H9TQP8NP8JN3X8HWSKPW43JE"
                      }
                    }
                  },
                  "ratelimited": {
                    "summary": "Rate limited key",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "data": {
                        "valid": false,
                        "code": "RATE_LIMITED",
                        "keyId": "key_01H9TQP8NP8JN3X8HWSKPW43JE",
                        "ratelimits": [
                          {
                            "name": "requests",
                            "limit": 100,
                            "remaining": 0,
                            "reset": 1714582980000
                          }
                        ]
                      }
                    }
                  },
                  "insufficientPermissions": {
                    "summary": "Missing required permissions",
                    "value": {
                      "meta": {
                        "requestId": "req_01H9TQPP77V5E48E9SH0BG0ZQX"
                      },
                      "data": {
                        "valid": false,
                        "code": "INSUFFICIENT_PERMISSIONS",
                        "keyId": "key_01H9TQP8NP8JN3X8HWSKPW43JE",
                        "permissions": [
                          "documents.read"
                        ]
                      }
                    }
                  }
                }
              }
            },
            "description": "Verification result. Note that even invalid keys return a 200 status code - you must check the 'valid' field in the response to determine if the key is valid. This design allows your application to handle different failure reasons (expired, rate limited, etc.) differently while maintaining a consistent API response structure."
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BadRequestErrorResponse"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UnauthorizedErrorResponse"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ForbiddenErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NotFoundErrorResponse"
                }
              }
            }
          },
          "500": {
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InternalServerErrorResponse"
                }
              }
            },
            "description": "Internal server error"
          }
        }
      }
    }
  }
}
