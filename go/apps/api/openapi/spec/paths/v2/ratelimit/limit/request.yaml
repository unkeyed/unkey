Request:
  required: true
  content:
    application/json:
      schema:
        "$ref": "#/V2RatelimitLimitRequestBody"
      examples:
        basic:
          summary: Basic rate limit check
          value:
            namespace: api.requests
            identifier: user_abc123
            limit: 100
            duration: 60000
        ipLimit:
          summary: IP-based rate limiting
          value:
            namespace: auth.login
            identifier: 203.0.113.42
            limit: 5
            duration: 60000
        weightedCost:
          summary: Operation with variable cost
          value:
            namespace: api.heavy_operations
            identifier: user_def456
            limit: 50
            duration: 3600000
            cost: 5

V2RatelimitLimitRequestBody:
  type: object
  additionalProperties: false
  properties:
    namespace:
      type: string
      minLength: 1
      maxLength: 255
      pattern: "^[a-zA-Z][a-zA-Z0-9_./-]*$"
      description: |
        Identifies the rate limit category using hierarchical naming for organization and monitoring.
        Namespaces must start with a letter and can contain letters, numbers, underscores, dots, slashes, or hyphens.
        Use descriptive, hierarchical names like 'auth.login', 'api.requests', or 'media.uploads' for clear categorization.
        Namespaces must be unique within your workspace and support segmentation of different API operations.
        Consistent naming conventions across your application improve monitoring and debugging capabilities.
      example: sms.sign_up
    cost:
      type: integer
      format: int64
      minimum: 0
      maximum: 1000
      default: 1
      description: |
        Sets how much of the rate limit quota this request consumes, enabling weighted rate limiting.
        Use higher values for resource-intensive operations and 0 for tracking without limiting.
        When accumulated cost exceeds the limit within the duration window, subsequent requests are rejected.
        Essential for implementing fair usage policies and preventing resource abuse through expensive operations.
      example: 5
    duration:
      type: integer
      format: int64
      minimum: 1000
      maximum: 2592000000
      description: |
        Sets the rate limit window duration in milliseconds after which the counter resets.
        Shorter durations enable faster recovery but may be less effective against sustained abuse.
        Common values include 60000 (1 minute), 3600000 (1 hour), and 86400000 (24 hours).
        Balance user experience with protection needs when choosing window sizes.
      example: 60000
    identifier:
      type: string
      minLength: 1
      maxLength: 255
      pattern: "^[a-zA-Z0-9_.:/-]+$"
      description: |
        Defines the scope of rate limiting by identifying the entity being limited.
        Use user IDs for per-user limits, IP addresses for anonymous limiting, or API key IDs for per-key limits.
        Accepts letters, numbers, underscores, dots, colons, slashes, and hyphens for flexible identifier formats.
        The same identifier can be used across different namespaces to apply multiple rate limit types.
        Choose identifiers that provide appropriate granularity for your rate limiting strategy.
      example: "user_12345"
    limit:
      type: integer
      format: int64
      minimum: 1
      maximum: 1000000
      description: |
        Sets the maximum operations allowed within the duration window before requests are rejected.
        When this limit is reached, subsequent requests fail with `RATE_LIMITED` until the window resets.
        Balance user experience with resource protection when setting limits for different user tiers.
        Consider system capacity, business requirements, and fair usage policies in limit determination.
      example: 1000
  required:
    - namespace
    - identifier
    - limit
    - duration