// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/oapi-codegen/nullable"
	"github.com/oapi-codegen/runtime"
)

const (
	RootKeyScopes = "rootKey.Scopes"
)

// Defines values for KeyCreditsRefillInterval.
const (
	KeyCreditsRefillIntervalDaily   KeyCreditsRefillInterval = "daily"
	KeyCreditsRefillIntervalMonthly KeyCreditsRefillInterval = "monthly"
)

// Defines values for KeysGetKeyResponseDataCreditsRefillInterval.
const (
	KeysGetKeyResponseDataCreditsRefillIntervalDaily   KeysGetKeyResponseDataCreditsRefillInterval = "daily"
	KeysGetKeyResponseDataCreditsRefillIntervalMonthly KeysGetKeyResponseDataCreditsRefillInterval = "monthly"
)

// Defines values for KeysUpdateRemainingResponseDataRefillSettingsInterval.
const (
	KeysUpdateRemainingResponseDataRefillSettingsIntervalDaily   KeysUpdateRemainingResponseDataRefillSettingsInterval = "daily"
	KeysUpdateRemainingResponseDataRefillSettingsIntervalMonthly KeysUpdateRemainingResponseDataRefillSettingsInterval = "monthly"
	KeysUpdateRemainingResponseDataRefillSettingsIntervalNever   KeysUpdateRemainingResponseDataRefillSettingsInterval = "never"
	KeysUpdateRemainingResponseDataRefillSettingsIntervalWeekly  KeysUpdateRemainingResponseDataRefillSettingsInterval = "weekly"
)

// Defines values for KeysVerifyKeyResponseDataCode.
const (
	DISABLED                KeysVerifyKeyResponseDataCode = "DISABLED"
	EXPIRED                 KeysVerifyKeyResponseDataCode = "EXPIRED"
	FORBIDDEN               KeysVerifyKeyResponseDataCode = "FORBIDDEN"
	INSUFFICIENTPERMISSIONS KeysVerifyKeyResponseDataCode = "INSUFFICIENT_PERMISSIONS"
	NOTFOUND                KeysVerifyKeyResponseDataCode = "NOT_FOUND"
	RATELIMITED             KeysVerifyKeyResponseDataCode = "RATE_LIMITED"
	UNAUTHORIZED            KeysVerifyKeyResponseDataCode = "UNAUTHORIZED"
	USAGEEXCEEDED           KeysVerifyKeyResponseDataCode = "USAGE_EXCEEDED"
	VALID                   KeysVerifyKeyResponseDataCode = "VALID"
)

// Defines values for V2KeysCreateKeyRequestBodyCreditsRefillInterval.
const (
	V2KeysCreateKeyRequestBodyCreditsRefillIntervalDaily   V2KeysCreateKeyRequestBodyCreditsRefillInterval = "daily"
	V2KeysCreateKeyRequestBodyCreditsRefillIntervalMonthly V2KeysCreateKeyRequestBodyCreditsRefillInterval = "monthly"
)

// Defines values for V2KeysUpdateKeyRequestBodyCreditsRefillInterval.
const (
	Daily   V2KeysUpdateKeyRequestBodyCreditsRefillInterval = "daily"
	Monthly V2KeysUpdateKeyRequestBodyCreditsRefillInterval = "monthly"
)

// Defines values for V2KeysVerifyKeyRequestBodyPermissions1Type.
const (
	And V2KeysVerifyKeyRequestBodyPermissions1Type = "and"
	Or  V2KeysVerifyKeyRequestBodyPermissions1Type = "or"
)

// ApisCreateApiResponseData defines model for ApisCreateApiResponseData.
type ApisCreateApiResponseData struct {
	// ApiId The unique identifier for the newly created API (begins with 'api_'). This ID is used in all subsequent operations related to this API, including key creation, key verification, and API management. Store this ID securely as it's required when creating keys within this API namespace.
	ApiId string `json:"apiId"`
}

// ApisGetApiResponseData defines model for ApisGetApiResponseData.
type ApisGetApiResponseData struct {
	// Id The unique identifier of the API (begins with 'api_'). This ID is used in all operations related to this API, including key creation, key verification, and API management.
	Id string `json:"id"`

	// Name The name of the API as specified during creation. This is an internal identifier used for organization and is not shown to end users. The name helps identify the purpose or environment of this API.
	Name string `json:"name"`
}

// ApisListKeysResponseData defines model for ApisListKeysResponseData.
type ApisListKeysResponseData = []KeyResponse

// BadRequestErrorDetails defines model for BadRequestErrorDetails.
type BadRequestErrorDetails struct {
	// Detail A human-readable explanation specific to this occurrence of the problem. This provides detailed information about what went wrong and potential remediation steps. The message is intended to be helpful for developers troubleshooting the issue.
	Detail string `json:"detail"`

	// Errors List of individual validation errors that occurred in the request. Each error provides specific details about what failed validation, where the error occurred in the request, and suggestions for fixing it. This granular information helps developers quickly identify and resolve multiple issues in a single request without having to make repeated API calls.
	Errors []ValidationError `json:"errors"`

	// Instance A URI reference that identifies the specific occurrence of the problem. This can be used to look up additional information about this specific error instance in logs or error tracking systems, and is particularly useful when reporting issues to support.
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code that corresponds to this error. This will match the status code in the HTTP response. Common codes include 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 409 (Conflict), and 500 (Internal Server Error).
	Status int `json:"status"`

	// Title A short, human-readable summary of the problem type. This is a concise, fixed string that categorizes the error and remains consistent between occurrences of the same error type. It provides a quick way to identify the category of error.
	Title string `json:"title"`

	// Type A URI reference to human-readable documentation for the error. This link points to detailed documentation about this specific error type, including possible causes and solutions. It's designed to help developers understand and resolve the issue.
	Type string `json:"type"`
}

// BadRequestErrorResponse Error response for invalid requests that cannot be processed due to client-side errors. This typically occurs when request parameters are missing, malformed, or fail validation rules. The response includes detailed information about the specific errors in the request, including the location of each error and suggestions for fixing it. When receiving this error, check the 'errors' array in the response for specific validation issues that need to be addressed before retrying.
type BadRequestErrorResponse struct {
	// Error Extended error details specifically for bad request (400) errors. This builds on the BaseError structure by adding an array of individual validation errors that provide specific information about each validation failure in the request. This is particularly useful for requests with multiple fields that might have different validation issues simultaneously.
	Error BadRequestErrorDetails `json:"error"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// BaseError Standard error structure that provides detailed information about errors encountered during API operations. This follows a problem details format that includes both machine-readable error codes and human-readable explanations. All error responses in the API include this structure to provide consistent, actionable error information.
type BaseError struct {
	// Detail A human-readable explanation specific to this occurrence of the problem. This provides detailed information about what went wrong and potential remediation steps. The message is intended to be helpful for developers troubleshooting the issue.
	Detail string `json:"detail"`

	// Instance A URI reference that identifies the specific occurrence of the problem. This can be used to look up additional information about this specific error instance in logs or error tracking systems, and is particularly useful when reporting issues to support.
	Instance *string `json:"instance,omitempty"`

	// Status HTTP status code that corresponds to this error. This will match the status code in the HTTP response. Common codes include 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 409 (Conflict), and 500 (Internal Server Error).
	Status int `json:"status"`

	// Title A short, human-readable summary of the problem type. This is a concise, fixed string that categorizes the error and remains consistent between occurrences of the same error type. It provides a quick way to identify the category of error.
	Title string `json:"title"`

	// Type A URI reference to human-readable documentation for the error. This link points to detailed documentation about this specific error type, including possible causes and solutions. It's designed to help developers understand and resolve the issue.
	Type string `json:"type"`
}

// ConflictErrorResponse Error response for conflicts with the current state of a resource. This typically occurs when trying to create a resource that already exists (like an identity with a duplicate externalId) or when performing an operation that conflicts with the resource's current state. When receiving this error, the request should be modified to resolve the conflict before retrying, or a different operation should be used instead.
type ConflictErrorResponse struct {
	// Error Standard error structure that provides detailed information about errors encountered during API operations. This follows a problem details format that includes both machine-readable error codes and human-readable explanations. All error responses in the API include this structure to provide consistent, actionable error information.
	Error BaseError `json:"error"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// ForbiddenErrorResponse Error response when the caller is authenticated but lacks permission to perform the requested operation. This occurs when:
//
// - The root key doesn't have the required permissions for the operation
// - The caller is trying to access resources from a different workspace
// - The caller is attempting to access another user's resources
// - The operation violates a policy restriction
//
// Unlike Unauthorized (401) which indicates authentication issues, Forbidden (403) indicates authorization problems for an authenticated caller.
//
// To fix this error:
// 1. Check the permissions assigned to your root key in the Unkey dashboard
// 2. Verify you're operating within the correct workspace
// 3. Ensure you have the necessary scope to access the requested resource
// 4. Request additional permissions if needed from your workspace administrator
//
// Permission patterns in Unkey follow a hierarchical structure:
// - 'resource.*' grants all permissions for a resource
// - 'resource.read' grants read-only access
// - 'resource.write' grants write access
//
// Common permission requirements for endpoints include:
// - keys.create - For creating new API keys
// - keys.read - For retrieving key information
// - keys.update - For modifying existing keys
// - keys.delete - For removing keys
// - apis.* - For managing API namespaces
type ForbiddenErrorResponse struct {
	// Error Standard error structure that provides detailed information about errors encountered during API operations. This follows a problem details format that includes both machine-readable error codes and human-readable explanations. All error responses in the API include this structure to provide consistent, actionable error information.
	Error BaseError `json:"error"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// IdentitiesCreateIdentityResponseData defines model for IdentitiesCreateIdentityResponseData.
type IdentitiesCreateIdentityResponseData struct {
	// IdentityId The unique identifier for this identity in Unkey's system (begins with 'id_').
	//
	// This ID is generated automatically and used internally by Unkey to reference this identity. While you typically don't need to store this value (your externalId is sufficient), it can be useful to record it for:
	// - Debugging purposes
	// - Advanced API operations
	// - Integration with Unkey's analytics
	//
	// Unlike externalId which comes from your system, this ID is guaranteed unique across all Unkey workspaces.
	IdentityId string `json:"identityId"`
}

// IdentitiesGetIdentityResponseData defines model for IdentitiesGetIdentityResponseData.
type IdentitiesGetIdentityResponseData struct {
	// ExternalId The external identifier for this identity in your system. This is the ID you provided during identity creation.
	ExternalId string `json:"externalId"`

	// Id The unique identifier for this identity in Unkey's system (begins with 'id_').
	Id string `json:"id"`

	// Meta Custom metadata associated with this identity. This can include any JSON-serializable data you stored with the identity during creation or updates.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Ratelimits Rate limits associated with this identity. These limits are shared across all API keys linked to this identity, providing consistent rate limiting regardless of which key is used.
	Ratelimits *[]Ratelimit `json:"ratelimits,omitempty"`
}

// IdentitiesListIdentitiesResponseData List of identities matching the specified criteria.
type IdentitiesListIdentitiesResponseData = []Identity

// IdentitiesUpdateIdentityResponseData defines model for IdentitiesUpdateIdentityResponseData.
type IdentitiesUpdateIdentityResponseData struct {
	// ExternalId The external identifier for this identity in your system.
	ExternalId string `json:"externalId"`

	// Id The unique identifier for this identity in Unkey's system (begins with 'id_').
	Id string `json:"id"`

	// Meta Custom metadata associated with this identity after the update.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Ratelimits Rate limits associated with this identity after the update.
	Ratelimits *[]Ratelimit `json:"ratelimits,omitempty"`
}

// Identity defines model for Identity.
type Identity struct {
	// ExternalId External identity ID
	ExternalId string `json:"externalId"`

	// Id Identity ID
	Id string `json:"id"`

	// Meta Identity metadata
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Ratelimits Identity ratelimits
	Ratelimits []Ratelimit `json:"ratelimits"`
}

// InternalServerErrorResponse Error response for unexpected server-side issues that prevented the request from being processed correctly. This is typically caused by problems with the service infrastructure, database connectivity issues, unexpected exceptions, or service failures. When receiving this error, clients should implement appropriate retry strategies with backoff and report the issue if it persists. The requestId in the meta object is essential for troubleshooting and should be included in any support inquiries.
type InternalServerErrorResponse struct {
	// Error Standard error structure that provides detailed information about errors encountered during API operations. This follows a problem details format that includes both machine-readable error codes and human-readable explanations. All error responses in the API include this structure to provide consistent, actionable error information.
	Error BaseError `json:"error"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// KeyCredits Remaining requests for this key
type KeyCredits struct {
	Refill *KeyCreditsRefill `json:"refill,omitempty"`

	// Remaining Remaining credits
	Remaining int `json:"remaining"`
}

// KeyCreditsRefill defines model for KeyCreditsRefill.
type KeyCreditsRefill struct {
	// Amount Amount to refill
	Amount int `json:"amount"`

	// Interval Refill interval
	Interval KeyCreditsRefillInterval `json:"interval"`

	// LastRefillAt Last time the key was refilled (Unix timestamp)
	LastRefillAt *int64 `json:"lastRefillAt,omitempty"`

	// RefillDay Day of the month when refill happens (for monthly interval)
	RefillDay *int `json:"refillDay,omitempty"`
}

// KeyCreditsRefillInterval Refill interval
type KeyCreditsRefillInterval string

// KeyResponse defines model for KeyResponse.
type KeyResponse struct {
	// CreatedAt When the key was created (Unix timestamp)
	CreatedAt int64 `json:"createdAt"`

	// Credits Remaining requests for this key
	Credits *KeyCredits `json:"credits,omitempty"`

	// Environment Optional environment tag
	Environment *string `json:"environment,omitempty"`

	// Expires When the key expires (Unix timestamp)
	Expires  *int64    `json:"expires,omitempty"`
	Identity *Identity `json:"identity,omitempty"`

	// KeyId The key ID
	KeyId string `json:"keyId"`

	// Meta Optional metadata for the key
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Name Optional name for the key
	Name *string `json:"name,omitempty"`

	// Permissions Permissions assigned to this key
	Permissions *[]string `json:"permissions,omitempty"`

	// Plaintext The decrypted key value (only included if decrypt=true)
	Plaintext *string `json:"plaintext,omitempty"`

	// Ratelimits Rate limits applied to this key
	Ratelimits *[]RatelimitResponse `json:"ratelimits,omitempty"`

	// Roles Roles assigned to this key
	Roles *[]string `json:"roles,omitempty"`

	// Start The first few characters of the key
	Start string `json:"start"`

	// UpdatedAt When the key was last updated (Unix timestamp)
	UpdatedAt *int64 `json:"updatedAt,omitempty"`
}

// KeyWhoamiData defines model for KeyWhoamiData.
type KeyWhoamiData struct {
	// CreatedAt The timestamp in milliseconds when the key was created
	CreatedAt int64 `json:"createdAt"`

	// Enabled Whether the key is enabled and can be used
	Enabled bool `json:"enabled"`

	// Environment The environment the key is associated with (e.g., production, staging, development)
	Environment nullable.Nullable[string] `json:"environment,omitempty"`

	// Id The unique identifier of the key
	Id string `json:"id"`

	// Identity The identity object associated with the key (null if no identity is associated)
	Identity nullable.Nullable[struct {
		// ExternalId The external identity ID associated with the key (e.g., user ID in your system)
		ExternalId string `json:"externalId"`

		// Id The unique identity ID associated with the key
		Id string `json:"id"`
	}] `json:"identity,omitempty"`

	// Meta Custom metadata associated with the key (null if no metadata is present)
	Meta nullable.Nullable[map[string]interface{}] `json:"meta,omitempty"`

	// Name The human-readable name of the key (optional)
	Name nullable.Nullable[string] `json:"name,omitempty"`

	// Remaining The remaining number of requests for the key (null means unlimited)
	Remaining nullable.Nullable[int64] `json:"remaining,omitempty"`
}

// KeysCreateKeyResponseData defines model for KeysCreateKeyResponseData.
type KeysCreateKeyResponseData struct {
	// Key The full generated API key that should be securely provided to your user. SECURITY WARNING: This is the only time you'll receive the complete key - Unkey only stores a securely hashed version. Never log or store this value in your own systems; provide it directly to your end user via secure channels. After this API call completes, this value cannot be retrieved again (unless created with recoverable=true).
	Key string `json:"key"`

	// KeyId The unique identifier for this key in Unkey's system. This is NOT the actual API key, but a reference ID used for management operations like updating or deleting the key. Store this ID in your database to reference the key later. This ID is not sensitive and can be logged or displayed in dashboards.
	KeyId string `json:"keyId"`
}

// KeysDeleteKeyResponseData Empty response object. A successful response indicates the key was deleted successfully. Deletion triggers cache invalidation across all regions, but it may take up to 30 seconds for the deletion to be fully propagated due to eventual consistency. During this propagation period, some verification attempts might still succeed in certain regions.
type KeysDeleteKeyResponseData = map[string]interface{}

// KeysGetKeyResponseData defines model for KeysGetKeyResponseData.
type KeysGetKeyResponseData struct {
	// ApiId The ID of the API this key belongs to.
	ApiId *string `json:"apiId,omitempty"`

	// CreatedAt Unix timestamp (in milliseconds) when the key was created.
	CreatedAt int64 `json:"createdAt"`

	// Credits Usage limits configuration for this key. Credits provide a way to limit the number of times a key can be used before becoming invalid. Unlike ratelimits, credits are globally consistent (using database transactions) providing 100% accuracy at the cost of slightly higher latency. Ideal for monetization, usage quotas, or strict limits that must not be exceeded. See the 'refill' field for automatic replenishment options.
	Credits *struct {
		// Refill Configuration for automatic credit refills.
		Refill *struct {
			// Amount Number of credits added during each refill.
			Amount int `json:"amount"`

			// Interval How often the credits are automatically refilled.
			Interval KeysGetKeyResponseDataCreditsRefillInterval `json:"interval"`

			// LastRefillAt Unix timestamp (in milliseconds) when credits were last refilled.
			LastRefillAt *int64 `json:"lastRefillAt,omitempty"`

			// RefillDay For monthly refills, the day of month when refills occur.
			RefillDay *int `json:"refillDay,omitempty"`
		} `json:"refill,omitempty"`

		// Remaining The number of times this key can still be used before becoming invalid.
		Remaining *int32 `json:"remaining,omitempty"`
	} `json:"credits,omitempty"`

	// Enabled Whether the key is currently active. Disabled keys will fail verification with code=DISABLED. Toggling this allows you to temporarily suspend access without deleting the key, which is useful for maintenance, account freezing, or debugging. Can be updated using the updateKey endpoint.
	Enabled bool `json:"enabled"`

	// Expires Unix timestamp (in milliseconds) when this key will automatically expire. If null, the key has no expiration.
	Expires *int64 `json:"expires,omitempty"`

	// ExternalId Your user's unique identifier, creating a link between Unkey and your system. This ID is returned during verification so you can identify which customer/entity is making the request without performing additional database lookups. Use consistent identifiers that match your primary user/tenant identifiers for seamless integration.
	ExternalId *string `json:"externalId,omitempty"`

	// Id The unique identifier of the key in Unkey's system.
	Id string `json:"id"`

	// Identity The identity associated with this key, if any. Identities allow resource sharing (like ratelimits) across multiple keys belonging to the same user/entity. This enables scenarios like issuing separate keys for different devices/services while maintaining global usage limits for the user. An identity's externalId typically matches your user ID or tenant ID.
	Identity *struct {
		// ExternalId Your identifier for this identity in your system.
		ExternalId string `json:"externalId"`

		// Id The unique ID of the identity in Unkey's system.
		Id string `json:"id"`

		// Meta Additional metadata associated with this identity.
		Meta *map[string]interface{} `json:"meta,omitempty"`
	} `json:"identity,omitempty"`

	// Meta Arbitrary JSON metadata associated with this key. This can include additional context like subscription plans, feature flags, or any custom data. Metadata is stored as-is and returned during verification, allowing you to access important information without additional database queries. Consider including data relevant to authorization decisions, usage tracking, and user context.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Name A descriptive name for the key for internal reference. Shown in dashboards and logs but never exposed to end users.
	Name *string `json:"name,omitempty"`

	// Permissions List of permission names directly assigned to this key.
	Permissions *[]string `json:"permissions,omitempty"`

	// Plaintext The full API key in plaintext. Only included when 'decrypt' is true and the key was created with 'recoverable: true'. SECURITY RISK: This field contains the actual secret key which should never be logged, stored in databases, or exposed in any frontend code. It should only be displayed directly to users through secure channels. Most applications should avoid setting decrypt=true unless absolutely necessary.
	Plaintext *string `json:"plaintext,omitempty"`

	// Ratelimits Array of ratelimits applied to this key. Multiple named ratelimits can control different aspects of key usage. For example, a 'requests' ratelimit might control overall API calls while a separate 'computations' limit manages access to resource-intensive operations. Ratelimits are optimized for performance and typically add minimal latency to verifications. They can be shared across keys through identities.
	Ratelimits *[]struct {
		// Async Whether this ratelimit uses fast (async=true) or consistent (async=false) mode. Fast mode has lower latency but less accuracy.
		Async *bool `json:"async,omitempty"`

		// Duration Duration of the ratelimit window in milliseconds.
		Duration int32 `json:"duration"`

		// Limit Maximum number of operations allowed within the time window.
		Limit int32 `json:"limit"`

		// Name Identifier for this ratelimit.
		Name string `json:"name"`
	} `json:"ratelimits,omitempty"`

	// Roles List of role names assigned to this key. Roles are collections of permissions.
	Roles *[]string `json:"roles,omitempty"`

	// Start The first few characters of the key to visually identify it without exposing the full key. Used in dashboards and logs to help users recognize which key is being used without revealing sensitive information. Typically includes the prefix if one was specified.
	Start string `json:"start"`

	// UpdatedAt Unix timestamp (in milliseconds) when the key was last updated.
	UpdatedAt *int64 `json:"updatedAt,omitempty"`

	// WorkspaceId The ID of the workspace that owns this key.
	WorkspaceId string `json:"workspaceId"`
}

// KeysGetKeyResponseDataCreditsRefillInterval How often the credits are automatically refilled.
type KeysGetKeyResponseDataCreditsRefillInterval string

// KeysUpdateKeyResponseData Empty response object by design. A successful response indicates the key was updated successfully. The endpoint doesn't return the updated key to reduce response size and avoid exposing sensitive information. Changes may take up to 30 seconds to propagate to all regions due to cache invalidation delays. If you need the updated key state, use a subsequent call to keys.getKey.
type KeysUpdateKeyResponseData = map[string]interface{}

// KeysUpdateRemainingResponseData defines model for KeysUpdateRemainingResponseData.
type KeysUpdateRemainingResponseData struct {
	// RefillSettings If the key has automatic refill settings, they are included here with their current configuration. If null, the key does not have automatic refills configured (either because they were removed with overwriteRefillSettings=true or because they were never set up). Refill settings create subscription-like behavior where the key automatically receives new credits on a regular schedule.
	RefillSettings nullable.Nullable[struct {
		// Amount The number of credits added during each automatic refill. This is the quota that gets renewed each period, making it useful for implementing subscription tiers with different usage limits (e.g., Basic=100/month, Pro=1000/month).
		Amount *int64 `json:"amount,omitempty"`

		// Interval The interval at which credits are automatically refilled. 'daily' resets at midnight UTC, 'weekly' resets on the specified weekday (where 1=Monday, 7=Sunday), 'monthly' resets on the specified day of month, and 'never' means no automatic refills occur.
		Interval *KeysUpdateRemainingResponseDataRefillSettingsInterval `json:"interval,omitempty"`

		// LastRefillAt The timestamp when the last automatic refill occurred. This helps track when credits were last replenished and understand when the next refill will occur. The timestamp is in ISO 8601 format (YYYY-MM-DDTHH:MM:SSZ).
		LastRefillAt *time.Time `json:"lastRefillAt,omitempty"`

		// RefillDay For monthly refills, the day of the month on which to refill (1-31). For weekly refills, the day of the week (1=Monday, 7=Sunday). This allows aligning refills with billing cycles, subscription periods, or other business-relevant schedules.
		RefillDay *int `json:"refillDay,omitempty"`
	}] `json:"refillSettings,omitempty"`

	// Remaining The updated remaining credits value for the key after the operation completes. This reflects the exact value that was set in the request. A value of -1 indicates unlimited usage, meaning the key can be used an unlimited number of times without being rejected for credit exhaustion. This field is guaranteed to be present in every response.
	Remaining int64 `json:"remaining"`
}

// KeysUpdateRemainingResponseDataRefillSettingsInterval The interval at which credits are automatically refilled. 'daily' resets at midnight UTC, 'weekly' resets on the specified weekday (where 1=Monday, 7=Sunday), 'monthly' resets on the specified day of month, and 'never' means no automatic refills occur.
type KeysUpdateRemainingResponseDataRefillSettingsInterval string

// KeysVerifyKeyResponseData defines model for KeysVerifyKeyResponseData.
type KeysVerifyKeyResponseData struct {
	// Code A machine-readable code indicating the verification status or failure reason. Values: VALID (key is valid), NOT_FOUND (key doesn't exist), FORBIDDEN (key exists but belongs to a different API), USAGE_EXCEEDED (key has no more credits), RATE_LIMITED (key exceeded rate limits), UNAUTHORIZED (key can't be used for this action), DISABLED (key was explicitly disabled), INSUFFICIENT_PERMISSIONS (key lacks required permissions), EXPIRED (key has passed its expiration date).
	Code KeysVerifyKeyResponseDataCode `json:"code"`

	// Credits The number of requests/credits remaining for this key. If null or not present, the key has unlimited usage. This value decreases with each verification (based on the 'cost' parameter) unless explicit credit refills are configured.
	Credits *int32 `json:"credits,omitempty"`

	// Enabled Indicates if the key is currently enabled. Disabled keys will always fail verification with code=DISABLED. This is useful for implementing temporary suspensions without deleting the key.
	Enabled *bool `json:"enabled,omitempty"`

	// Environment The environment tag associated with the key (e.g., 'production', 'staging', 'development'). Use this to further segment keys within an API beyond just the apiId separation.
	Environment *string `json:"environment,omitempty"`

	// Expires Unix timestamp (in milliseconds) when the key will expire. If null or not present, the key has no expiration. You can use this to warn users about upcoming expirations or to understand the validity period.
	Expires *int64 `json:"expires,omitempty"`

	// ExternalId Your user/tenant identifier that was associated with this key during creation. This allows you to connect the key back to your user without additional database lookups, making it ideal for implementing user-based authorization in stateless services.
	ExternalId *string   `json:"externalId,omitempty"`
	Identity   *Identity `json:"identity,omitempty"`

	// KeyId The unique identifier of the verified key in Unkey's system. Use this ID for operations like updating or revoking the key. This field is returned for both valid and invalid keys (except when code=NOT_FOUND).
	KeyId *string `json:"keyId,omitempty"`

	// Meta Custom metadata associated with the key. This can include any JSON-serializable data you stored with the key during creation or updates, such as plan information, feature flags, or user details. Use this to avoid additional database lookups for contextual information needed during API calls.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Name The human-readable name assigned to this key during creation. This is useful for displaying in logs or admin interfaces to identify the key's purpose or owner.
	Name *string `json:"name,omitempty"`

	// Permissions A list of all permission names assigned to this key, either directly or through roles. These permissions determine what actions the key can perform. Only returned when permissions were checked during verification or when the key fails with code=INSUFFICIENT_PERMISSIONS.
	Permissions *[]string `json:"permissions,omitempty"`

	// Ratelimits Information about the rate limits applied during verification. Only included when rate limits were checked. If verification failed with code=RATE_LIMITED, this will show which specific rate limit was exceeded.
	Ratelimits *[]struct {
		// Limit The maximum number of operations allowed within the current time window for this rate limit.
		Limit int32 `json:"limit"`

		// Name The name of the rate limit that was checked. This matches the name provided in the request.
		Name string `json:"name"`

		// Remaining The number of operations still allowed within the current time window after this verification. Your application can use this to inform users about remaining capacity or to implement your own backoff strategies.
		Remaining int32 `json:"remaining"`

		// Reset Unix timestamp in milliseconds when the rate limit window will reset and 'remaining' will return to 'limit'. Use this to implement retry-after logic or to display wait times to users.
		Reset int64 `json:"reset"`
	} `json:"ratelimits,omitempty"`

	// Roles A list of all role names assigned to this key. Roles are collections of permissions that grant access to specific functionality. Only returned when permissions were checked during verification.
	Roles *[]string `json:"roles,omitempty"`

	// Valid The primary verification result. If true, the key is valid and can be used. If false, check the 'code' field to understand why verification failed. Your application should always check this field first before proceeding.
	Valid bool `json:"valid"`
}

// KeysVerifyKeyResponseDataCode A machine-readable code indicating the verification status or failure reason. Values: VALID (key is valid), NOT_FOUND (key doesn't exist), FORBIDDEN (key exists but belongs to a different API), USAGE_EXCEEDED (key has no more credits), RATE_LIMITED (key exceeded rate limits), UNAUTHORIZED (key can't be used for this action), DISABLED (key was explicitly disabled), INSUFFICIENT_PERMISSIONS (key lacks required permissions), EXPIRED (key has passed its expiration date).
type KeysVerifyKeyResponseDataCode string

// LivenessResponseData Response data for the liveness check endpoint. This provides a simple indication of whether the Unkey API service is running and able to process requests. Monitoring systems can use this endpoint to track service availability and trigger alerts if the service becomes unhealthy.
type LivenessResponseData struct {
	// Message Status message indicating the health of the service. A value of 'OK' indicates that the service is functioning properly and ready to accept requests. Any other value indicates a potential issue with the service health.
	Message string `json:"message"`
}

// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
type Meta struct {
	// RequestId A unique id for this request. Always include this ID when contacting support about a specific API request. This identifier allows Unkey's support team to trace the exact request through logs and diagnostic systems to provide faster assistance.
	RequestId string `json:"requestId"`
}

// NotFoundErrorResponse Error response when the requested resource cannot be found. This typically indicates that the resource either doesn't exist, has been deleted, or the caller doesn't have permission to see it. Common scenarios include looking up non-existent keys, APIs, permissions, or identities. When receiving this error, verify that the resource identifier is correct and that the resource hasn't been deleted.
type NotFoundErrorResponse struct {
	// Error Standard error structure that provides detailed information about errors encountered during API operations. This follows a problem details format that includes both machine-readable error codes and human-readable explanations. All error responses in the API include this structure to provide consistent, actionable error information.
	Error BaseError `json:"error"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	// Cursor Opaque token for retrieving the next set of results
	Cursor *string `json:"cursor,omitempty"`

	// HasMore Indicates if more results exist beyond this page
	HasMore bool `json:"hasMore"`
}

// Permission defines model for Permission.
type Permission struct {
	// CreatedAt When the permission was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Description A description of what this permission grants access to
	Description *string `json:"description,omitempty"`

	// Id The unique identifier for the permission
	Id string `json:"id"`

	// Name The unique name of the permission
	Name string `json:"name"`

	// WorkspaceId The workspace this permission belongs to
	WorkspaceId string `json:"workspaceId"`
}

// PermissionsCreatePermissionResponseData defines model for PermissionsCreatePermissionResponseData.
type PermissionsCreatePermissionResponseData struct {
	// PermissionId The id of the permission. This is used internally
	PermissionId string `json:"permissionId"`
}

// PermissionsCreateRoleResponseData defines model for PermissionsCreateRoleResponseData.
type PermissionsCreateRoleResponseData struct {
	// RoleId The id of the role. This is used internally
	RoleId string `json:"roleId"`
}

// PermissionsGetPermissionResponseData defines model for PermissionsGetPermissionResponseData.
type PermissionsGetPermissionResponseData struct {
	Permission Permission `json:"permission"`
}

// PermissionsGetRoleResponseData defines model for PermissionsGetRoleResponseData.
type PermissionsGetRoleResponseData struct {
	Role RoleWithPermissions `json:"role"`
}

// PermissionsListPermissionsResponseData defines model for PermissionsListPermissionsResponseData.
type PermissionsListPermissionsResponseData = []Permission

// PermissionsListRolesResponseData defines model for PermissionsListRolesResponseData.
type PermissionsListRolesResponseData = []RoleWithPermissions

// PreconditionFailedErrorResponse Error response for when the service is available but in a degraded state. This occurs when preconditions for normal operation aren't fully met. This could happen when dependent services are experiencing issues, when the system is in maintenance mode, or when certain features are temporarily disabled. Clients should proceed with caution and may want to retry non-critical operations later.
type PreconditionFailedErrorResponse struct {
	// Error Standard error structure that provides detailed information about errors encountered during API operations. This follows a problem details format that includes both machine-readable error codes and human-readable explanations. All error responses in the API include this structure to provide consistent, actionable error information.
	Error BaseError `json:"error"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// Ratelimit defines model for Ratelimit.
type Ratelimit struct {
	// Duration The duration for each ratelimit window in milliseconds.
	//
	// This controls how long the rate limit counter accumulates before resetting. Common values include:
	// - 1000 (1 second): For strict per-second limits on high-frequency operations
	// - 60000 (1 minute): For moderate API usage control
	// - 3600000 (1 hour): For less frequent but costly operations
	// - 86400000 (24 hours): For daily quotas
	//
	// Shorter windows provide more frequent resets but may allow large burst usage. Longer windows provide more consistent usage patterns but take longer to reset after limit exhaustion.
	Duration int64 `json:"duration"`

	// Limit The maximum number of operations allowed within the specified time window.
	//
	// When this limit is reached, verification requests will fail with code=RATE_LIMITED until the window resets. The limit should reflect:
	// - Your infrastructure capacity and scaling limitations
	// - Fair usage expectations for your service
	// - Different tier levels for various user types
	// - The relative cost of the operations being limited
	//
	// Higher values allow more frequent access but may impact service performance.
	Limit int64 `json:"limit"`

	// Name The name of this rate limit. This name is used to identify which limit to check during key verification.
	//
	// Best practices for limit names:
	// - Use descriptive, semantic names like 'api_requests', 'heavy_operations', or 'downloads'
	// - Be consistent with naming conventions across your application
	// - Create separate limits for different resource types or operation costs
	// - Consider using namespaced names for better organization (e.g., 'files.downloads', 'compute.training')
	//
	// You will reference this exact name when verifying keys to check against this specific limit.
	Name string `json:"name"`
}

// RatelimitDeleteOverrideResponseData Empty response object. A successful response indicates the override was successfully deleted. The operation is immediate - as soon as this response is received, the override no longer exists and affected identifiers have reverted to using the default rate limit for the namespace. No other data is returned as part of the deletion operation.
type RatelimitDeleteOverrideResponseData = map[string]interface{}

// RatelimitLimitResponseData defines model for RatelimitLimitResponseData.
type RatelimitLimitResponseData struct {
	// Limit The maximum number of operations allowed within the time window. This reflects either the default limit specified in the request or an override limit if one exists for this identifier.
	//
	// This value helps clients understand their total quota for the current window.
	Limit int64 `json:"limit"`

	// OverrideId If a rate limit override was applied for this identifier, this field contains the ID of the override that was used. Empty when no override is in effect.
	//
	// This can be useful for:
	// - Debugging which override rule was matched
	// - Tracking the effects of specific overrides
	// - Understanding why limits differ from default values
	// - Audit logging of special rate limit rules
	OverrideId *string `json:"overrideId,omitempty"`

	// Remaining The number of operations remaining in the current window before the rate limit is exceeded. Applications should use this value to:
	//
	// - Implement client-side throttling before hitting limits
	// - Display usage information to end users
	// - Trigger alerts when approaching limits
	// - Adjust request patterns based on available capacity
	//
	// When this reaches zero, requests will be rejected until the window resets.
	Remaining int64 `json:"remaining"`

	// Reset The Unix timestamp in milliseconds when the rate limit window will reset and 'remaining' will return to 'limit'.
	//
	// This timestamp enables clients to:
	// - Calculate and display wait times to users
	// - Implement intelligent retry mechanisms
	// - Schedule requests to resume after the reset
	// - Implement exponential backoff when needed
	//
	// The reset time is based on a sliding window from the first request in the current window.
	Reset int64 `json:"reset"`

	// Success Whether the request passed the rate limit check. If true, the request is allowed to proceed. If false, the request has exceeded the rate limit and should be blocked or rejected.
	//
	// You MUST check this field to determine if the request should proceed, as the endpoint always returns HTTP 200 even when rate limited.
	Success bool `json:"success"`
}

// RatelimitListOverridesResponseData defines model for RatelimitListOverridesResponseData.
type RatelimitListOverridesResponseData = []RatelimitOverride

// RatelimitOverride defines model for RatelimitOverride.
type RatelimitOverride struct {
	// Duration The duration in milliseconds for this override's rate limit window. This may differ from the default duration for the namespace, allowing custom time windows for specific entities. After this duration elapses, the rate limit counter for affected identifiers resets to zero.
	Duration int64 `json:"duration"`

	// Identifier The identifier pattern this override applies to. This determines which entities receive the custom rate limit.
	//
	// This can be:
	// - An exact identifier for a specific entity
	// - A pattern with wildcards for matching multiple entities
	//
	// Wildcard examples:
	// - 'admin_*' matches any identifier starting with 'admin_'
	// - '*_test' matches any identifier ending with '_test'
	// - '*premium*' matches any identifier containing 'premium'
	//
	// More complex patterns can combine multiple wildcards. Detailed documentation on pattern matching rules is available at https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules
	Identifier string `json:"identifier"`

	// Limit The maximum number of requests allowed for entities matching this override. This replaces the default limit for the namespace when applied.
	//
	// Common use cases:
	// - Higher limits for premium customers
	// - Reduced limits for abusive or suspicious entities
	// - Zero limit to completely block specific patterns
	// - Custom tier-based limits for different customer segments
	Limit int64 `json:"limit"`

	// NamespaceId The unique identifier of the rate limit namespace this override belongs to. This links the override to a specific namespace context, ensuring the override only applies within that namespace.
	NamespaceId string `json:"namespaceId"`

	// OverrideId The unique identifier of this specific rate limit override. This ID is generated when the override is created and can be used for management operations like updating or deleting the override.
	OverrideId string `json:"overrideId"`
}

// RatelimitResponse defines model for RatelimitResponse.
type RatelimitResponse struct {
	// Duration The duration of the rate limit window in milliseconds
	Duration int `json:"duration"`

	// Id The unique identifier for this rate limit
	Id string `json:"id"`

	// Limit The maximum number of requests allowed within the duration
	Limit int `json:"limit"`

	// Name The name of the rate limit
	Name string `json:"name"`
}

// RatelimitSetOverrideResponseData defines model for RatelimitSetOverrideResponseData.
type RatelimitSetOverrideResponseData struct {
	// OverrideId The unique identifier for the newly created or updated rate limit override. This ID can be used to:
	//
	// - Reference this specific override in subsequent API calls
	// - Delete or modify this override later
	// - Track which override is being applied in rate limit responses
	// - Associate override effects with specific rules in analytics
	//
	// Store this ID if you need to manage the override in the future.
	OverrideId string `json:"overrideId"`
}

// RoleWithPermissions defines model for RoleWithPermissions.
type RoleWithPermissions struct {
	// CreatedAt When the role was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Description A description of what this role represents
	Description *string `json:"description,omitempty"`

	// Id The unique identifier for the role
	Id string `json:"id"`

	// Name The unique name of the role
	Name string `json:"name"`

	// Permissions The permissions assigned to this role
	Permissions []Permission `json:"permissions"`

	// WorkspaceId The workspace this role belongs to
	WorkspaceId string `json:"workspaceId"`
}

// UnauthorizedErrorResponse Error response when authentication has failed or credentials are missing. This occurs when:
//
// - The Authorization header is missing
// - The root key is invalid or has been revoked
// - The root key format is incorrect
// - The authentication token has expired
//
// To fix this error:
// 1. Ensure you're including the Authorization header with format: 'Bearer your_root_key'
// 2. Verify your root key is valid and has not been revoked in the Unkey dashboard
// 3. Check that you're using the correct root key for the environment
// 4. If using a new key, ensure it was created successfully
//
// For security reasons, the specific reason for authentication failure may be intentionally vague in the error message. Check your Unkey dashboard for more detailed information about your root keys.
type UnauthorizedErrorResponse struct {
	// Error Standard error structure that provides detailed information about errors encountered during API operations. This follows a problem details format that includes both machine-readable error codes and human-readable explanations. All error responses in the API include this structure to provide consistent, actionable error information.
	Error BaseError `json:"error"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2ApisCreateApiRequestBody defines model for V2ApisCreateApiRequestBody.
type V2ApisCreateApiRequestBody struct {
	// Name The name for your API. This is an internal identifier used for organization and not shown to end users. APIs are containers for groups of keys and provide isolation between different environments or services.
	//
	// Best practices for API names:
	// - Use descriptive names that identify the purpose or environment
	// - Include environment indicators (e.g., 'payment-service-production', 'auth-service-staging')
	// - Use consistent naming conventions across your organization
	// - Keep names relatively short but informative
	//
	// Common patterns include:
	// - Environment separation: 'production-api', 'staging-api', 'development-api'
	// - Service-based: 'payment-service', 'user-management', 'data-analytics'
	// - Product-based: 'premium-tier', 'free-tier', 'internal-tools'
	Name string `json:"name"`
}

// V2ApisCreateApiResponseBody defines model for V2ApisCreateApiResponseBody.
type V2ApisCreateApiResponseBody struct {
	Data ApisCreateApiResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2ApisDeleteApiRequestBody defines model for V2ApisDeleteApiRequestBody.
type V2ApisDeleteApiRequestBody struct {
	// ApiId The id of the API you want to delete (begins with 'api_').
	//
	// WARNING: Deleting an API has significant consequences:
	// - All keys associated with this API will be invalidated immediately
	// - Verification attempts for these keys will fail with code=NOT_FOUND
	// - This action cannot be undone
	//
	// Before deletion, ensure that:
	// - You have the correct API ID (check the environment/service)
	// - You have migrated any needed keys to a new API
	// - You have updated all client applications to use new keys
	// - You have backed up any important metadata or analytics
	ApiId string `json:"apiId"`
}

// V2ApisDeleteApiResponseBody defines model for V2ApisDeleteApiResponseBody.
type V2ApisDeleteApiResponseBody struct {
	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2ApisGetApiRequestBody defines model for V2ApisGetApiRequestBody.
type V2ApisGetApiRequestBody struct {
	// ApiId The ID of the API to retrieve (begins with 'api_'). This identifier uniquely references a specific API in your workspace. Use this endpoint to verify an API exists, check its name, or retrieve its ID when you only have the name stored.
	ApiId string `json:"apiId"`
}

// V2ApisGetApiResponseBody defines model for V2ApisGetApiResponseBody.
type V2ApisGetApiResponseBody struct {
	Data ApisGetApiResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2ApisListKeysRequestBody defines model for V2ApisListKeysRequestBody.
type V2ApisListKeysRequestBody struct {
	// ApiId The ID of the API whose keys you want to list (begins with 'api_'). This endpoint returns all keys associated with this specific API, subject to pagination and any additional filters provided.
	ApiId string `json:"apiId"`

	// Cursor Pagination cursor from a previous response. Use this to fetch subsequent pages of results when the response contains hasMore=true. Each response containing additional results will include a new cursor value in the pagination object.
	Cursor *string `json:"cursor,omitempty"`

	// Decrypt When true, attempts to include the plaintext key value in the response. SECURITY WARNING:
	// - This requires special permissions on the calling root key
	// - Only works for keys created with 'recoverable: true'
	// - Exposes sensitive key material in the response
	// - Should only be used in secure administrative contexts
	// - Never enable this in user-facing applications
	Decrypt *bool `json:"decrypt,omitempty"`

	// ExternalId Optional filter to return only keys associated with a specific external ID. This is useful when you need to find all keys belonging to a particular user, organization, or entity in your system. The value must exactly match the externalId set during key creation.
	ExternalId *string `json:"externalId,omitempty"`

	// Limit The maximum number of keys to return in a single request. Use this to control response size and loading performance. Higher values return more keys but may increase response time. Lower values may require more pagination requests but provide faster initial loading.
	Limit *int `json:"limit,omitempty"`

	// RevalidateKeysCache EXPERIMENTAL: Skip the cache and fetch the keys directly from the database. This ensures you see the most recent state, including keys created moments ago. Use this when:
	// - You've just created a key and need to display it immediately
	// - You need absolute certainty about the current key state
	// - You're debugging cache consistency issues
	//
	// This parameter comes with a performance cost and should be used sparingly.
	RevalidateKeysCache *bool `json:"revalidateKeysCache,omitempty"`
}

// V2ApisListKeysResponseBody defines model for V2ApisListKeysResponseBody.
type V2ApisListKeysResponseBody struct {
	Data ApisListKeysResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta       Meta        `json:"meta"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

// V2IdentitiesCreateIdentityRequestBody defines model for V2IdentitiesCreateIdentityRequestBody.
type V2IdentitiesCreateIdentityRequestBody struct {
	// ExternalId The id of this identity in your system.
	//
	// This should be a stable, unique identifier that represents a user, organization, or entity in your application. Common sources include:
	// - User IDs from your authentication system
	// - Organization/tenant IDs
	// - Customer IDs from your database
	// - Email addresses (if they serve as stable identifiers)
	//
	// Best practices:
	// - Use consistent identifier types across your application
	// - Prefer UUIDs or opaque IDs over sequential numbers
	// - Ensure the ID remains stable even if other user properties change
	// - Consider namespace prefixing (e.g., 'user_123', 'org_456') for clarity
	//
	// `externalId`s are unique across your workspace and therefore a `CONFLICT` error is returned when you try to create duplicates.
	ExternalId string `json:"externalId"`

	// Meta Attach metadata to this identity that you need to have access to when verifying a key.
	//
	// Metadata lets you store context with the identity that will be accessible during key verification without additional database lookups. This improves performance and reduces dependencies.
	//
	// Common metadata uses:
	// - User profile information (name, email, etc.)
	// - Subscription or plan details
	// - Feature flags and entitlements
	// - Usage limits or quotas
	// - Organization information
	// - Region or localization preferences
	//
	// This data is returned as-is in the `verifyKey` response when verifying any key associated with this identity.
	//
	// Note: Metadata should be kept reasonably small as it affects verification performance. For large data sets, consider storing only identifiers or essential information.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Ratelimits Attach ratelimits to this identity.
	//
	// Identity-based rate limits provide shared rate limiting across all keys belonging to the same identity. This is essential for:
	//
	// - Implementing fair usage policies across multiple API keys
	// - Preventing abuse by users with multiple keys
	// - Enforcing consistent limits regardless of how many keys a user creates
	// - Creating tiered access levels with different rate limits
	//
	// How it works:
	// - Rate limits defined here apply to all keys that share this identity
	// - During verification, specify which named limits to check
	// - Counters are shared across all keys with this identity
	// - Each named limit can have different thresholds and windows
	//
	// When verifying keys, you can specify which limits you want to use and all keys attached to this identity will share the limits, regardless of which specific key is used.
	Ratelimits *[]Ratelimit `json:"ratelimits,omitempty"`
}

// V2IdentitiesCreateIdentityResponseBody defines model for V2IdentitiesCreateIdentityResponseBody.
type V2IdentitiesCreateIdentityResponseBody struct {
	Data IdentitiesCreateIdentityResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2IdentitiesDeleteIdentityRequestBody defines model for V2IdentitiesDeleteIdentityRequestBody.
type V2IdentitiesDeleteIdentityRequestBody struct {
	// ExternalId The id of this identity in your system.
	//
	// This should match the externalId value you used when creating the identity. You can use this field when you know the specific externalId but don't have the Unkey identityId. Only one of externalId or identityId is required.
	//
	// This identifier typically comes from your authentication system and could be a userId, organizationId, or any other stable unique identifier in your application.
	ExternalId *string `json:"externalId,omitempty"`

	// IdentityId The Unkey Identity ID (begins with 'id_').
	//
	// This is the internal unique identifier generated by Unkey when the identity was created. Use this when you have the specific Unkey ID and want to ensure you're targeting the exact identity. This is especially useful in automation scripts or when you need to guarantee you're operating on a specific identity regardless of externalId changes.
	//
	// Only one of externalId or identityId is required.
	IdentityId *string `json:"identityId,omitempty"`
	union      json.RawMessage
}

// V2IdentitiesDeleteIdentityRequestBody0 Identify by external ID from your system
type V2IdentitiesDeleteIdentityRequestBody0 = interface{}

// V2IdentitiesDeleteIdentityRequestBody1 Identify by Unkey's internal identity ID
type V2IdentitiesDeleteIdentityRequestBody1 = interface{}

// V2IdentitiesDeleteIdentityResponseBody Empty response object. A successful response indicates the identity was deleted successfully. The operation is immediate and permanent - the identity and all its associated data are removed from the system. Any API keys previously associated with this identity remain valid but are no longer linked to this identity.
type V2IdentitiesDeleteIdentityResponseBody struct {
	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2IdentitiesGetIdentityRequestBody defines model for V2IdentitiesGetIdentityRequestBody.
type V2IdentitiesGetIdentityRequestBody struct {
	// ExternalId The external ID of the identity to retrieve. This is the ID from your own system that was used during identity creation. Use either identityId or externalId to specify which identity to fetch. If both are provided, identityId takes precedence.
	ExternalId *string `json:"externalId,omitempty"`

	// IdentityId The Unkey identity ID to retrieve (begins with 'id_'). Use either identityId or externalId to specify which identity to fetch. If both are provided, identityId takes precedence.
	IdentityId *string `json:"identityId,omitempty"`
	union      json.RawMessage
}

// V2IdentitiesGetIdentityRequestBody0 defines model for .
type V2IdentitiesGetIdentityRequestBody0 = interface{}

// V2IdentitiesGetIdentityRequestBody1 defines model for .
type V2IdentitiesGetIdentityRequestBody1 = interface{}

// V2IdentitiesGetIdentityResponseBody defines model for V2IdentitiesGetIdentityResponseBody.
type V2IdentitiesGetIdentityResponseBody struct {
	Data IdentitiesGetIdentityResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2IdentitiesListIdentitiesRequestBody defines model for V2IdentitiesListIdentitiesRequestBody.
type V2IdentitiesListIdentitiesRequestBody struct {
	// Cursor Pagination cursor from a previous response. Use this to fetch subsequent pages of results when the response contains a cursor value.
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of identities to return in a single request. Use this to control response size and loading performance.
	Limit *int `json:"limit,omitempty"`
}

// V2IdentitiesListIdentitiesResponseBody defines model for V2IdentitiesListIdentitiesResponseBody.
type V2IdentitiesListIdentitiesResponseBody struct {
	// Data List of identities matching the specified criteria.
	Data IdentitiesListIdentitiesResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta       Meta       `json:"meta"`
	Pagination Pagination `json:"pagination"`
}

// V2IdentitiesUpdateIdentityRequestBody defines model for V2IdentitiesUpdateIdentityRequestBody.
type V2IdentitiesUpdateIdentityRequestBody struct {
	// ExternalId The external ID of the identity to update. This is the ID from your own system that was used during identity creation. Use either identityId or externalId to specify which identity to update. If both are provided, identityId takes precedence.
	ExternalId *string `json:"externalId,omitempty"`

	// IdentityId The Unkey Identity ID (begins with 'id_'). Use either identityId or externalId to specify which identity to update. If both are provided, identityId takes precedence.
	IdentityId *string `json:"identityId,omitempty"`

	// Meta Custom metadata to associate with this identity. This can include any JSON-serializable data you want to store with the identity. Set to an empty object {} to clear existing metadata.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Ratelimits Array of ratelimits to apply to this identity. These limits are shared across all API keys associated with this identity. Providing this array will completely replace any existing ratelimits. Set to an empty array [] to remove all ratelimits.
	Ratelimits *[]Ratelimit `json:"ratelimits,omitempty"`
	union      json.RawMessage
}

// V2IdentitiesUpdateIdentityRequestBody0 defines model for .
type V2IdentitiesUpdateIdentityRequestBody0 = interface{}

// V2IdentitiesUpdateIdentityRequestBody1 defines model for .
type V2IdentitiesUpdateIdentityRequestBody1 = interface{}

// V2IdentitiesUpdateIdentityResponseBody defines model for V2IdentitiesUpdateIdentityResponseBody.
type V2IdentitiesUpdateIdentityResponseBody struct {
	Data IdentitiesUpdateIdentityResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysAddPermissionsRequestBody defines model for V2KeysAddPermissionsRequestBody.
type V2KeysAddPermissionsRequestBody struct {
	// KeyId The ID of the key to which permissions will be added (begins with 'key_')
	KeyId string `json:"keyId"`

	// Permissions List of permissions to add to the key. Each permission can be identified by ID or name (if both are provided in the same object, ID takes precedence).
	//
	// Best practices:
	// - Use consistent naming patterns (e.g., 'resource.action' or 'resource.subresouce.action')
	// - Group related permissions (e.g., 'documents.read', 'documents.write', 'documents.delete')
	// - Use hierarchical naming for verification flexibility
	// - Consider creating a permission naming guide for your team
	//
	// Duplicate permissions are automatically handled (adding the same permission twice has no effect). During verification, hierarchical patterns are matched - a key with 'billing.*' permission will have access to 'billing.invoices.view'.
	Permissions []struct {
		// Create When true, if a permission with this name doesn't exist, it will be automatically created on-the-fly. Only works when specifying name, not ID.
		//
		// SECURITY CONSIDERATIONS:
		// - Requires the 'rbac.*.create_permission' permission on your root key
		// - Use carefully to avoid permission proliferation
		// - Consider centralizing permission creation in a controlled process
		// - Typos with create=true can lead to unintended permissions
		// - Created permissions are permanent and visible to all API keys in the workspace
		Create *bool `json:"create,omitempty"`

		// Id The ID of an existing permission (begins with 'perm_'). Provide either ID or name. Use ID when you know the exact permission identifier and want to ensure you're referencing a specific permission.
		Id *string `json:"id,omitempty"`

		// Name The name of the permission. Provide either ID or name. Permission names typically follow a 'resource.action' format (e.g., 'documents.read', 'users.delete'). Use consistent naming patterns to create logical permission hierarchies.
		Name *string `json:"name,omitempty"`
	} `json:"permissions"`
}

// V2KeysAddPermissionsResponse defines model for V2KeysAddPermissionsResponse.
type V2KeysAddPermissionsResponse struct {
	// Data Complete list of all permissions directly assigned to the key (including both newly added permissions and those that were already assigned).
	//
	// This response includes:
	// - All direct permissions assigned to the key (both pre-existing and newly added)
	// - Permissions sorted alphabetically by name for consistent response format
	// - Both the permission ID and name for each permission
	//
	// Important notes:
	// - This list does NOT include permissions granted through roles
	// - For a complete permission picture, use /v2/keys.getKey instead
	// - An empty array indicates the key has no direct permissions assigned
	// - Only includes direct permissions from the same workspace as the key
	Data V2KeysAddPermissionsResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysAddPermissionsResponseData Complete list of all permissions directly assigned to the key (including both newly added permissions and those that were already assigned).
//
// This response includes:
// - All direct permissions assigned to the key (both pre-existing and newly added)
// - Permissions sorted alphabetically by name for consistent response format
// - Both the permission ID and name for each permission
//
// Important notes:
// - This list does NOT include permissions granted through roles
// - For a complete permission picture, use /v2/keys.getKey instead
// - An empty array indicates the key has no direct permissions assigned
// - Only includes direct permissions from the same workspace as the key
type V2KeysAddPermissionsResponseData = []struct {
	// Id The unique identifier of the permission (begins with 'perm_'). This ID can be used in other API calls to reference this specific permission. IDs are guaranteed unique and won't change, making them ideal for scripting and automation. You can store these IDs in your system for consistent reference.
	Id string `json:"id"`

	// Name The name of the permission, typically following a 'resource.action' pattern like 'documents.read'. Names are human-readable identifiers used both for assignment and verification.
	//
	// During verification:
	// - The exact name is matched (e.g., 'documents.read')
	// - Hierarchical wildcards are supported in verification requests
	// - A key with permission 'documents.*' grants access to 'documents.read', 'documents.write', etc.
	// - Wildcards can appear at any level: 'billing.*.view' matches 'billing.invoices.view' and 'billing.payments.view'
	//
	// However, when adding permissions, you must specify each exact permission - wildcards are not valid for assignment.
	Name string `json:"name"`
}

// V2KeysAddRolesRequestBody defines model for V2KeysAddRolesRequestBody.
type V2KeysAddRolesRequestBody struct {
	// KeyId The ID of the key to which roles will be added (begins with 'key_'). This is the database reference ID for the key, not the actual API key string. This ID uniquely identifies which key will receive the additional roles.
	KeyId string `json:"keyId"`

	// Roles List of roles to add to the key. Each role can be identified by ID or name (if both are provided in the same object, ID takes precedence).
	//
	// Key behaviors:
	// - Duplicate roles are automatically handled (adding the same role twice has no effect)
	// - The operation is idempotent - running it multiple times produces the same result
	// - Roles must already exist - unlike permissions, roles cannot be created on-the-fly
	// - All roles must belong to the same workspace as the key
	// - Invalid roles will cause the entire operation to fail (atomic transaction)
	//
	// Roles are collections of permissions that provide a convenient way to assign multiple permissions at once. When a key is verified, all permissions granted through all assigned roles are checked, alongside any direct permissions on the key.
	Roles []struct {
		// Id The ID of an existing role (begins with 'role_'). Provide either ID or name, not both. Using the ID guarantees you're referencing the exact role intended, regardless of name changes. This is particularly valuable for scripting, automation, and ensuring consistency between environments where role names might differ but IDs are stable references.
		Id *string `json:"id,omitempty"`

		// Name The name of the role. Provide either ID or name, not both. Role names must be unique within a workspace, making them generally safe to use as references. Names are more human-readable and easier to work with in configurations and documentation. However, if roles are renamed, any integration using name references will need to be updated.
		Name *string `json:"name,omitempty"`
	} `json:"roles"`
}

// V2KeysAddRolesResponse defines model for V2KeysAddRolesResponse.
type V2KeysAddRolesResponse struct {
	// Data Complete list of all roles directly assigned to the key after the operation completes.
	//
	// The response includes:
	// - All roles now assigned to the key (both pre-existing and newly added)
	// - Both ID and name of each role for easy reference
	// - Roles sorted alphabetically by name for consistent response format
	//
	// Important notes:
	// - The response shows the complete current state after the addition
	// - An empty array means the key has no roles assigned (unlikely after an add operation)
	// - This only shows direct role assignments, not inherited or nested roles
	// - Role permissions are not expanded in this response - use keys.getKey for full details
	// - All role changes are logged in the audit log for security tracking
	Data V2KeysAddRolesResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysAddRolesResponseData Complete list of all roles directly assigned to the key after the operation completes.
//
// The response includes:
// - All roles now assigned to the key (both pre-existing and newly added)
// - Both ID and name of each role for easy reference
// - Roles sorted alphabetically by name for consistent response format
//
// Important notes:
// - The response shows the complete current state after the addition
// - An empty array means the key has no roles assigned (unlikely after an add operation)
// - This only shows direct role assignments, not inherited or nested roles
// - Role permissions are not expanded in this response - use keys.getKey for full details
// - All role changes are logged in the audit log for security tracking
type V2KeysAddRolesResponseData = []struct {
	// Id The unique identifier of the role (begins with 'role_'). This ID can be used in other API calls to reference this specific role. Role IDs are immutable and guaranteed to be unique within your Unkey workspace, making them reliable reference points for integration and automation systems.
	Id string `json:"id"`

	// Name The name of the role. This is a human-readable identifier that's unique within your workspace. Role names help identify what access level or function a role provides. Common patterns include naming by access level ('admin', 'editor', 'viewer'), by department ('billing_manager', 'support_agent'), or by feature area ('analytics_user', 'dashboard_admin').
	Name string `json:"name"`
}

// V2KeysCreateKeyRequestBody defines model for V2KeysCreateKeyRequestBody.
type V2KeysCreateKeyRequestBody struct {
	// ApiId The API ID where this key should be created. Keys are isolated by API, preventing keys from one environment (e.g., development) being used in another (e.g., production). We recommend creating separate APIs for different environments and services.
	ApiId string `json:"apiId"`

	// ByteLength Controls the cryptographic strength of the generated key. Higher values increase security but result in longer keys. The default (16 bytes) provides 2^128 possible combinations, which is secure for most applications. For highly sensitive APIs, consider using 24 or 32 bytes.
	ByteLength *int `json:"byteLength,omitempty"`

	// Credits Usage limits configuration for this key. Credits provide a way to limit how many times a key can be used, with optional automatic refills. Unlike rate limits (which control frequency), credits control total usage and are globally consistent. This makes them ideal for implementing usage-based pricing, subscription tiers, or hard usage caps.
	Credits *struct {
		// Refill Configuration for automatic credit refills. This creates a subscription-like recurring quota that resets on a schedule. To implement monthly plans with usage quotas, set interval='monthly' with the appropriate amount and refillDay.
		Refill *struct {
			// Amount Number of credits to add during each automatic refill. This should typically match the 'remaining' value to provide consistent quota periods.
			Amount int `json:"amount"`

			// Interval How frequently credits should be automatically refilled. With 'daily', credits reset at midnight UTC. With 'monthly', credits reset on the specified refillDay (or the 1st if not specified).
			Interval V2KeysCreateKeyRequestBodyCreditsRefillInterval `json:"interval"`

			// RefillDay For monthly refills, the day of month when credits are replenished. If the month doesn't have this day (e.g., refillDay=31 in February), the refill occurs on the last day of the month.
			RefillDay *int `json:"refillDay,omitempty"`
		} `json:"refill,omitempty"`

		// Remaining The initial number of credits (or requests) this key can use before becoming invalid. Each verification decrements this counter by the specified cost (default 1). When it reaches zero, verification fails with code=USAGE_EXCEEDED. This provides global consistency for usage limits, making it ideal for paid APIs with strict quotas.
		Remaining int32 `json:"remaining"`
	} `json:"credits,omitempty"`

	// Enabled Controls whether the key is active upon creation. If false, verification will immediately fail with code=DISABLED. This is useful for preparing keys in advance that will be activated later, or for implementing approval workflows where keys are created disabled until reviewed.
	Enabled *bool `json:"enabled,omitempty"`

	// Expires Unix timestamp (milliseconds) when this key should automatically expire. After this time, verification will fail with code=EXPIRED. Use temporary keys for time-limited access, trial periods, emergency access, or one-time operations. Omit this field for keys that should never expire.
	Expires *int64 `json:"expires,omitempty"`

	// ExternalId Your system's unique identifier for the user or entity this key belongs to. This ID is returned during verification, allowing you to identify the key owner without additional database lookups. Typically, this should be your user ID, organization ID, or tenant ID - whatever you use to identify entities in your system.
	ExternalId *string `json:"externalId,omitempty"`

	// Meta Arbitrary JSON metadata stored with the key and returned during verification. This is ideal for contextual information needed during API requests like subscription plans, feature flags, or user properties. Storing this data with the key eliminates the need for additional database lookups during verification, improving performance for stateless services.
	Meta *map[string]interface{} `json:"meta,omitempty"`

	// Name Human-readable name for the key shown in dashboards, logs, and API responses. This helps identify the key's purpose or owner but is never exposed to end users. Good names include the user's name, the specific service, or the access level (e.g., 'Alice's Production Key', 'Payment Service Key', 'Admin Access').
	Name *string `json:"name,omitempty"`

	// Permissions Individual permissions to assign directly to this key. Permissions define specific actions the key can perform when verified with the permissions check. Use a hierarchical naming pattern like 'resource.action' (e.g., 'documents.read', 'users.delete') to create logical groupings. During verification, a key with permission 'documents.*' will have access to both 'documents.read' and 'documents.write'.
	Permissions *[]string `json:"permissions,omitempty"`

	// Prefix Optional prefix for the key that helps visually identify its purpose. The prefix becomes part of the key (e.g., 'prod_xxxxxxxxx') and appears in logs and dashboards. Use prefixes like 'prod', 'dev', 'test', or application names to help users understand what the key is for. Only alphanumeric characters, underscores, and hyphens are allowed.
	Prefix *string `json:"prefix,omitempty"`

	// Ratelimits Array of rate limits to apply to this key. Rate limits protect against abuse by controlling how frequently operations can be performed. Unlike credits (which limit total usage), rate limits are time-based and automatically reset. They're optimized for performance and typically add minimal latency to verifications.
	Ratelimits *[]struct {
		// Duration Duration of the rate limit window in milliseconds. Common durations include 60000 (1 minute), 3600000 (1 hour), or 86400000 (1 day). The rate limit resets after this period has elapsed.
		Duration int32 `json:"duration"`

		// Limit Maximum number of operations allowed within the time window. When this limit is reached, verification fails with code=RATE_LIMITED until the window resets.
		Limit int32 `json:"limit"`

		// Name Identifier for this rate limit. Multiple named rate limits can control different aspects of API usage. Use descriptive names that reflect what's being limited, like 'requests', 'compute_operations', or 'database_writes'.
		Name string `json:"name"`
	} `json:"ratelimits,omitempty"`

	// Recoverable If true, the plaintext key is stored in an encrypted vault, allowing it to be retrieved later using keys.getKey with decrypt=true. SECURITY WARNING: This reduces security by storing the key in recoverable format. Use only for development keys, emergency backup, or when absolutely necessary. In production, set this to false (default) for maximum security.
	Recoverable *bool `json:"recoverable,omitempty"`

	// Roles Roles to assign to this key for permission management. Each role represents a collection of permissions that define what actions the key can perform. Roles must already exist in your workspace. During verification, all permissions from these roles are checked against requested permissions. Common role names include 'admin', 'editor', 'viewer', etc.
	Roles *[]string `json:"roles,omitempty"`
}

// V2KeysCreateKeyRequestBodyCreditsRefillInterval How frequently credits should be automatically refilled. With 'daily', credits reset at midnight UTC. With 'monthly', credits reset on the specified refillDay (or the 1st if not specified).
type V2KeysCreateKeyRequestBodyCreditsRefillInterval string

// V2KeysCreateKeyResponseBody defines model for V2KeysCreateKeyResponseBody.
type V2KeysCreateKeyResponseBody struct {
	Data KeysCreateKeyResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysDeleteKeyRequestBody defines model for V2KeysDeleteKeyRequestBody.
type V2KeysDeleteKeyRequestBody struct {
	// KeyId The unique identifier of the key to delete (starts with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. Once deleted, verification attempts with this key will fail with code=NOT_FOUND and it will no longer appear in key listings.
	KeyId string `json:"keyId"`

	// Permanent Controls whether the key should be soft-deleted (default) or permanently erased from the database. Soft deletion marks the key as deleted but preserves its data, allowing potential recovery via direct database operations. Permanent deletion completely removes all traces of the key including its hash and metadata. Use permanent=true for regulatory compliance scenarios (like GDPR), resolving hash collisions during migrations, or when you need to reuse the same key string in the future. CAUTION: Permanent deletion cannot be undone.
	Permanent *bool `json:"permanent,omitempty"`
}

// V2KeysDeleteKeyResponseBody defines model for V2KeysDeleteKeyResponseBody.
type V2KeysDeleteKeyResponseBody struct {
	// Data Empty response object. A successful response indicates the key was deleted successfully. Deletion triggers cache invalidation across all regions, but it may take up to 30 seconds for the deletion to be fully propagated due to eventual consistency. During this propagation period, some verification attempts might still succeed in certain regions.
	Data *KeysDeleteKeyResponseData `json:"data,omitempty"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysGetKeyRequestBody defines model for V2KeysGetKeyRequestBody.
type V2KeysGetKeyRequestBody struct {
	// Decrypt Whether to include the plaintext key in the response. This is only possible for keys created with 'recoverable: true' and requires the 'decrypt_key' permission. SECURITY WARNING: This should be used sparingly and only for legitimate recovery purposes. Keys returned this way must be handled securely and not logged or stored insecurely. Most applications should set this to false.
	Decrypt *bool `json:"decrypt,omitempty"`

	// KeyId The unique identifier of the key to retrieve (starts with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. You can find this ID in the creation response, key listings, or in the dashboard.
	KeyId string `json:"keyId"`
}

// V2KeysGetKeyResponseBody defines model for V2KeysGetKeyResponseBody.
type V2KeysGetKeyResponseBody struct {
	Data KeysGetKeyResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysRemovePermissionsRequestBody defines model for V2KeysRemovePermissionsRequestBody.
type V2KeysRemovePermissionsRequestBody struct {
	// KeyId The unique identifier of the key from which permissions will be removed (begins with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. Every operation requires this identifier to specify which key to modify.
	KeyId string `json:"keyId"`

	// Permissions List of permissions to remove from the key. Each permission can be identified by ID or name (if both are provided in the same object, ID takes precedence).
	//
	// Important details:
	// - This operation only affects direct permissions on the key, not permissions granted through roles
	// - Removing permissions that aren't assigned to the key is a no-op and doesn't cause an error
	// - Removing all permissions doesn't disable the key - it just removes its direct permissions
	// - The operation is idempotent - multiple identical requests have the same effect as a single request
	// - After removal, any verification checks for these permissions will fail unless granted via roles
	// - Each permission must include either id or name - you can't use wildcards for removal
	Permissions []struct {
		// Id The ID of the permission to remove (begins with 'perm_'). Provide either ID or name, not both. Using ID guarantees you're removing the exact permission intended, even if multiple permissions have similar names. The ID is especially useful in automation scripts where precision is important.
		Id *string `json:"id,omitempty"`

		// Name The name of the permission to remove. Provide either ID or name, not both. When using names, the string must match exactly as it was defined - including case sensitivity and full hierarchical path (e.g., 'documents.write', not just 'write'). Name lookup happens within the same workspace as the key.
		Name *string `json:"name,omitempty"`
	} `json:"permissions"`
}

// V2KeysRemovePermissionsResponse defines model for V2KeysRemovePermissionsResponse.
type V2KeysRemovePermissionsResponse struct {
	// Data Empty response object by design. A successful response indicates the permissions were successfully removed from the key. Unlike the addPermissions endpoint which returns the current permissions, this endpoint returns an empty object to reduce response size.
	//
	// Important post-operation effects:
	// - Any cached versions of the key are immediately invalidated to ensure consistency
	// - Changes to permissions take effect within seconds for new verifications
	// - Existing verification sessions might retain permissions until their cache expires (usually <30 seconds)
	// - To get the updated list of permissions, use the keys.getKey endpoint
	// - All permission removals are logged to the audit log for security tracking
	Data V2KeysRemovePermissionsResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysRemovePermissionsResponseData Empty response object by design. A successful response indicates the permissions were successfully removed from the key. Unlike the addPermissions endpoint which returns the current permissions, this endpoint returns an empty object to reduce response size.
//
// Important post-operation effects:
// - Any cached versions of the key are immediately invalidated to ensure consistency
// - Changes to permissions take effect within seconds for new verifications
// - Existing verification sessions might retain permissions until their cache expires (usually <30 seconds)
// - To get the updated list of permissions, use the keys.getKey endpoint
// - All permission removals are logged to the audit log for security tracking
type V2KeysRemovePermissionsResponseData = map[string]interface{}

// V2KeysRemoveRolesRequestBody defines model for V2KeysRemoveRolesRequestBody.
type V2KeysRemoveRolesRequestBody struct {
	// KeyId The ID of the key from which roles will be removed (begins with 'key_'). This is the database reference for the key, not the actual API key string that users authenticate with. Every operation requires this identifier to specify which key to modify.
	KeyId string `json:"keyId"`

	// Roles List of roles to remove from the key. Each role can be identified by ID or name (if both are provided in the same object, ID takes precedence).
	//
	// Key behaviors:
	// - Only affects direct role assignments on the key
	// - Removing roles that aren't assigned to the key has no effect (silent no-op)
	// - The operation is idempotent - multiple identical requests have the same effect
	// - Invalid role references will cause the entire operation to fail (atomic transaction)
	// - After removal, the key will lose access to any permissions that were only granted through these roles
	// - Inherited roles or permissions from other sources are not affected
	//
	// This operation is commonly used when downgrading access levels, removing temporary elevated privileges, or fine-tuning access control for API keys.
	Roles []struct {
		// Id The ID of an existing role (begins with 'role_'). Provide either ID or name, not both. Using the role ID ensures you're removing exactly the intended role, even if multiple roles have similar or identical names. IDs are especially useful in automation scripts and cross-environment scenarios where consistent references are important.
		Id *string `json:"id,omitempty"`

		// Name The name of the role. Provide either ID or name, not both. Role names must exactly match the role's current name in your workspace, including case sensitivity. Names are more human-readable and easier to work with in configurations, but if roles are renamed, any systems using name references will need to be updated.
		Name *string `json:"name,omitempty"`
	} `json:"roles"`
}

// V2KeysRemoveRolesResponse defines model for V2KeysRemoveRolesResponse.
type V2KeysRemoveRolesResponse struct {
	// Data Complete list of all roles directly assigned to the key after the removal operation completes.
	//
	// The response includes:
	// - The remaining roles still assigned to the key (after removing the specified roles)
	// - Both ID and name for each role for easy reference
	// - Roles sorted alphabetically by name for consistent response format
	//
	// Important notes:
	// - The response reflects the current state after the removal operation
	// - An empty array indicates the key now has no roles assigned
	// - This only shows direct role assignments
	// - Role permissions are not expanded in this response - use keys.getKey for full details
	// - All role changes are logged in the audit log for security tracking
	// - Changes take effect immediately for new verifications but cached sessions may retain old permissions briefly
	Data V2KeysRemoveRolesResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysRemoveRolesResponseData Complete list of all roles directly assigned to the key after the removal operation completes.
//
// The response includes:
// - The remaining roles still assigned to the key (after removing the specified roles)
// - Both ID and name for each role for easy reference
// - Roles sorted alphabetically by name for consistent response format
//
// Important notes:
// - The response reflects the current state after the removal operation
// - An empty array indicates the key now has no roles assigned
// - This only shows direct role assignments
// - Role permissions are not expanded in this response - use keys.getKey for full details
// - All role changes are logged in the audit log for security tracking
// - Changes take effect immediately for new verifications but cached sessions may retain old permissions briefly
type V2KeysRemoveRolesResponseData = []struct {
	// Id The unique identifier of the role (begins with 'role_'). This ID can be used in other API calls to reference this specific role.
	Id string `json:"id"`

	// Name The name of the role. This is a human-readable identifier that's unique within your workspace.
	Name string `json:"name"`
}

// V2KeysSetPermissionsRequestBody defines model for V2KeysSetPermissionsRequestBody.
type V2KeysSetPermissionsRequestBody struct {
	// KeyId The unique identifier of the key to set permissions on (begins with 'key_'). This ID comes from the createKey response and identifies which key will have its permissions replaced. This is the database ID, not the actual API key string that users authenticate with.
	KeyId string `json:"keyId"`

	// Permissions The permissions to set for this key. This is a complete replacement operation - it overwrites all existing direct permissions with this new set.
	//
	// Key behaviors:
	// - Providing an empty array removes all direct permissions from the key
	// - This only affects direct permissions - permissions granted through roles are not affected
	// - All existing direct permissions not included in this list will be removed
	// - The complete list approach allows synchronizing permissions with external systems
	// - Permission changes take effect immediately for new verifications
	//
	// Unlike addPermissions (which only adds) or removePermissions (which only removes), this endpoint performs a wholesale replacement of the permission set.
	Permissions []struct {
		// Create When true, if a permission with this name doesn't exist, it will be automatically created on-the-fly. Only works when specifying name, not ID.
		//
		// SECURITY CONSIDERATIONS:
		// - Requires the 'rbac.*.create_permission' permission on your root key
		// - Created permissions are permanent and visible throughout your workspace
		// - Use carefully to avoid permission proliferation and inconsistency
		// - Consider using a controlled process for permission creation instead
		// - Typos with create=true will create unintended permissions that persist in your system
		Create *bool `json:"create,omitempty"`

		// Id The ID of an existing permission (begins with 'perm_'). Provide either ID or name for each permission, not both. Using ID is more precise and guarantees you're referencing the exact permission intended, regardless of name changes or duplicates. IDs are particularly useful in automation scripts and when migrating permissions between environments.
		Id *string `json:"id,omitempty"`

		// Name The name of the permission. Provide either ID or name for each permission, not both. Names must match exactly as defined in your permission system - including case sensitivity and the complete hierarchical path. Names are generally more human-readable but can be ambiguous if not carefully managed across your workspace.
		Name *string `json:"name,omitempty"`
	} `json:"permissions"`
}

// V2KeysSetPermissionsResponse defines model for V2KeysSetPermissionsResponse.
type V2KeysSetPermissionsResponse struct {
	// Data Complete list of all permissions now directly assigned to the key after the set operation has completed.
	//
	// The response includes:
	// - The comprehensive, updated set of direct permissions (reflecting the complete replacement)
	// - Both ID and name for each permission for easy reference
	// - Permissions sorted alphabetically by name for consistent response format
	//
	// Important notes:
	// - This only shows direct permissions, not those granted through roles
	// - An empty array means the key has no direct permissions assigned
	// - For a complete permission picture including roles, use keys.getKey instead
	// - All permission changes are logged in the audit log for security tracking
	Data V2KeysSetPermissionsResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysSetPermissionsResponseData Complete list of all permissions now directly assigned to the key after the set operation has completed.
//
// The response includes:
// - The comprehensive, updated set of direct permissions (reflecting the complete replacement)
// - Both ID and name for each permission for easy reference
// - Permissions sorted alphabetically by name for consistent response format
//
// Important notes:
// - This only shows direct permissions, not those granted through roles
// - An empty array means the key has no direct permissions assigned
// - For a complete permission picture including roles, use keys.getKey instead
// - All permission changes are logged in the audit log for security tracking
type V2KeysSetPermissionsResponseData = []struct {
	// Id The unique identifier of the permission
	Id string `json:"id"`

	// Name The name of the permission
	Name string `json:"name"`
}

// V2KeysSetRolesRequestBody defines model for V2KeysSetRolesRequestBody.
type V2KeysSetRolesRequestBody struct {
	// KeyId The ID of the key for which to set roles (begins with 'key_'). This is the database reference ID for the key, not the actual API key string. This operation will replace all existing direct role assignments for this key.
	KeyId string `json:"keyId"`

	// Roles Complete list of roles to assign to the key. This is a wholesale replacement operation - it replaces all existing direct role assignments with this new set.
	//
	// Key behaviors:
	// - This operation is a complete replacement, not an incremental update
	// - Any existing roles not included in this request will be removed
	// - Providing an empty array removes all direct role assignments from the key
	// - Roles must already exist - they cannot be created on-the-fly like permissions
	// - All roles must belong to the same workspace as the key
	// - Invalid role references will cause the entire operation to fail (atomic transaction)
	// - Changes take effect immediately for new verifications
	//
	// This approach allows you to precisely control the full role set in a single operation, making it ideal for synchronizing roles with external systems or implementing controlled role templates.
	Roles []struct {
		// Id The ID of an existing role (begins with 'role_'). Provide either ID or name, not both. Using role IDs guarantees you're referencing the exact roles intended, regardless of name changes or duplications. This approach is particularly valuable in automation scripts, cross-environment deployments, and systems where role names might change but IDs remain stable.
		Id *string `json:"id,omitempty"`

		// Name The name of the role. Provide either ID or name, not both. Role names must be unique within a workspace, making them generally safe to use as references. Names are more human-readable and easier to work with in configurations, especially when implementing standardized role templates across many keys. However, if roles are renamed, any integrations using name references will need updates.
		Name *string `json:"name,omitempty"`
	} `json:"roles"`
}

// V2KeysSetRolesResponse defines model for V2KeysSetRolesResponse.
type V2KeysSetRolesResponse struct {
	// Data Complete list of all roles now directly assigned to the key after the set operation has completed.
	//
	// The response includes:
	// - The comprehensive, updated set of roles (reflecting the complete replacement)
	// - Both ID and name for each role for easy reference
	// - Roles sorted alphabetically by name for consistent response format
	//
	// Important notes:
	// - This response shows the final state after the complete replacement
	// - If you provided an empty array in the request, this will also be empty
	// - This only shows direct role assignments on the key
	// - Role permissions are not expanded in this response - use keys.getKey for complete details
	// - All role changes are logged in the audit log for security tracking
	// - An empty array indicates the key now has no roles assigned at all
	Data V2KeysSetRolesResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysSetRolesResponseData Complete list of all roles now directly assigned to the key after the set operation has completed.
//
// The response includes:
// - The comprehensive, updated set of roles (reflecting the complete replacement)
// - Both ID and name for each role for easy reference
// - Roles sorted alphabetically by name for consistent response format
//
// Important notes:
// - This response shows the final state after the complete replacement
// - If you provided an empty array in the request, this will also be empty
// - This only shows direct role assignments on the key
// - Role permissions are not expanded in this response - use keys.getKey for complete details
// - All role changes are logged in the audit log for security tracking
// - An empty array indicates the key now has no roles assigned at all
type V2KeysSetRolesResponseData = []struct {
	// Id The unique identifier of the role (begins with 'role_'). This ID can be used in other API calls to reference this specific role. Role IDs are immutable and guaranteed to be unique, making them reliable reference points for integration and automation systems.
	Id string `json:"id"`

	// Name The name of the role. This is a human-readable identifier that's unique within your workspace. Role names are descriptive labels that help identify what access level or function a role provides. Good naming practices include naming by access level ('admin', 'editor'), by department ('billing_team', 'support_staff'), or by feature area ('reporting_user', 'settings_manager').
	Name string `json:"name"`
}

// V2KeysUpdateKeyRequestBody defines model for V2KeysUpdateKeyRequestBody.
type V2KeysUpdateKeyRequestBody struct {
	// Credits Usage limits configuration for this key. Set to null to disable usage limits entirely (unlimited usage). Omit this field to leave all usage limit settings unchanged. Note: Cannot set refill when credits is null; setting refillDay requires interval to be 'monthly'. Use this to implement usage-based pricing models or to apply different quotas for different subscription tiers.
	Credits nullable.Nullable[struct {
		// Refill Configuration for automatic credit refills. Set to null to disable automatic refills (creating a one-time credit allocation). Omit this field to leave existing refill settings unchanged. Use refills to implement recurring quotas that reset on a schedule.
		Refill nullable.Nullable[struct {
			// Amount Number of credits to add during each automatic refill. This typically matches your plan's quota (e.g., 1000 API calls per month).
			Amount int `json:"amount"`

			// Interval How often the credits should be refilled. For 'monthly' refills, you can specify the day of month using 'refillDay'. Use 'daily' for high-frequency use cases (e.g., 100 requests per day) and 'monthly' for subscription-based models.
			Interval V2KeysUpdateKeyRequestBodyCreditsRefillInterval `json:"interval"`

			// RefillDay For monthly refills, the day of month when refills occur. Cannot be used with 'daily' interval. Useful for aligning quota refills with billing cycles or subscription renewal dates.
			RefillDay *int `json:"refillDay,omitempty"`
		}] `json:"refill,omitempty"`

		// Remaining Number of times this key can be used before becoming invalid. Required when specifying credits. Use this to implement usage-based pricing, subscription tiers, or consumption quotas. Each verification reduces this count by the verification cost (default 1).
		Remaining int32 `json:"remaining"`
	}] `json:"credits,omitempty"`

	// Enabled Whether the key is currently active. When set to false, verification attempts will fail with code=DISABLED. This allows temporarily suspending access without deleting the key, which is useful for pausing subscriptions, handling account issues, or during maintenance. Omit this field to leave the enabled status unchanged.
	Enabled *bool `json:"enabled,omitempty"`

	// Expires Unix timestamp (in milliseconds) when this key will automatically expire. After this time, verification will fail with code=EXPIRED. Set to null to remove an expiration date (making the key permanent). Omit this field to leave it unchanged. Useful for extending trials, adjusting subscription periods, or implementing temporary access.
	Expires nullable.Nullable[int64] `json:"expires,omitempty"`

	// ExternalId Your user's unique identifier, creating a link between Unkey and your system. This helps identify which user/entity owns this key during verification. Set to null to disconnect this key from any identity. Omit this field to leave it unchanged. Useful when transferring keys between users or when a user's ID changes in your system.
	ExternalId nullable.Nullable[string] `json:"externalId,omitempty"`

	// KeyId The unique identifier of the key to update (starts with 'key_'). This is the database ID returned from createKey, not the actual API key string itself. Always required for any update operation.
	KeyId string `json:"keyId"`

	// Meta Arbitrary JSON metadata to associate with this key. This data is returned during key verification and can be used to store anything needed during API access: subscription plans, feature flags, user properties, etc. Set to null to remove all metadata. Omit this field to leave it unchanged. This lets you update user context without having to issue new keys.
	Meta nullable.Nullable[map[string]interface{}] `json:"meta,omitempty"`

	// Name A descriptive name for the key for internal reference. Set to null to remove the name. Omit this field to leave it unchanged. Good naming helps with key organization, especially when managing many keys for different users or services.
	Name nullable.Nullable[string] `json:"name,omitempty"`

	// Ratelimits Array of rate limits to apply to this key. Rate limits provide protection against abuse by controlling request frequency. Set to null to remove all rate limits. Omit this field to leave existing rate limits unchanged. Unlike credits (which limit total usage), rate limits are time-based and automatically reset. You can define multiple named rate limits to control different aspects of API usage with different thresholds and time windows.
	Ratelimits nullable.Nullable[[]struct {
		// Async Whether this rate limit uses fast (async=true) or consistent (async=false) mode. Fast mode has lower latency but less accuracy, making it suitable for most use cases. Consistent mode provides stronger guarantees but adds latency to verifications. Use consistent mode only when strict rate limiting is essential.
		Async *bool `json:"async,omitempty"`

		// Duration Duration of the rate limit window in milliseconds. Common values include 60000 (1 minute), 3600000 (1 hour), and 86400000 (24 hours). The rate limit automatically resets after this period elapses.
		Duration int32 `json:"duration"`

		// Limit Maximum number of operations allowed within the time window. When this limit is reached, verification fails with code=RATE_LIMITED until the window resets. Adjust this based on your API's capacity and the user's expected usage patterns.
		Limit int32 `json:"limit"`

		// Name Identifier for this rate limit. Names must be unique for this key. Use semantic names reflecting what's being limited, such as 'requests' (overall API calls), 'computations' (intensive operations), or 'write_operations' (data-modifying calls).
		Name string `json:"name"`
	}] `json:"ratelimits,omitempty"`
}

// V2KeysUpdateKeyRequestBodyCreditsRefillInterval How often the credits should be refilled. For 'monthly' refills, you can specify the day of month using 'refillDay'. Use 'daily' for high-frequency use cases (e.g., 100 requests per day) and 'monthly' for subscription-based models.
type V2KeysUpdateKeyRequestBodyCreditsRefillInterval string

// V2KeysUpdateKeyResponseBody defines model for V2KeysUpdateKeyResponseBody.
type V2KeysUpdateKeyResponseBody struct {
	// Data Empty response object by design. A successful response indicates the key was updated successfully. The endpoint doesn't return the updated key to reduce response size and avoid exposing sensitive information. Changes may take up to 30 seconds to propagate to all regions due to cache invalidation delays. If you need the updated key state, use a subsequent call to keys.getKey.
	Data *KeysUpdateKeyResponseData `json:"data,omitempty"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysUpdateRemainingRequestBody defines model for V2KeysUpdateRemainingRequestBody.
type V2KeysUpdateRemainingRequestBody struct {
	// KeyId The ID of the key to update (begins with 'key_'). This is the database reference ID for the key, not the actual API key string that users authenticate with. This ID uniquely identifies which key's credits will be updated.
	KeyId string `json:"keyId"`

	// OverwriteRefillSettings When true, any existing automatic refill settings will be removed from the key.
	//
	// Use cases:
	// - Convert a key with automatic periodic refills to a one-time credit allocation
	// - Remove subscription-like behavior in favor of manually controlled credits
	// - Downgrade from an automatic plan to a fixed allocation
	// - Simplify credit management by removing automated refills
	//
	// When false or omitted, existing refill settings are preserved, and only the current remaining value is updated. This lets you adjust the current balance without changing the refill schedule.
	OverwriteRefillSettings *bool `json:"overwriteRefillSettings,omitempty"`

	// Remaining The new value for the remaining credits. This is an absolute value replacement, not an increment or decrement operation.
	//
	// Key behaviors:
	// - This completely replaces the current remaining credits value
	// - To add credits, first get the current value and then set remaining = current + additional
	// - To make a key unlimited, set remaining = -1
	// - To make a key with unlimited usage have a specific limit, set remaining to a positive number
	// - Credits are decremented each time the key is successfully verified (by the cost value, default 1)
	// - When credits reach zero, verification fails with code=USAGE_EXCEEDED
	//
	// This field is useful for implementing usage-based pricing, subscription tiers, trial periods, or consumption quotas.
	Remaining int64 `json:"remaining"`
}

// V2KeysUpdateRemainingResponse defines model for V2KeysUpdateRemainingResponse.
type V2KeysUpdateRemainingResponse struct {
	Data KeysUpdateRemainingResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysVerifyKeyRequestBody defines model for V2KeysVerifyKeyRequestBody.
type V2KeysVerifyKeyRequestBody struct {
	// ApiId The ID of the API this key belongs to. This is required to ensure keys from different environments (dev/staging/prod) or different services don't leak between contexts. You should store this API ID alongside your service configuration.
	ApiId string `json:"apiId"`

	// Credits Optional configuration for how this request should affect the key's remaining usage credits. Credits provide a globally consistent mechanism for limiting key usage, ideal for paid APIs with strict usage limits.
	Credits *struct {
		// Cost The number of credits to deduct for this verification. Set to 0 to validate the key without consuming credits (useful for read-only or free operations). Set higher for premium/expensive operations. This allows implementing tiered usage within a single API.
		Cost *int32 `json:"cost,omitempty"`
	} `json:"credits,omitempty"`

	// Key The API key to verify. This is the full string provided by your user - including any prefix. Unkey uses a secure hashing algorithm to verify the key without storing the plaintext value. SECURITY NOTICE: Never log or store API keys in your system.
	Key string `json:"key"`

	// Permissions Optional RBAC permission checks to verify the key has the required permissions. If provided, the verification will only succeed if the key has the specified permissions (either directly or through roles). This is the recommended way to implement authorization in your API.
	Permissions *V2KeysVerifyKeyRequestBody_Permissions `json:"permissions,omitempty"`

	// Ratelimits Optional array of ratelimits to check during verification. Ratelimits provide protection against abuse by limiting the frequency of operations. Multiple named ratelimits can be used to control different aspects of your API. Unlike credits, ratelimits are optimized for performance with eventual consistency.
	Ratelimits *[]struct {
		// Cost The cost of this operation against the ratelimit. Higher values consume more of the ratelimit quota. Use this to model operations with different weights.
		Cost *int32 `json:"cost,omitempty"`

		// Duration Temporarily override the ratelimit window duration in milliseconds for this request only. This won't change the stored configuration.
		Duration *int32 `json:"duration,omitempty"`

		// Limit Temporarily override the configured limit for this request only. This won't change the stored configuration.
		Limit *int32 `json:"limit,omitempty"`

		// Name The name of the ratelimit to check. This must match a ratelimit configured for the key or identity. Use semantic names like 'requests', 'computations', or 'heavy_operations'.
		Name string `json:"name"`
	} `json:"ratelimits,omitempty"`

	// Tags Optional metadata tags for analytics and monitoring. These don't affect verification outcomes but let you segment API usage in analytics dashboards. Good uses include tracking endpoints, client versions, regions, or request details. Format as 'key=value' for best compatibility with analytics tools.
	Tags *[]string `json:"tags,omitempty"`
}

// V2KeysVerifyKeyRequestBodyPermissions0 A single permission to check. The key is valid only if it has this exact permission. Permission checks are hierarchical - a key with permission 'documents.*' will have access to 'documents.read' and 'documents.write'.
type V2KeysVerifyKeyRequestBodyPermissions0 = string

// V2KeysVerifyKeyRequestBodyPermissions1 defines model for .
type V2KeysVerifyKeyRequestBodyPermissions1 struct {
	// Permissions List of permissions to check against the key's assigned permissions and roles.
	Permissions []string `json:"permissions"`

	// Type Logical operator to apply to the permissions. 'and' requires all permissions to be present, 'or' requires at least one.
	Type V2KeysVerifyKeyRequestBodyPermissions1Type `json:"type"`
}

// V2KeysVerifyKeyRequestBodyPermissions1Type Logical operator to apply to the permissions. 'and' requires all permissions to be present, 'or' requires at least one.
type V2KeysVerifyKeyRequestBodyPermissions1Type string

// V2KeysVerifyKeyRequestBody_Permissions Optional RBAC permission checks to verify the key has the required permissions. If provided, the verification will only succeed if the key has the specified permissions (either directly or through roles). This is the recommended way to implement authorization in your API.
type V2KeysVerifyKeyRequestBody_Permissions struct {
	union json.RawMessage
}

// V2KeysVerifyKeyResponseBody defines model for V2KeysVerifyKeyResponseBody.
type V2KeysVerifyKeyResponseBody struct {
	Data KeysVerifyKeyResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2KeysWhoamiRequestBody defines model for V2KeysWhoamiRequestBody.
type V2KeysWhoamiRequestBody struct {
	// Key The API key to identify and retrieve information about
	Key string `json:"key"`
}

// V2KeysWhoamiResponse defines model for V2KeysWhoamiResponse.
type V2KeysWhoamiResponse struct {
	Data KeyWhoamiData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2LivenessResponseBody defines model for V2LivenessResponseBody.
type V2LivenessResponseBody struct {
	// Data Response data for the liveness check endpoint. This provides a simple indication of whether the Unkey API service is running and able to process requests. Monitoring systems can use this endpoint to track service availability and trigger alerts if the service becomes unhealthy.
	Data LivenessResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2PermissionsCreatePermissionRequestBody defines model for V2PermissionsCreatePermissionRequestBody.
type V2PermissionsCreatePermissionRequestBody struct {
	// Description Explain what this permission does. This is just for your team, your users will not see this.
	Description *string `json:"description,omitempty"`

	// Name The unique name of your permission
	Name string `json:"name"`

	// Slug The unique slug identifier for your permission, used for URL-safe references. Only alphanumeric characters, periods, underscores, and dashes are allowed.
	Slug string `json:"slug"`
}

// V2PermissionsCreatePermissionResponseBody defines model for V2PermissionsCreatePermissionResponseBody.
type V2PermissionsCreatePermissionResponseBody struct {
	Data PermissionsCreatePermissionResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2PermissionsCreateRoleRequestBody defines model for V2PermissionsCreateRoleRequestBody.
type V2PermissionsCreateRoleRequestBody struct {
	// Description Explain what this role does. This is just for your team, your users will not see this.
	Description *string `json:"description,omitempty"`

	// Name The unique name of your role
	Name string `json:"name"`
}

// V2PermissionsCreateRoleResponseBody defines model for V2PermissionsCreateRoleResponseBody.
type V2PermissionsCreateRoleResponseBody struct {
	Data PermissionsCreateRoleResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2PermissionsDeletePermissionRequestBody defines model for V2PermissionsDeletePermissionRequestBody.
type V2PermissionsDeletePermissionRequestBody struct {
	// PermissionId The id of the permission to delete
	PermissionId string `json:"permissionId"`
}

// V2PermissionsDeletePermissionResponseBody defines model for V2PermissionsDeletePermissionResponseBody.
type V2PermissionsDeletePermissionResponseBody struct {
	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2PermissionsDeleteRoleRequestBody defines model for V2PermissionsDeleteRoleRequestBody.
type V2PermissionsDeleteRoleRequestBody struct {
	// RoleId The id of the role to delete
	RoleId string `json:"roleId"`
}

// V2PermissionsDeleteRoleResponseBody defines model for V2PermissionsDeleteRoleResponseBody.
type V2PermissionsDeleteRoleResponseBody struct {
	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2PermissionsGetPermissionRequestBody defines model for V2PermissionsGetPermissionRequestBody.
type V2PermissionsGetPermissionRequestBody struct {
	// PermissionId The id of the permission to retrieve
	PermissionId string `json:"permissionId"`
}

// V2PermissionsGetPermissionResponseBody defines model for V2PermissionsGetPermissionResponseBody.
type V2PermissionsGetPermissionResponseBody struct {
	Data PermissionsGetPermissionResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2PermissionsGetRoleRequestBody defines model for V2PermissionsGetRoleRequestBody.
type V2PermissionsGetRoleRequestBody struct {
	// RoleId The id of the role to retrieve
	RoleId string `json:"roleId"`
}

// V2PermissionsGetRoleResponseBody defines model for V2PermissionsGetRoleResponseBody.
type V2PermissionsGetRoleResponseBody struct {
	Data PermissionsGetRoleResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2PermissionsListPermissionsRequestBody defines model for V2PermissionsListPermissionsRequestBody.
type V2PermissionsListPermissionsRequestBody struct {
	// Cursor Cursor for pagination
	Cursor *string `json:"cursor,omitempty"`
}

// V2PermissionsListPermissionsResponseBody defines model for V2PermissionsListPermissionsResponseBody.
type V2PermissionsListPermissionsResponseBody struct {
	Data PermissionsListPermissionsResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta       Meta        `json:"meta"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

// V2PermissionsListRolesRequestBody defines model for V2PermissionsListRolesRequestBody.
type V2PermissionsListRolesRequestBody struct {
	// Cursor Cursor for pagination
	Cursor *string `json:"cursor,omitempty"`

	// Limit The maximum number of roles to return
	Limit *int32 `json:"limit,omitempty"`
}

// V2PermissionsListRolesResponseBody defines model for V2PermissionsListRolesResponseBody.
type V2PermissionsListRolesResponseBody struct {
	Data PermissionsListRolesResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta       Meta        `json:"meta"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

// V2RatelimitDeleteOverrideRequestBody Deletes an existing rate limit override. This permanently removes a custom rate limit rule, reverting affected identifiers back to the default rate limits for the namespace.
//
// Use this endpoint when you need to:
// - Remove special rate limit rules that are no longer needed
// - Reset entities back to standard rate limits
// - Clean up temporary overrides
// - Remove outdated tiering or custom limit rules
// - Fix misconfigured overrides
//
// Once deleted, the override cannot be recovered, and the operation takes effect immediately.
type V2RatelimitDeleteOverrideRequestBody struct {
	// Identifier The exact identifier pattern of the override to delete. This must match exactly as it was specified when creating the override.
	//
	// Important notes:
	// - This is case-sensitive and must match exactly
	// - Include any wildcards (*) that were part of the original pattern
	// - For example, if the override was created for 'premium_*', you must use 'premium_*' here, not a specific ID
	//
	// After deletion, any identifiers previously affected by this override will immediately revert to using the default rate limit for the namespace.
	Identifier string `json:"identifier"`

	// NamespaceId The unique ID of the rate limit namespace containing the override. Either namespaceId or namespaceName must be provided, but not both. Using namespaceId is more precise and less prone to naming conflicts, making it ideal for automation and scripts.
	NamespaceId *string `json:"namespaceId,omitempty"`

	// NamespaceName The name of the rate limit namespace containing the override. Either namespaceId or namespaceName must be provided, but not both. Using namespaceName is more human-readable and convenient for manual operations and configurations.
	NamespaceName *string `json:"namespaceName,omitempty"`
}

// V2RatelimitDeleteOverrideResponseBody defines model for V2RatelimitDeleteOverrideResponseBody.
type V2RatelimitDeleteOverrideResponseBody struct {
	// Data Empty response object. A successful response indicates the override was successfully deleted. The operation is immediate - as soon as this response is received, the override no longer exists and affected identifiers have reverted to using the default rate limit for the namespace. No other data is returned as part of the deletion operation.
	Data RatelimitDeleteOverrideResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2RatelimitGetOverrideRequestBody Gets the configuration of an existing rate limit override. Use this to retrieve details about custom rate limit rules that have been created for specific identifiers within a namespace.
//
// This endpoint is useful for:
// - Verifying override configurations
// - Checking current limits for specific entities
// - Auditing rate limit policies
// - Debugging rate limiting behavior
// - Retrieving override settings for modification
type V2RatelimitGetOverrideRequestBody struct {
	// Identifier The exact identifier pattern for the override you want to retrieve. This must match exactly as it was specified when creating the override.
	//
	// Important notes:
	// - This is case-sensitive and must match exactly
	// - Include any wildcards (*) that were part of the original pattern
	// - For example, if the override was created for 'premium_*', you must use 'premium_*' here, not a specific ID like 'premium_user1'
	//
	// This field is used to look up the specific override configuration for this pattern.
	Identifier string `json:"identifier"`

	// NamespaceId The unique ID of the rate limit namespace. Either namespaceId or namespaceName must be provided, but not both. Using namespaceId is more precise and less prone to naming conflicts, making it ideal for scripts and automated operations.
	NamespaceId *string `json:"namespaceId,omitempty"`

	// NamespaceName The name of the rate limit namespace. Either namespaceId or namespaceName must be provided, but not both. Using namespaceName is more human-readable and easier to work with for manual operations and configurations.
	NamespaceName *string `json:"namespaceName,omitempty"`
}

// V2RatelimitGetOverrideResponseBody defines model for V2RatelimitGetOverrideResponseBody.
type V2RatelimitGetOverrideResponseBody struct {
	Data RatelimitOverride `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2RatelimitLimitRequestBody defines model for V2RatelimitLimitRequestBody.
type V2RatelimitLimitRequestBody struct {
	// Cost The cost of the request against the rate limit. This allows different operations to consume varying amounts of the rate limit quota.
	//
	// Common use cases:
	// - Set to 1 (default) for standard operations
	// - Set higher values (e.g., 5, 10) for resource-intensive operations
	// - Set to 0 for operations that should be tracked but not count against limits
	// - Use weighted costs to implement fair queuing or priority systems
	//
	// When the total accrued cost exceeds the limit within the duration window, subsequent requests will be rejected.
	Cost *int64 `json:"cost,omitempty"`

	// Duration The duration in milliseconds for the rate limit window. After this period elapses, the rate limit counter resets.
	//
	// Common values:
	// - 1000 (1 second): For very strict, per-second limits
	// - 60000 (1 minute): For standard API rate limiting
	// - 3600000 (1 hour): For less frequent but resource-intensive operations
	// - 86400000 (24 hours): For daily quotas
	//
	// The duration affects how quickly users can retry after hitting limits. Shorter durations allow faster recovery but may be less effective against certain abuse patterns.
	Duration int64 `json:"duration"`

	// Identifier The unique identifier for the entity being rate limited. This defines the scope of the rate limit and is typically:
	//
	// - A user ID for per-user limits
	// - An IP address for anonymous rate limiting
	// - An API key ID for per-key limits
	// - A session ID for per-session limits
	// - A tenant/organization ID for organizational limits
	//
	// The same identifier can be used across different namespaces to apply multiple types of limits to the same entity.
	Identifier string `json:"identifier"`

	// Limit The maximum number of operations (adjusted by cost) allowed within the time window. When this limit is reached, subsequent requests will be rejected with a RATE_LIMITED response.
	//
	// Considerations for setting limits:
	// - Balance between user experience and resource protection
	// - Different limits for different user tiers or subscription levels
	// - Higher limits for authenticated vs. unauthenticated requests
	// - System capacity and scaling limitations
	// - Business requirements and fair usage policies
	Limit int64 `json:"limit"`

	// Namespace The namespace name for the rate limit. Namespaces provide a way to organize and segment different rate limits in your application.
	//
	// Best practices for namespaces:
	// - Use descriptive, hierarchical names (e.g., 'auth.login', 'api.requests', 'media.uploads')
	// - Create separate namespaces for different resources or operations
	// - Keep naming conventions consistent across your application
	// - Consider service or feature-based namespaces for easier monitoring
	//
	// Namespaces are unique within your workspace, so choose names that clearly indicate their purpose.
	Namespace string `json:"namespace"`
}

// V2RatelimitLimitResponseBody defines model for V2RatelimitLimitResponseBody.
type V2RatelimitLimitResponseBody struct {
	Data RatelimitLimitResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// V2RatelimitListOverridesRequestBody defines model for V2RatelimitListOverridesRequestBody.
type V2RatelimitListOverridesRequestBody struct {
	// Cursor Pagination cursor from a previous response. Include this when fetching subsequent pages of results. Each response containing more results than the requested limit will include a cursor value in the pagination object that can be used here.
	Cursor *string `json:"cursor,omitempty"`

	// Limit Maximum number of override entries to return in a single response. Use this to control response size and loading performance.
	//
	// - Lower values (10-20): Better for UI displays and faster response times
	// - Higher values (50-100): Better for data exports or bulk operations
	// - Default (10): Suitable for most dashboard views
	//
	// Results exceeding this limit will be paginated, with a cursor provided for fetching subsequent pages.
	Limit *int `json:"limit,omitempty"`

	// NamespaceId The unique ID of the rate limit namespace to list overrides for. Either namespaceId or namespaceName must be provided, but not both. Using namespaceId guarantees you're targeting the exact namespace intended, even if names change over time.
	NamespaceId *string `json:"namespaceId,omitempty"`

	// NamespaceName The name of the rate limit namespace to list overrides for. Either namespaceId or namespaceName must be provided, but not both. Using namespaceName is more human-readable and convenient for manual operations and dashboards.
	NamespaceName *string `json:"namespaceName,omitempty"`
}

// V2RatelimitListOverridesResponseBody defines model for V2RatelimitListOverridesResponseBody.
type V2RatelimitListOverridesResponseBody struct {
	Data RatelimitListOverridesResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta       Meta        `json:"meta"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

// V2RatelimitSetOverrideRequestBody Sets a new or overwrites an existing rate limit override. Overrides allow you to apply special rate limit rules to specific identifiers, providing custom limits that differ from the default.
//
// Overrides are useful for:
// - Granting higher limits to premium users or trusted partners
// - Implementing stricter limits for suspicious or abusive users
// - Creating tiered access levels with different quotas
// - Implementing temporary rate limit adjustments
// - Prioritizing important clients with higher limits
type V2RatelimitSetOverrideRequestBody struct {
	// Duration The duration in milliseconds for the rate limit window. This defines how long the rate limit counter accumulates before resetting to zero.
	//
	// Considerations:
	// - This can differ from the default duration for the namespace
	// - Longer durations create stricter limits that take longer to reset
	// - Shorter durations allow more frequent bursts of activity
	// - Common values: 60000 (1 minute), 3600000 (1 hour), 86400000 (1 day)
	Duration int64 `json:"duration"`

	// Identifier Identifier of the entity receiving this custom rate limit. This can be:
	//
	// - A specific user ID for individual custom limits
	// - An IP address for location-based rules
	// - An email domain for organization-wide policies
	// - Any other string that identifies the target entity
	//
	// Wildcards (*) can be used to create pattern-matching rules that apply to multiple identifiers. For example:
	// - 'premium_*' would match all identifiers starting with 'premium_'
	// - '*_admin' would match all identifiers ending with '_admin'
	// - '*suspicious*' would match any identifier containing 'suspicious'
	//
	// More detailed information on wildcard pattern rules is available at https://www.unkey.com/docs/ratelimiting/overrides#wildcard-rules
	Identifier string `json:"identifier"`

	// Limit The maximum number of requests allowed for this override. This defines the custom quota for the specified identifier(s).
	//
	// Special values:
	// - Higher than default: For premium or trusted entities
	// - Lower than default: For suspicious or abusive entities
	// - 0: To completely block access (useful for ban implementation)
	//
	// This limit entirely replaces the default limit for matching identifiers.
	Limit int64 `json:"limit"`

	// NamespaceId The unique ID of the rate limit namespace. Either namespaceId or namespaceName must be provided, but not both. Using namespaceId guarantees you're targeting the exact namespace intended, even if names change, making it ideal for automation and scripts.
	NamespaceId *string `json:"namespaceId,omitempty"`

	// NamespaceName The name of the rate limit namespace. Either namespaceId or namespaceName must be provided, but not both. Using namespaceName is more human-readable and convenient for manual operations and configurations.
	NamespaceName *string `json:"namespaceName,omitempty"`
}

// V2RatelimitSetOverrideResponseBody defines model for V2RatelimitSetOverrideResponseBody.
type V2RatelimitSetOverrideResponseBody struct {
	Data RatelimitSetOverrideResponseData `json:"data"`

	// Meta Metadata object included in every API response. This provides context about the request and is essential for debugging, audit trails, and support inquiries. The requestId is particularly important when troubleshooting issues with the Unkey support team.
	Meta Meta `json:"meta"`
}

// ValidationError Detailed information about a specific validation error in a request. Each validation error pinpoints exactly what part of the request failed validation, why it failed, and how to fix it. Multiple validation errors may be returned in a single response when there are issues with multiple fields or parameters.
type ValidationError struct {
	// Fix A human-readable suggestion describing how to fix the error. This provides practical guidance on what changes would satisfy the validation requirements. Not all validation errors include fix suggestions, but when present, they offer specific remediation advice.
	Fix *string `json:"fix,omitempty"`

	// Location JSON path indicating exactly where in the request the error occurred. This helps pinpoint the problematic field or parameter. Examples include:
	// - 'body.name' (field in request body)
	// - 'body.items[3].tags' (nested array element)
	// - 'path.apiId' (path parameter)
	// - 'query.limit' (query parameter)
	//
	// Use this location to identify exactly which part of your request needs correction.
	Location string `json:"location"`

	// Message Detailed error message explaining what validation rule was violated. This provides specific information about why the field or parameter was rejected, such as format errors, invalid values, or constraint violations.
	Message string `json:"message"`
}

// CreateApiJSONRequestBody defines body for CreateApi for application/json ContentType.
type CreateApiJSONRequestBody = V2ApisCreateApiRequestBody

// DeleteApiJSONRequestBody defines body for DeleteApi for application/json ContentType.
type DeleteApiJSONRequestBody = V2ApisDeleteApiRequestBody

// GetApiJSONRequestBody defines body for GetApi for application/json ContentType.
type GetApiJSONRequestBody = V2ApisGetApiRequestBody

// ListKeysJSONRequestBody defines body for ListKeys for application/json ContentType.
type ListKeysJSONRequestBody = V2ApisListKeysRequestBody

// IdentitiesCreateIdentityJSONRequestBody defines body for IdentitiesCreateIdentity for application/json ContentType.
type IdentitiesCreateIdentityJSONRequestBody = V2IdentitiesCreateIdentityRequestBody

// V2IdentitiesDeleteIdentityJSONRequestBody defines body for V2IdentitiesDeleteIdentity for application/json ContentType.
type V2IdentitiesDeleteIdentityJSONRequestBody = V2IdentitiesDeleteIdentityRequestBody

// IdentitiesGetIdentityJSONRequestBody defines body for IdentitiesGetIdentity for application/json ContentType.
type IdentitiesGetIdentityJSONRequestBody = V2IdentitiesGetIdentityRequestBody

// IdentitiesListIdentitiesJSONRequestBody defines body for IdentitiesListIdentities for application/json ContentType.
type IdentitiesListIdentitiesJSONRequestBody = V2IdentitiesListIdentitiesRequestBody

// V2IdentitiesUpdateIdentityJSONRequestBody defines body for V2IdentitiesUpdateIdentity for application/json ContentType.
type V2IdentitiesUpdateIdentityJSONRequestBody = V2IdentitiesUpdateIdentityRequestBody

// AddPermissionsJSONRequestBody defines body for AddPermissions for application/json ContentType.
type AddPermissionsJSONRequestBody = V2KeysAddPermissionsRequestBody

// AddRolesJSONRequestBody defines body for AddRoles for application/json ContentType.
type AddRolesJSONRequestBody = V2KeysAddRolesRequestBody

// CreateKeyJSONRequestBody defines body for CreateKey for application/json ContentType.
type CreateKeyJSONRequestBody = V2KeysCreateKeyRequestBody

// DeleteKeyJSONRequestBody defines body for DeleteKey for application/json ContentType.
type DeleteKeyJSONRequestBody = V2KeysDeleteKeyRequestBody

// GetKeyJSONRequestBody defines body for GetKey for application/json ContentType.
type GetKeyJSONRequestBody = V2KeysGetKeyRequestBody

// RemovePermissionsJSONRequestBody defines body for RemovePermissions for application/json ContentType.
type RemovePermissionsJSONRequestBody = V2KeysRemovePermissionsRequestBody

// RemoveRolesJSONRequestBody defines body for RemoveRoles for application/json ContentType.
type RemoveRolesJSONRequestBody = V2KeysRemoveRolesRequestBody

// SetPermissionsJSONRequestBody defines body for SetPermissions for application/json ContentType.
type SetPermissionsJSONRequestBody = V2KeysSetPermissionsRequestBody

// SetRolesJSONRequestBody defines body for SetRoles for application/json ContentType.
type SetRolesJSONRequestBody = V2KeysSetRolesRequestBody

// UpdateKeyJSONRequestBody defines body for UpdateKey for application/json ContentType.
type UpdateKeyJSONRequestBody = V2KeysUpdateKeyRequestBody

// UpdateRemainingJSONRequestBody defines body for UpdateRemaining for application/json ContentType.
type UpdateRemainingJSONRequestBody = V2KeysUpdateRemainingRequestBody

// VerifyKeyJSONRequestBody defines body for VerifyKey for application/json ContentType.
type VerifyKeyJSONRequestBody = V2KeysVerifyKeyRequestBody

// WhoamiJSONRequestBody defines body for Whoami for application/json ContentType.
type WhoamiJSONRequestBody = V2KeysWhoamiRequestBody

// CreatePermissionJSONRequestBody defines body for CreatePermission for application/json ContentType.
type CreatePermissionJSONRequestBody = V2PermissionsCreatePermissionRequestBody

// CreateRoleJSONRequestBody defines body for CreateRole for application/json ContentType.
type CreateRoleJSONRequestBody = V2PermissionsCreateRoleRequestBody

// DeletePermissionJSONRequestBody defines body for DeletePermission for application/json ContentType.
type DeletePermissionJSONRequestBody = V2PermissionsDeletePermissionRequestBody

// DeleteRoleJSONRequestBody defines body for DeleteRole for application/json ContentType.
type DeleteRoleJSONRequestBody = V2PermissionsDeleteRoleRequestBody

// GetPermissionJSONRequestBody defines body for GetPermission for application/json ContentType.
type GetPermissionJSONRequestBody = V2PermissionsGetPermissionRequestBody

// GetRoleJSONRequestBody defines body for GetRole for application/json ContentType.
type GetRoleJSONRequestBody = V2PermissionsGetRoleRequestBody

// ListPermissionsJSONRequestBody defines body for ListPermissions for application/json ContentType.
type ListPermissionsJSONRequestBody = V2PermissionsListPermissionsRequestBody

// ListRolesJSONRequestBody defines body for ListRoles for application/json ContentType.
type ListRolesJSONRequestBody = V2PermissionsListRolesRequestBody

// RatelimitDeleteOverrideJSONRequestBody defines body for RatelimitDeleteOverride for application/json ContentType.
type RatelimitDeleteOverrideJSONRequestBody = V2RatelimitDeleteOverrideRequestBody

// RatelimitGetOverrideJSONRequestBody defines body for RatelimitGetOverride for application/json ContentType.
type RatelimitGetOverrideJSONRequestBody = V2RatelimitGetOverrideRequestBody

// RatelimitLimitJSONRequestBody defines body for RatelimitLimit for application/json ContentType.
type RatelimitLimitJSONRequestBody = V2RatelimitLimitRequestBody

// RatelimitListOverridesJSONRequestBody defines body for RatelimitListOverrides for application/json ContentType.
type RatelimitListOverridesJSONRequestBody = V2RatelimitListOverridesRequestBody

// RatelimitSetOverrideJSONRequestBody defines body for RatelimitSetOverride for application/json ContentType.
type RatelimitSetOverrideJSONRequestBody = V2RatelimitSetOverrideRequestBody

// AsV2IdentitiesDeleteIdentityRequestBody0 returns the union data inside the V2IdentitiesDeleteIdentityRequestBody as a V2IdentitiesDeleteIdentityRequestBody0
func (t V2IdentitiesDeleteIdentityRequestBody) AsV2IdentitiesDeleteIdentityRequestBody0() (V2IdentitiesDeleteIdentityRequestBody0, error) {
	var body V2IdentitiesDeleteIdentityRequestBody0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2IdentitiesDeleteIdentityRequestBody0 overwrites any union data inside the V2IdentitiesDeleteIdentityRequestBody as the provided V2IdentitiesDeleteIdentityRequestBody0
func (t *V2IdentitiesDeleteIdentityRequestBody) FromV2IdentitiesDeleteIdentityRequestBody0(v V2IdentitiesDeleteIdentityRequestBody0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2IdentitiesDeleteIdentityRequestBody0 performs a merge with any union data inside the V2IdentitiesDeleteIdentityRequestBody, using the provided V2IdentitiesDeleteIdentityRequestBody0
func (t *V2IdentitiesDeleteIdentityRequestBody) MergeV2IdentitiesDeleteIdentityRequestBody0(v V2IdentitiesDeleteIdentityRequestBody0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV2IdentitiesDeleteIdentityRequestBody1 returns the union data inside the V2IdentitiesDeleteIdentityRequestBody as a V2IdentitiesDeleteIdentityRequestBody1
func (t V2IdentitiesDeleteIdentityRequestBody) AsV2IdentitiesDeleteIdentityRequestBody1() (V2IdentitiesDeleteIdentityRequestBody1, error) {
	var body V2IdentitiesDeleteIdentityRequestBody1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2IdentitiesDeleteIdentityRequestBody1 overwrites any union data inside the V2IdentitiesDeleteIdentityRequestBody as the provided V2IdentitiesDeleteIdentityRequestBody1
func (t *V2IdentitiesDeleteIdentityRequestBody) FromV2IdentitiesDeleteIdentityRequestBody1(v V2IdentitiesDeleteIdentityRequestBody1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2IdentitiesDeleteIdentityRequestBody1 performs a merge with any union data inside the V2IdentitiesDeleteIdentityRequestBody, using the provided V2IdentitiesDeleteIdentityRequestBody1
func (t *V2IdentitiesDeleteIdentityRequestBody) MergeV2IdentitiesDeleteIdentityRequestBody1(v V2IdentitiesDeleteIdentityRequestBody1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V2IdentitiesDeleteIdentityRequestBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.ExternalId != nil {
		object["externalId"], err = json.Marshal(t.ExternalId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'externalId': %w", err)
		}
	}

	if t.IdentityId != nil {
		object["identityId"], err = json.Marshal(t.IdentityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'identityId': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *V2IdentitiesDeleteIdentityRequestBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["externalId"]; found {
		err = json.Unmarshal(raw, &t.ExternalId)
		if err != nil {
			return fmt.Errorf("error reading 'externalId': %w", err)
		}
	}

	if raw, found := object["identityId"]; found {
		err = json.Unmarshal(raw, &t.IdentityId)
		if err != nil {
			return fmt.Errorf("error reading 'identityId': %w", err)
		}
	}

	return err
}

// AsV2IdentitiesGetIdentityRequestBody0 returns the union data inside the V2IdentitiesGetIdentityRequestBody as a V2IdentitiesGetIdentityRequestBody0
func (t V2IdentitiesGetIdentityRequestBody) AsV2IdentitiesGetIdentityRequestBody0() (V2IdentitiesGetIdentityRequestBody0, error) {
	var body V2IdentitiesGetIdentityRequestBody0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2IdentitiesGetIdentityRequestBody0 overwrites any union data inside the V2IdentitiesGetIdentityRequestBody as the provided V2IdentitiesGetIdentityRequestBody0
func (t *V2IdentitiesGetIdentityRequestBody) FromV2IdentitiesGetIdentityRequestBody0(v V2IdentitiesGetIdentityRequestBody0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2IdentitiesGetIdentityRequestBody0 performs a merge with any union data inside the V2IdentitiesGetIdentityRequestBody, using the provided V2IdentitiesGetIdentityRequestBody0
func (t *V2IdentitiesGetIdentityRequestBody) MergeV2IdentitiesGetIdentityRequestBody0(v V2IdentitiesGetIdentityRequestBody0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV2IdentitiesGetIdentityRequestBody1 returns the union data inside the V2IdentitiesGetIdentityRequestBody as a V2IdentitiesGetIdentityRequestBody1
func (t V2IdentitiesGetIdentityRequestBody) AsV2IdentitiesGetIdentityRequestBody1() (V2IdentitiesGetIdentityRequestBody1, error) {
	var body V2IdentitiesGetIdentityRequestBody1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2IdentitiesGetIdentityRequestBody1 overwrites any union data inside the V2IdentitiesGetIdentityRequestBody as the provided V2IdentitiesGetIdentityRequestBody1
func (t *V2IdentitiesGetIdentityRequestBody) FromV2IdentitiesGetIdentityRequestBody1(v V2IdentitiesGetIdentityRequestBody1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2IdentitiesGetIdentityRequestBody1 performs a merge with any union data inside the V2IdentitiesGetIdentityRequestBody, using the provided V2IdentitiesGetIdentityRequestBody1
func (t *V2IdentitiesGetIdentityRequestBody) MergeV2IdentitiesGetIdentityRequestBody1(v V2IdentitiesGetIdentityRequestBody1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V2IdentitiesGetIdentityRequestBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.ExternalId != nil {
		object["externalId"], err = json.Marshal(t.ExternalId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'externalId': %w", err)
		}
	}

	if t.IdentityId != nil {
		object["identityId"], err = json.Marshal(t.IdentityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'identityId': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *V2IdentitiesGetIdentityRequestBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["externalId"]; found {
		err = json.Unmarshal(raw, &t.ExternalId)
		if err != nil {
			return fmt.Errorf("error reading 'externalId': %w", err)
		}
	}

	if raw, found := object["identityId"]; found {
		err = json.Unmarshal(raw, &t.IdentityId)
		if err != nil {
			return fmt.Errorf("error reading 'identityId': %w", err)
		}
	}

	return err
}

// AsV2IdentitiesUpdateIdentityRequestBody0 returns the union data inside the V2IdentitiesUpdateIdentityRequestBody as a V2IdentitiesUpdateIdentityRequestBody0
func (t V2IdentitiesUpdateIdentityRequestBody) AsV2IdentitiesUpdateIdentityRequestBody0() (V2IdentitiesUpdateIdentityRequestBody0, error) {
	var body V2IdentitiesUpdateIdentityRequestBody0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2IdentitiesUpdateIdentityRequestBody0 overwrites any union data inside the V2IdentitiesUpdateIdentityRequestBody as the provided V2IdentitiesUpdateIdentityRequestBody0
func (t *V2IdentitiesUpdateIdentityRequestBody) FromV2IdentitiesUpdateIdentityRequestBody0(v V2IdentitiesUpdateIdentityRequestBody0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2IdentitiesUpdateIdentityRequestBody0 performs a merge with any union data inside the V2IdentitiesUpdateIdentityRequestBody, using the provided V2IdentitiesUpdateIdentityRequestBody0
func (t *V2IdentitiesUpdateIdentityRequestBody) MergeV2IdentitiesUpdateIdentityRequestBody0(v V2IdentitiesUpdateIdentityRequestBody0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV2IdentitiesUpdateIdentityRequestBody1 returns the union data inside the V2IdentitiesUpdateIdentityRequestBody as a V2IdentitiesUpdateIdentityRequestBody1
func (t V2IdentitiesUpdateIdentityRequestBody) AsV2IdentitiesUpdateIdentityRequestBody1() (V2IdentitiesUpdateIdentityRequestBody1, error) {
	var body V2IdentitiesUpdateIdentityRequestBody1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2IdentitiesUpdateIdentityRequestBody1 overwrites any union data inside the V2IdentitiesUpdateIdentityRequestBody as the provided V2IdentitiesUpdateIdentityRequestBody1
func (t *V2IdentitiesUpdateIdentityRequestBody) FromV2IdentitiesUpdateIdentityRequestBody1(v V2IdentitiesUpdateIdentityRequestBody1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2IdentitiesUpdateIdentityRequestBody1 performs a merge with any union data inside the V2IdentitiesUpdateIdentityRequestBody, using the provided V2IdentitiesUpdateIdentityRequestBody1
func (t *V2IdentitiesUpdateIdentityRequestBody) MergeV2IdentitiesUpdateIdentityRequestBody1(v V2IdentitiesUpdateIdentityRequestBody1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V2IdentitiesUpdateIdentityRequestBody) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.ExternalId != nil {
		object["externalId"], err = json.Marshal(t.ExternalId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'externalId': %w", err)
		}
	}

	if t.IdentityId != nil {
		object["identityId"], err = json.Marshal(t.IdentityId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'identityId': %w", err)
		}
	}

	if t.Meta != nil {
		object["meta"], err = json.Marshal(t.Meta)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'meta': %w", err)
		}
	}

	if t.Ratelimits != nil {
		object["ratelimits"], err = json.Marshal(t.Ratelimits)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ratelimits': %w", err)
		}
	}
	b, err = json.Marshal(object)
	return b, err
}

func (t *V2IdentitiesUpdateIdentityRequestBody) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["externalId"]; found {
		err = json.Unmarshal(raw, &t.ExternalId)
		if err != nil {
			return fmt.Errorf("error reading 'externalId': %w", err)
		}
	}

	if raw, found := object["identityId"]; found {
		err = json.Unmarshal(raw, &t.IdentityId)
		if err != nil {
			return fmt.Errorf("error reading 'identityId': %w", err)
		}
	}

	if raw, found := object["meta"]; found {
		err = json.Unmarshal(raw, &t.Meta)
		if err != nil {
			return fmt.Errorf("error reading 'meta': %w", err)
		}
	}

	if raw, found := object["ratelimits"]; found {
		err = json.Unmarshal(raw, &t.Ratelimits)
		if err != nil {
			return fmt.Errorf("error reading 'ratelimits': %w", err)
		}
	}

	return err
}

// AsV2KeysVerifyKeyRequestBodyPermissions0 returns the union data inside the V2KeysVerifyKeyRequestBody_Permissions as a V2KeysVerifyKeyRequestBodyPermissions0
func (t V2KeysVerifyKeyRequestBody_Permissions) AsV2KeysVerifyKeyRequestBodyPermissions0() (V2KeysVerifyKeyRequestBodyPermissions0, error) {
	var body V2KeysVerifyKeyRequestBodyPermissions0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2KeysVerifyKeyRequestBodyPermissions0 overwrites any union data inside the V2KeysVerifyKeyRequestBody_Permissions as the provided V2KeysVerifyKeyRequestBodyPermissions0
func (t *V2KeysVerifyKeyRequestBody_Permissions) FromV2KeysVerifyKeyRequestBodyPermissions0(v V2KeysVerifyKeyRequestBodyPermissions0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2KeysVerifyKeyRequestBodyPermissions0 performs a merge with any union data inside the V2KeysVerifyKeyRequestBody_Permissions, using the provided V2KeysVerifyKeyRequestBodyPermissions0
func (t *V2KeysVerifyKeyRequestBody_Permissions) MergeV2KeysVerifyKeyRequestBodyPermissions0(v V2KeysVerifyKeyRequestBodyPermissions0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsV2KeysVerifyKeyRequestBodyPermissions1 returns the union data inside the V2KeysVerifyKeyRequestBody_Permissions as a V2KeysVerifyKeyRequestBodyPermissions1
func (t V2KeysVerifyKeyRequestBody_Permissions) AsV2KeysVerifyKeyRequestBodyPermissions1() (V2KeysVerifyKeyRequestBodyPermissions1, error) {
	var body V2KeysVerifyKeyRequestBodyPermissions1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromV2KeysVerifyKeyRequestBodyPermissions1 overwrites any union data inside the V2KeysVerifyKeyRequestBody_Permissions as the provided V2KeysVerifyKeyRequestBodyPermissions1
func (t *V2KeysVerifyKeyRequestBody_Permissions) FromV2KeysVerifyKeyRequestBodyPermissions1(v V2KeysVerifyKeyRequestBodyPermissions1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeV2KeysVerifyKeyRequestBodyPermissions1 performs a merge with any union data inside the V2KeysVerifyKeyRequestBody_Permissions, using the provided V2KeysVerifyKeyRequestBodyPermissions1
func (t *V2KeysVerifyKeyRequestBody_Permissions) MergeV2KeysVerifyKeyRequestBodyPermissions1(v V2KeysVerifyKeyRequestBodyPermissions1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t V2KeysVerifyKeyRequestBody_Permissions) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *V2KeysVerifyKeyRequestBody_Permissions) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
