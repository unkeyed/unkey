// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: lease_acquire_workflow.sql

package db

import (
	"context"
)

const checkLeaseExpired = `-- name: CheckLeaseExpired :one
SELECT EXISTS(
    SELECT 1 FROM leases 
    WHERE resource_id = ? AND expires_at > ?
) as lease_active
`

type CheckLeaseExpiredParams struct {
	ResourceID string `db:"resource_id"`
	ExpiresAt  int64  `db:"expires_at"`
}

// CheckLeaseExpired
//
//	SELECT EXISTS(
//	    SELECT 1 FROM leases
//	    WHERE resource_id = ? AND expires_at > ?
//	) as lease_active
func (q *Queries) CheckLeaseExpired(ctx context.Context, db DBTX, arg CheckLeaseExpiredParams) (bool, error) {
	row := db.QueryRowContext(ctx, checkLeaseExpired, arg.ResourceID, arg.ExpiresAt)
	var lease_active bool
	err := row.Scan(&lease_active)
	return lease_active, err
}

const getExistingLease = `-- name: GetExistingLease :one
SELECT resource_id, kind, namespace, worker_id, acquired_at, expires_at, heartbeat_at FROM leases 
WHERE resource_id = ? AND kind = 'workflow'
`

// GetExistingLease
//
//	SELECT resource_id, kind, namespace, worker_id, acquired_at, expires_at, heartbeat_at FROM leases
//	WHERE resource_id = ? AND kind = 'workflow'
func (q *Queries) GetExistingLease(ctx context.Context, db DBTX, resourceID string) (Lease, error) {
	row := db.QueryRowContext(ctx, getExistingLease, resourceID)
	var i Lease
	err := row.Scan(
		&i.ResourceID,
		&i.Kind,
		&i.Namespace,
		&i.WorkerID,
		&i.AcquiredAt,
		&i.ExpiresAt,
		&i.HeartbeatAt,
	)
	return i, err
}

const getWorkflowForLease = `-- name: GetWorkflowForLease :one

SELECT id, workflow_name, status, input_data, output_data, error_message, created_at, started_at, completed_at, max_attempts, remaining_attempts, next_retry_at, namespace, trigger_type, trigger_source, sleep_until, trace_id FROM workflow_executions 
WHERE id = ? AND namespace = ?
`

type GetWorkflowForLeaseParams struct {
	ID        string `db:"id"`
	Namespace string `db:"namespace"`
}

// Complex queries for workflow lease acquisition transaction
//
//	SELECT id, workflow_name, status, input_data, output_data, error_message, created_at, started_at, completed_at, max_attempts, remaining_attempts, next_retry_at, namespace, trigger_type, trigger_source, sleep_until, trace_id FROM workflow_executions
//	WHERE id = ? AND namespace = ?
func (q *Queries) GetWorkflowForLease(ctx context.Context, db DBTX, arg GetWorkflowForLeaseParams) (WorkflowExecution, error) {
	row := db.QueryRowContext(ctx, getWorkflowForLease, arg.ID, arg.Namespace)
	var i WorkflowExecution
	err := row.Scan(
		&i.ID,
		&i.WorkflowName,
		&i.Status,
		&i.InputData,
		&i.OutputData,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.MaxAttempts,
		&i.RemainingAttempts,
		&i.NextRetryAt,
		&i.Namespace,
		&i.TriggerType,
		&i.TriggerSource,
		&i.SleepUntil,
		&i.TraceID,
	)
	return i, err
}
