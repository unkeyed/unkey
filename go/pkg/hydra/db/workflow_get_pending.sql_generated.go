// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: workflow_get_pending.sql

package db

import (
	"context"
	"database/sql"
	"strings"
)

const getPendingWorkflows = `-- name: GetPendingWorkflows :many
SELECT id, workflow_name, status, input_data, output_data, error_message, created_at, started_at, completed_at, max_attempts, remaining_attempts, next_retry_at, namespace, trigger_type, trigger_source, sleep_until, trace_id FROM workflow_executions
WHERE namespace = ? 
  AND (
    status = 'pending' 
    OR (status = 'failed' AND next_retry_at <= ?) 
    OR (status = 'sleeping' AND sleep_until <= ?)
  )
ORDER BY created_at ASC
LIMIT ? OFFSET ?
`

type GetPendingWorkflowsParams struct {
	Namespace   string        `db:"namespace"`
	NextRetryAt sql.NullInt64 `db:"next_retry_at"`
	SleepUntil  sql.NullInt64 `db:"sleep_until"`
	Limit       int32         `db:"limit"`
	Offset      int32         `db:"offset"`
}

// GetPendingWorkflows
//
//	SELECT id, workflow_name, status, input_data, output_data, error_message, created_at, started_at, completed_at, max_attempts, remaining_attempts, next_retry_at, namespace, trigger_type, trigger_source, sleep_until, trace_id FROM workflow_executions
//	WHERE namespace = ?
//	  AND (
//	    status = 'pending'
//	    OR (status = 'failed' AND next_retry_at <= ?)
//	    OR (status = 'sleeping' AND sleep_until <= ?)
//	  )
//	ORDER BY created_at ASC
//	LIMIT ? OFFSET ?
func (q *Queries) GetPendingWorkflows(ctx context.Context, db DBTX, arg GetPendingWorkflowsParams) ([]WorkflowExecution, error) {
	rows, err := db.QueryContext(ctx, getPendingWorkflows,
		arg.Namespace,
		arg.NextRetryAt,
		arg.SleepUntil,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowExecution
	for rows.Next() {
		var i WorkflowExecution
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowName,
			&i.Status,
			&i.InputData,
			&i.OutputData,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.MaxAttempts,
			&i.RemainingAttempts,
			&i.NextRetryAt,
			&i.Namespace,
			&i.TriggerType,
			&i.TriggerSource,
			&i.SleepUntil,
			&i.TraceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingWorkflowsWithNames = `-- name: GetPendingWorkflowsWithNames :many
SELECT id, workflow_name, status, input_data, output_data, error_message, created_at, started_at, completed_at, max_attempts, remaining_attempts, next_retry_at, namespace, trigger_type, trigger_source, sleep_until, trace_id FROM workflow_executions
WHERE namespace = ? 
  AND (
    status = 'pending' 
    OR (status = 'failed' AND next_retry_at <= ?) 
    OR (status = 'sleeping' AND sleep_until <= ?)
  )
  AND workflow_name IN (/*SLICE:workflow_names*/?)
ORDER BY created_at ASC
LIMIT ? OFFSET ?
`

type GetPendingWorkflowsWithNamesParams struct {
	Namespace     string        `db:"namespace"`
	NextRetryAt   sql.NullInt64 `db:"next_retry_at"`
	SleepUntil    sql.NullInt64 `db:"sleep_until"`
	WorkflowNames []string      `db:"workflow_names"`
	Limit         int32         `db:"limit"`
	Offset        int32         `db:"offset"`
}

// GetPendingWorkflowsWithNames
//
//	SELECT id, workflow_name, status, input_data, output_data, error_message, created_at, started_at, completed_at, max_attempts, remaining_attempts, next_retry_at, namespace, trigger_type, trigger_source, sleep_until, trace_id FROM workflow_executions
//	WHERE namespace = ?
//	  AND (
//	    status = 'pending'
//	    OR (status = 'failed' AND next_retry_at <= ?)
//	    OR (status = 'sleeping' AND sleep_until <= ?)
//	  )
//	  AND workflow_name IN (/*SLICE:workflow_names*/?)
//	ORDER BY created_at ASC
//	LIMIT ? OFFSET ?
func (q *Queries) GetPendingWorkflowsWithNames(ctx context.Context, db DBTX, arg GetPendingWorkflowsWithNamesParams) ([]WorkflowExecution, error) {
	query := getPendingWorkflowsWithNames
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Namespace)
	queryParams = append(queryParams, arg.NextRetryAt)
	queryParams = append(queryParams, arg.SleepUntil)
	if len(arg.WorkflowNames) > 0 {
		for _, v := range arg.WorkflowNames {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:workflow_names*/?", strings.Repeat(",?", len(arg.WorkflowNames))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:workflow_names*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.Limit)
	queryParams = append(queryParams, arg.Offset)
	rows, err := db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkflowExecution
	for rows.Next() {
		var i WorkflowExecution
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowName,
			&i.Status,
			&i.InputData,
			&i.OutputData,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.MaxAttempts,
			&i.RemainingAttempts,
			&i.NextRetryAt,
			&i.Namespace,
			&i.TriggerType,
			&i.TriggerSource,
			&i.SleepUntil,
			&i.TraceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
