package apierrors

import "encoding/json"

type Error interface {
	// Conform with the std error interface
	Error() string

	// Serialize the error as json to be sent to the client.
	Marshal() ([]byte, error)
}

// The canonical model for problem details is a JSON [JSON] object. When
// serialized in a JSON document, that format is identified with the
// "application/problem+json" media type.
//
// For example:
//
// POST /purchase HTTP/1.1
// Host: store.example.com
// Content-Type: application/json
// Accept: application/json, application/problem+json
//
//	{
//	  "item": 123456,
//	  "quantity": 2
//	}
//
// HTTP/1.1 403 Forbidden
// Content-Type: application/problem+json
// Content-Language: en
//
//	{
//	 "type": "https://example.com/probs/out-of-credit",
//	 "title": "You do not have enough credit.",
//	 "detail": "Your current balance is 30, but that costs 50.",
//	 "instance": "/account/12345/msgs/abc",
//	 "balance": 30,
//	 "accounts": ["/account/12345",
//	              "/account/67890"]
//	}
//
// The field documentation is partially copied from
// https://datatracker.ietf.org/doc/html/rfc9457
type BaseError struct {

	// https://datatracker.ietf.org/doc/html/rfc9457#section-3.1.1
	//
	// The "type" member is a JSON string containing a URI reference [URI] that
	// identifies the problem type. Consumers MUST use the "type" URI (after
	// resolution, if necessary) as the problem type's primary identifier.
	Type string `json:"type"`

	// https://datatracker.ietf.org/doc/html/rfc9457#section-3.1.2
	// The "status" member is a JSON number indicating the HTTP status code
	// ([HTTP], Section 15) generated by the origin server for this occurrence of
	//  the problem.
	//
	// The "status" member, if present, is only advisory; it conveys the HTTP
	// status code used for the convenience of the consumer. Generators MUST use
	//  the same status code in the actual HTTP response, to assure that generic
	// HTTP software that does not understand this format still behaves correctly.
	//  See Section 5 for further caveats regarding its use.
	//
	// Consumers can use the status member to determine what the original status
	// code used by the generator was when it has been changed (e.g., by an
	// intermediary or cache) and when a message's content is persisted without
	// HTTi information. Generic HTTP software will still use the HTTP status code.
	Status int `json:"status"`

	// https://datatracker.ietf.org/doc/html/rfc9457#section-3.1.3
	// The "title" member is a JSON string containing a short, human-readable
	// summary of the problem type.
	//
	// It SHOULD NOT change from occurrence to occurrence of the problem, except
	// for localization (e.g., using proactive content negotiation;
	// see [HTTP], Section 12.1).
	//
	// The "title" string is advisory and is included only for users who are
	// unaware of and cannot discover the semantics of the type URI
	// (e.g., during offline log analysis).
	Title string `json:"title"`

	// https://datatracker.ietf.org/doc/html/rfc9457#section-3.1.4
	// The "detail" member is a JSON string containing a human-readable
	// explanation specific to this occurrence of the problem.
	//
	// The "detail" string, if present, ought to focus on helping the client
	// correct the problem, rather than giving debugging information.
	// Consumers SHOULD NOT parse the "detail" member for information;
	// extensions are more suitable and less error-prone ways to obtain such
	// information.
	Detail string `json:"detail"`

	// https://datatracker.ietf.org/doc/html/rfc9457#section-3.1.5
	// The "instance" member is a JSON string containing a URI reference that
	// identifies the specific occurrence of the problem.
	//
	// When the "instance" URI is dereferenceable, the problem details object can
	// be fetched from it. It might also return information about the problem
	// occurrence in other formats through use of proactive content negotiation
	// (see [HTTP], Section 12.5.1).
	//
	// When the "instance" URI is not dereferenceable, it serves as a unique
	// identifier for the problem occurrence that may be of significance to the
	// server but is opaque to the client.
	//
	// When "instance" contains a relative URI, it is resolved relative to the
	// document's base URI, as per [URI], Section 5. However, using relative URIs
	// can cause confusion, and they might not be handled correctly by all
	// implementations.
	//
	// For example, if the two resources "https://api.example.org/foo/bar/123"
	// and "https://api.example.org/widget/456" both respond with an "instance"
	// equal to the relative URI reference "example-instance", when resolved they
	// will identify different resources
	// ("https://api.example.org/foo/bar/example-instance" and
	// "https://api.example.org/widget/example-instance", respectively).
	// As a result, it is RECOMMENDED that absolute URIs be used in "instance"
	// when possible, and that when relative URIs are used, they include the full
	// path (e.g., "/instances/123").
	Instance string `json:"instance,omitempty"`

	// RequestID is the unique id for this request. A user should log this and
	// include it in their support ticket to retrieve detailed traces about this
	// request later.
	RequestID string `json:"requestId"`
}

func (e BaseError) Error() string {
	panic("IMPLEMENT ME")
}

func (e BaseError) Marshal() ([]byte, error) {
	return json.Marshal(e)
}
