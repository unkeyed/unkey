package array

// Fill creates a new slice of the specified length where each element is generated by calling the provided function.
//
// The function allocates a slice with the exact capacity needed, then populates each element by calling
// the generator function in sequential order from index 0 to length-1. This approach provides optimal
// memory allocation patterns and eliminates the slice growth overhead associated with append-based
// approaches for large datasets.
//
// Fill is designed specifically for scenarios requiring bulk data generation, particularly in testing
// environments where millions of data structures must be created with varying properties. The single
// allocation strategy ensures predictable memory usage and optimal garbage collection behavior.
//
// Parameters:
//   - length: The number of elements to create. Zero returns an empty slice.
//     Negative values return an empty slice (note: this differs from make(), which panics).
//   - generator: Function called once per element to produce the value for that position. The function
//     should be lightweight and deterministic where possible. If the generator panics, Fill propagates
//     the panic. Generator functions that perform I/O or other blocking operations will impact performance
//     proportionally.
//
// Returns a new slice of type []T containing exactly length elements, each populated by calling the
// generator function. The slice has capacity equal to length, ensuring no additional allocations are
// needed if the slice is not grown further.
//
// Behavior details:
//   - Generator function is called exactly length times in sequential order (0, 1, 2, ...)
//   - Each call receives no parameters - the generator must maintain its own state if needed
//   - Slice allocation occurs once at the beginning with capacity = length
//   - No additional memory allocations occur during population
//   - Returned slice is independent of any other slices created by Fill
//
// Performance characteristics:
//   - Time complexity: O(n) where n equals length
//   - Space complexity: O(n) for slice data plus constant overhead (~24 bytes for slice header)
//   - Memory allocation: Single allocation for slice data, no additional allocations during population
//   - Generator calls: Exactly length calls, no caching or optimization of generator results
//
// The single allocation approach makes Fill significantly more efficient than append-based generation
// for large slices, as it eliminates the exponential growth and copying overhead inherent in slice
// expansion. For slices with millions of elements, this difference can be substantial both in terms
// of execution time and memory usage.
//
// Concurrency safety:
//
//	Fill is safe to call concurrently from multiple goroutines, as each invocation creates an
//	independent slice. The safety of concurrent Fill operations depends entirely on the generator
//	function - if the generator accesses shared mutable state without synchronization, race
//	conditions may occur. Generator functions should either be stateless or use appropriate
//	synchronization primitives.
//
// Error conditions:
//
//	Fill does not return errors as slice creation cannot fail under normal conditions. Memory
//	exhaustion during allocation will result in a runtime panic, consistent with Go's make()
//	function. Generator function panics are propagated to the caller unchanged.
//
// Edge cases and special behavior:
//   - length = 0: Returns empty slice []T{}, generator is never called
//   - length < 0: Returns empty slice []T{} following make() semantics
//   - Very large length values: May cause out-of-memory panics if insufficient RAM available
//   - Generator function panic: Panic propagates to caller, partial slice may be allocated but not returned
//
// Common usage patterns:
//
//	// Generate unique identifiers for testing
//	userIDs := array.Fill(10000, func() string {
//	    return uid.New(uid.UserPrefix)
//	})
//
//	// Create test data with random properties
//	testCases := array.Fill(1000000, func() TestCase {
//	    return TestCase{
//	        ID:       uid.New(uid.TestPrefix),
//	        Priority: rand.Intn(10),
//	        Created:  time.Now().Add(-time.Duration(rand.Intn(86400)) * time.Second),
//	    }
//	})
//
//	// Initialize configuration arrays
//	servers := array.Fill(5, func() ServerConfig {
//	    return ServerConfig{
//	        Port:           8080,
//	        ReadTimeout:    30 * time.Second,
//	        WriteTimeout:   30 * time.Second,
//	        MaxConnections: 1000,
//	    }
//	})
//
// Performance comparison with alternatives:
//
//	// Fill - optimal for known sizes
//	data := array.Fill(100000, func() int { return rand.Intn(1000) })
//
//	// Manual allocation - equivalent performance but more verbose
//	data := make([]int, 100000)
//	for i := range data {
//	    data[i] = rand.Intn(1000)
//	}
//
//	// Append-based - significantly slower for large slices due to growth overhead
//	var data []int
//	for i := 0; i < 100000; i++ {
//	    data = append(data, rand.Intn(1000))
//	}
func Fill[T any](length int, generator func() T) []T {
	if length <= 0 {
		return []T{}
	}

	slice := make([]T, length)
	for i := range length {
		slice[i] = generator()
	}
	return slice
}
