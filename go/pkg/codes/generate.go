//go:build ignore
// +build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"time"
	"unicode"

	"github.com/unkeyed/unkey/go/pkg/codes"
)

// commentMap stores comments for types and fields
var commentMap = make(map[string]map[string]string)

func main() {
	// Extract comments from source files first
	if err := extractComments(); err != nil {
		fmt.Fprintf(os.Stderr, "Error extracting comments: %v\n", err)
	}

	// Output file
	outputPath := "constants_gen.go"
	f, err := os.Create(outputPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	// Write file header
	f.WriteString(fmt.Sprintf("// Code generated by generate.go; DO NOT EDIT.\n"))
	f.WriteString(fmt.Sprintf("// Generated at: %s\n\n", time.Now().Format(time.RFC3339)))
	f.WriteString("package codes\n\n")

	// Generate constants
	f.WriteString("// URN is a string type for error code constants\n")
	f.WriteString("type URN string\n\n")

	f.WriteString("// Error code constants for use in switch statements for exhaustive checking\n")
	f.WriteString("const (\n")

	// Process each top-level error domain using reflection
	processErrorDomain(f, "Unkey", reflect.ValueOf(codes.Auth))
	processErrorDomain(f, "Unkey", reflect.ValueOf(codes.Data))
	processErrorDomain(f, "Unkey", reflect.ValueOf(codes.App))

	f.WriteString(")\n")

	fmt.Println("Generated error constants with documentation")
}

// extractComments parses source files to get documentation comments
func extractComments() error {
	fset := token.NewFileSet()

	// Get all Go files in the current directory except generated files
	files, err := filepath.Glob("*.go")
	if err != nil {
		return err
	}

	for _, filename := range files {
		// Skip generated files
		if strings.HasSuffix(filename, "_gen.go") || filename == "generate.go" {
			continue
		}

		// Parse the file
		file, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
		if err != nil {
			return err
		}

		// Visit all declarations in the file
		ast.Inspect(file, func(n ast.Node) bool {
			// Look for type declarations
			typeSpec, ok := n.(*ast.TypeSpec)
			if !ok {
				return true
			}

			typeName := typeSpec.Name.Name

			// Check if it's a struct type
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				return true
			}

			// Create entry for this type
			if _, exists := commentMap[typeName]; !exists {
				commentMap[typeName] = make(map[string]string)
			}

			// Extract comments for struct fields
			for _, field := range structType.Fields.List {
				if field.Doc != nil {
					comment := field.Doc.Text()

					// Store comment for each field name
					for _, name := range field.Names {
						commentMap[typeName][name.Name] = comment
					}
				}
			}

			return true
		})
	}

	return nil
}

// processErrorDomain extracts error codes from a domain using reflection
func processErrorDomain(f *os.File, systemName string, domainValue reflect.Value) {
	// Section header
	domainType := domainValue.Type()
	domainName := domainType.Name()
	f.WriteString(fmt.Sprintf("// ----------------\n"))
	f.WriteString(fmt.Sprintf("// %s\n", domainName))
	f.WriteString(fmt.Sprintf("// ----------------\n"))
	f.WriteString("\n")

	// Iterate through categories (fields of the domain struct)
	for i := 0; i < domainValue.NumField(); i++ {
		categoryField := domainValue.Field(i)
		categoryName := domainType.Field(i).Name

		f.WriteString(fmt.Sprintf("// %s\n\n", categoryName))

		// Iterate through error codes in this category
		processCategory(f, systemName, domainName, categoryName, categoryField)

		f.WriteString("\n")
	}
}

// processCategory extracts error codes from a category using reflection
func processCategory(f *os.File, systemName, domainName, categoryName string, categoryValue reflect.Value) {
	// Iterate through error codes in this category
	categoryType := categoryValue.Type()

	for j := 0; j < categoryValue.NumField(); j++ {
		codeField := categoryValue.Field(j)
		codeName := categoryType.Field(j).Name

		// Extract the actual Code object
		codeObj := codeField.Interface().(codes.Code)

		// Generate constant name (PascalCase)
		constName := fmt.Sprintf("%s%s%s", domainName, categoryName, codeName)

		// Get the string representation
		codeStr := codeObj.URN()

		// Look up and write comments if available
		if comments, ok := commentMap[categoryType.Name()]; ok {
			if comment, ok := comments[codeName]; ok {
				// Clean up the comment and add it to the output
				lines := strings.Split(strings.TrimSpace(comment), "\n")
				for _, line := range lines {
					line = strings.TrimSpace(line)
					if line != "" {
						f.WriteString(fmt.Sprintf("\t// %s\n", line))
					}
				}
			}
		}

		// Write the constant
		f.WriteString(fmt.Sprintf("\t%s URN = \"%s\"\n", constName, codeStr))
	}
}

// toSnakeCase converts a string from PascalCase to snake_case
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && unicode.IsUpper(r) {
			result.WriteRune('_')
		}
		result.WriteRune(unicode.ToLower(r))
	}
	return result.String()
}
