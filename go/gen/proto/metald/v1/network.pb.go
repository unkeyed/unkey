// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.9
// 	protoc        (unknown)
// source: metald/v1/network.proto

package metaldv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Network mode for the interface
type NetworkMode int32

const (
	NetworkMode_NETWORK_MODE_UNSPECIFIED NetworkMode = 0
	NetworkMode_NETWORK_MODE_DUAL_STACK  NetworkMode = 1 // Both IPv4 and IPv6
	NetworkMode_NETWORK_MODE_IPV4_ONLY   NetworkMode = 2 // IPv4 only
	NetworkMode_NETWORK_MODE_IPV6_ONLY   NetworkMode = 3 // IPv6 only
)

// Enum value maps for NetworkMode.
var (
	NetworkMode_name = map[int32]string{
		0: "NETWORK_MODE_UNSPECIFIED",
		1: "NETWORK_MODE_DUAL_STACK",
		2: "NETWORK_MODE_IPV4_ONLY",
		3: "NETWORK_MODE_IPV6_ONLY",
	}
	NetworkMode_value = map[string]int32{
		"NETWORK_MODE_UNSPECIFIED": 0,
		"NETWORK_MODE_DUAL_STACK":  1,
		"NETWORK_MODE_IPV4_ONLY":   2,
		"NETWORK_MODE_IPV6_ONLY":   3,
	}
)

func (x NetworkMode) Enum() *NetworkMode {
	p := new(NetworkMode)
	*p = x
	return p
}

func (x NetworkMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NetworkMode) Descriptor() protoreflect.EnumDescriptor {
	return file_metald_v1_network_proto_enumTypes[0].Descriptor()
}

func (NetworkMode) Type() protoreflect.EnumType {
	return &file_metald_v1_network_proto_enumTypes[0]
}

func (x NetworkMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NetworkMode.Descriptor instead.
func (NetworkMode) EnumDescriptor() ([]byte, []int) {
	return file_metald_v1_network_proto_rawDescGZIP(), []int{0}
}

type NetworkStats struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	BytesReceived      int64                  `protobuf:"varint,1,opt,name=bytes_received,json=bytesReceived,proto3" json:"bytes_received,omitempty"`
	BytesTransmitted   int64                  `protobuf:"varint,2,opt,name=bytes_transmitted,json=bytesTransmitted,proto3" json:"bytes_transmitted,omitempty"`
	PacketsReceived    int64                  `protobuf:"varint,3,opt,name=packets_received,json=packetsReceived,proto3" json:"packets_received,omitempty"`
	PacketsTransmitted int64                  `protobuf:"varint,4,opt,name=packets_transmitted,json=packetsTransmitted,proto3" json:"packets_transmitted,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *NetworkStats) Reset() {
	*x = NetworkStats{}
	mi := &file_metald_v1_network_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkStats) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkStats) ProtoMessage() {}

func (x *NetworkStats) ProtoReflect() protoreflect.Message {
	mi := &file_metald_v1_network_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkStats.ProtoReflect.Descriptor instead.
func (*NetworkStats) Descriptor() ([]byte, []int) {
	return file_metald_v1_network_proto_rawDescGZIP(), []int{0}
}

func (x *NetworkStats) GetBytesReceived() int64 {
	if x != nil {
		return x.BytesReceived
	}
	return 0
}

func (x *NetworkStats) GetBytesTransmitted() int64 {
	if x != nil {
		return x.BytesTransmitted
	}
	return 0
}

func (x *NetworkStats) GetPacketsReceived() int64 {
	if x != nil {
		return x.PacketsReceived
	}
	return 0
}

func (x *NetworkStats) GetPacketsTransmitted() int64 {
	if x != nil {
		return x.PacketsTransmitted
	}
	return 0
}

type NetworkInterface struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier for this network interface
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// MAC address (optional, will be generated if not provided)
	MacAddress string `protobuf:"bytes,2,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	// Host-side TAP device name
	TapDevice string `protobuf:"bytes,3,opt,name=tap_device,json=tapDevice,proto3" json:"tap_device,omitempty"`
	// Network interface type (virtio-net, e1000, etc.)
	InterfaceType string `protobuf:"bytes,4,opt,name=interface_type,json=interfaceType,proto3" json:"interface_type,omitempty"`
	// Additional network options
	Options map[string]string `protobuf:"bytes,5,rep,name=options,proto3" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// IPv4 configuration (optional)
	Ipv4Config *IPv4Config `protobuf:"bytes,6,opt,name=ipv4_config,json=ipv4Config,proto3" json:"ipv4_config,omitempty"`
	// IPv6 configuration (optional)
	Ipv6Config *IPv6Config `protobuf:"bytes,7,opt,name=ipv6_config,json=ipv6Config,proto3" json:"ipv6_config,omitempty"`
	// Network mode
	Mode NetworkMode `protobuf:"varint,8,opt,name=mode,proto3,enum=metald.v1.NetworkMode" json:"mode,omitempty"`
	// Rate limiting
	RxRateLimit   *RateLimit `protobuf:"bytes,10,opt,name=rx_rate_limit,json=rxRateLimit,proto3" json:"rx_rate_limit,omitempty"` // Receive rate limit
	TxRateLimit   *RateLimit `protobuf:"bytes,11,opt,name=tx_rate_limit,json=txRateLimit,proto3" json:"tx_rate_limit,omitempty"` // Transmit rate limit
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkInterface) Reset() {
	*x = NetworkInterface{}
	mi := &file_metald_v1_network_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkInterface) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkInterface) ProtoMessage() {}

func (x *NetworkInterface) ProtoReflect() protoreflect.Message {
	mi := &file_metald_v1_network_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkInterface.ProtoReflect.Descriptor instead.
func (*NetworkInterface) Descriptor() ([]byte, []int) {
	return file_metald_v1_network_proto_rawDescGZIP(), []int{1}
}

func (x *NetworkInterface) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *NetworkInterface) GetMacAddress() string {
	if x != nil {
		return x.MacAddress
	}
	return ""
}

func (x *NetworkInterface) GetTapDevice() string {
	if x != nil {
		return x.TapDevice
	}
	return ""
}

func (x *NetworkInterface) GetInterfaceType() string {
	if x != nil {
		return x.InterfaceType
	}
	return ""
}

func (x *NetworkInterface) GetOptions() map[string]string {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *NetworkInterface) GetIpv4Config() *IPv4Config {
	if x != nil {
		return x.Ipv4Config
	}
	return nil
}

func (x *NetworkInterface) GetIpv6Config() *IPv6Config {
	if x != nil {
		return x.Ipv6Config
	}
	return nil
}

func (x *NetworkInterface) GetMode() NetworkMode {
	if x != nil {
		return x.Mode
	}
	return NetworkMode_NETWORK_MODE_UNSPECIFIED
}

func (x *NetworkInterface) GetRxRateLimit() *RateLimit {
	if x != nil {
		return x.RxRateLimit
	}
	return nil
}

func (x *NetworkInterface) GetTxRateLimit() *RateLimit {
	if x != nil {
		return x.TxRateLimit
	}
	return nil
}

// IPv4 network configuration
type IPv4Config struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Address       string                 `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`                         // IPv4 address (e.g., "10.100.1.2")
	Netmask       string                 `protobuf:"bytes,2,opt,name=netmask,proto3" json:"netmask,omitempty"`                         // Network mask (e.g., "255.255.255.0")
	Gateway       string                 `protobuf:"bytes,3,opt,name=gateway,proto3" json:"gateway,omitempty"`                         // Default gateway
	DnsServers    []string               `protobuf:"bytes,4,rep,name=dns_servers,json=dnsServers,proto3" json:"dns_servers,omitempty"` // DNS servers
	Dhcp          bool                   `protobuf:"varint,5,opt,name=dhcp,proto3" json:"dhcp,omitempty"`                              // Use DHCP instead of static config
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPv4Config) Reset() {
	*x = IPv4Config{}
	mi := &file_metald_v1_network_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPv4Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPv4Config) ProtoMessage() {}

func (x *IPv4Config) ProtoReflect() protoreflect.Message {
	mi := &file_metald_v1_network_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPv4Config.ProtoReflect.Descriptor instead.
func (*IPv4Config) Descriptor() ([]byte, []int) {
	return file_metald_v1_network_proto_rawDescGZIP(), []int{2}
}

func (x *IPv4Config) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *IPv4Config) GetNetmask() string {
	if x != nil {
		return x.Netmask
	}
	return ""
}

func (x *IPv4Config) GetGateway() string {
	if x != nil {
		return x.Gateway
	}
	return ""
}

func (x *IPv4Config) GetDnsServers() []string {
	if x != nil {
		return x.DnsServers
	}
	return nil
}

func (x *IPv4Config) GetDhcp() bool {
	if x != nil {
		return x.Dhcp
	}
	return false
}

// IPv6 network configuration
type IPv6Config struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	Address           string                 `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`                                               // IPv6 address (e.g., "fd00::1:2")
	PrefixLength      int32                  `protobuf:"varint,2,opt,name=prefix_length,json=prefixLength,proto3" json:"prefix_length,omitempty"`                // Prefix length (e.g., 64)
	Gateway           string                 `protobuf:"bytes,3,opt,name=gateway,proto3" json:"gateway,omitempty"`                                               // Default gateway
	DnsServers        []string               `protobuf:"bytes,4,rep,name=dns_servers,json=dnsServers,proto3" json:"dns_servers,omitempty"`                       // DNS servers (IPv6 addresses)
	Slaac             bool                   `protobuf:"varint,5,opt,name=slaac,proto3" json:"slaac,omitempty"`                                                  // Use SLAAC (Stateless Address Autoconfiguration)
	PrivacyExtensions bool                   `protobuf:"varint,6,opt,name=privacy_extensions,json=privacyExtensions,proto3" json:"privacy_extensions,omitempty"` // Enable privacy extensions
	LinkLocal         string                 `protobuf:"bytes,7,opt,name=link_local,json=linkLocal,proto3" json:"link_local,omitempty"`                          // Link-local address (auto-generated if empty)
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *IPv6Config) Reset() {
	*x = IPv6Config{}
	mi := &file_metald_v1_network_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPv6Config) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPv6Config) ProtoMessage() {}

func (x *IPv6Config) ProtoReflect() protoreflect.Message {
	mi := &file_metald_v1_network_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPv6Config.ProtoReflect.Descriptor instead.
func (*IPv6Config) Descriptor() ([]byte, []int) {
	return file_metald_v1_network_proto_rawDescGZIP(), []int{3}
}

func (x *IPv6Config) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *IPv6Config) GetPrefixLength() int32 {
	if x != nil {
		return x.PrefixLength
	}
	return 0
}

func (x *IPv6Config) GetGateway() string {
	if x != nil {
		return x.Gateway
	}
	return ""
}

func (x *IPv6Config) GetDnsServers() []string {
	if x != nil {
		return x.DnsServers
	}
	return nil
}

func (x *IPv6Config) GetSlaac() bool {
	if x != nil {
		return x.Slaac
	}
	return false
}

func (x *IPv6Config) GetPrivacyExtensions() bool {
	if x != nil {
		return x.PrivacyExtensions
	}
	return false
}

func (x *IPv6Config) GetLinkLocal() string {
	if x != nil {
		return x.LinkLocal
	}
	return ""
}

// Rate limiting configuration
type RateLimit struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Bandwidth     int64                  `protobuf:"varint,1,opt,name=bandwidth,proto3" json:"bandwidth,omitempty"`                     // Bandwidth in bytes/second
	RefillTime    int64                  `protobuf:"varint,2,opt,name=refill_time,json=refillTime,proto3" json:"refill_time,omitempty"` // Token bucket refill time in milliseconds
	Burst         int64                  `protobuf:"varint,3,opt,name=burst,proto3" json:"burst,omitempty"`                             // Burst size in bytes
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RateLimit) Reset() {
	*x = RateLimit{}
	mi := &file_metald_v1_network_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RateLimit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimit) ProtoMessage() {}

func (x *RateLimit) ProtoReflect() protoreflect.Message {
	mi := &file_metald_v1_network_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimit.ProtoReflect.Descriptor instead.
func (*RateLimit) Descriptor() ([]byte, []int) {
	return file_metald_v1_network_proto_rawDescGZIP(), []int{4}
}

func (x *RateLimit) GetBandwidth() int64 {
	if x != nil {
		return x.Bandwidth
	}
	return 0
}

func (x *RateLimit) GetRefillTime() int64 {
	if x != nil {
		return x.RefillTime
	}
	return 0
}

func (x *RateLimit) GetBurst() int64 {
	if x != nil {
		return x.Burst
	}
	return 0
}

var File_metald_v1_network_proto protoreflect.FileDescriptor

const file_metald_v1_network_proto_rawDesc = "" +
	"\n" +
	"\x17metald/v1/network.proto\x12\tmetald.v1\"\xbe\x01\n" +
	"\fNetworkStats\x12%\n" +
	"\x0ebytes_received\x18\x01 \x01(\x03R\rbytesReceived\x12+\n" +
	"\x11bytes_transmitted\x18\x02 \x01(\x03R\x10bytesTransmitted\x12)\n" +
	"\x10packets_received\x18\x03 \x01(\x03R\x0fpacketsReceived\x12/\n" +
	"\x13packets_transmitted\x18\x04 \x01(\x03R\x12packetsTransmitted\"\x99\x04\n" +
	"\x10NetworkInterface\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x1f\n" +
	"\vmac_address\x18\x02 \x01(\tR\n" +
	"macAddress\x12\x1d\n" +
	"\n" +
	"tap_device\x18\x03 \x01(\tR\ttapDevice\x12%\n" +
	"\x0einterface_type\x18\x04 \x01(\tR\rinterfaceType\x12B\n" +
	"\aoptions\x18\x05 \x03(\v2(.metald.v1.NetworkInterface.OptionsEntryR\aoptions\x126\n" +
	"\vipv4_config\x18\x06 \x01(\v2\x15.metald.v1.IPv4ConfigR\n" +
	"ipv4Config\x126\n" +
	"\vipv6_config\x18\a \x01(\v2\x15.metald.v1.IPv6ConfigR\n" +
	"ipv6Config\x12*\n" +
	"\x04mode\x18\b \x01(\x0e2\x16.metald.v1.NetworkModeR\x04mode\x128\n" +
	"\rrx_rate_limit\x18\n" +
	" \x01(\v2\x14.metald.v1.RateLimitR\vrxRateLimit\x128\n" +
	"\rtx_rate_limit\x18\v \x01(\v2\x14.metald.v1.RateLimitR\vtxRateLimit\x1a:\n" +
	"\fOptionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x8f\x01\n" +
	"\n" +
	"IPv4Config\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12\x18\n" +
	"\anetmask\x18\x02 \x01(\tR\anetmask\x12\x18\n" +
	"\agateway\x18\x03 \x01(\tR\agateway\x12\x1f\n" +
	"\vdns_servers\x18\x04 \x03(\tR\n" +
	"dnsServers\x12\x12\n" +
	"\x04dhcp\x18\x05 \x01(\bR\x04dhcp\"\xea\x01\n" +
	"\n" +
	"IPv6Config\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddress\x12#\n" +
	"\rprefix_length\x18\x02 \x01(\x05R\fprefixLength\x12\x18\n" +
	"\agateway\x18\x03 \x01(\tR\agateway\x12\x1f\n" +
	"\vdns_servers\x18\x04 \x03(\tR\n" +
	"dnsServers\x12\x14\n" +
	"\x05slaac\x18\x05 \x01(\bR\x05slaac\x12-\n" +
	"\x12privacy_extensions\x18\x06 \x01(\bR\x11privacyExtensions\x12\x1d\n" +
	"\n" +
	"link_local\x18\a \x01(\tR\tlinkLocal\"`\n" +
	"\tRateLimit\x12\x1c\n" +
	"\tbandwidth\x18\x01 \x01(\x03R\tbandwidth\x12\x1f\n" +
	"\vrefill_time\x18\x02 \x01(\x03R\n" +
	"refillTime\x12\x14\n" +
	"\x05burst\x18\x03 \x01(\x03R\x05burst*\x80\x01\n" +
	"\vNetworkMode\x12\x1c\n" +
	"\x18NETWORK_MODE_UNSPECIFIED\x10\x00\x12\x1b\n" +
	"\x17NETWORK_MODE_DUAL_STACK\x10\x01\x12\x1a\n" +
	"\x16NETWORK_MODE_IPV4_ONLY\x10\x02\x12\x1a\n" +
	"\x16NETWORK_MODE_IPV6_ONLY\x10\x03B:Z8github.com/unkeyed/unkey/go/gen/proto/metald/v1;metaldv1b\x06proto3"

var (
	file_metald_v1_network_proto_rawDescOnce sync.Once
	file_metald_v1_network_proto_rawDescData []byte
)

func file_metald_v1_network_proto_rawDescGZIP() []byte {
	file_metald_v1_network_proto_rawDescOnce.Do(func() {
		file_metald_v1_network_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_metald_v1_network_proto_rawDesc), len(file_metald_v1_network_proto_rawDesc)))
	})
	return file_metald_v1_network_proto_rawDescData
}

var file_metald_v1_network_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_metald_v1_network_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_metald_v1_network_proto_goTypes = []any{
	(NetworkMode)(0),         // 0: metald.v1.NetworkMode
	(*NetworkStats)(nil),     // 1: metald.v1.NetworkStats
	(*NetworkInterface)(nil), // 2: metald.v1.NetworkInterface
	(*IPv4Config)(nil),       // 3: metald.v1.IPv4Config
	(*IPv6Config)(nil),       // 4: metald.v1.IPv6Config
	(*RateLimit)(nil),        // 5: metald.v1.RateLimit
	nil,                      // 6: metald.v1.NetworkInterface.OptionsEntry
}
var file_metald_v1_network_proto_depIdxs = []int32{
	6, // 0: metald.v1.NetworkInterface.options:type_name -> metald.v1.NetworkInterface.OptionsEntry
	3, // 1: metald.v1.NetworkInterface.ipv4_config:type_name -> metald.v1.IPv4Config
	4, // 2: metald.v1.NetworkInterface.ipv6_config:type_name -> metald.v1.IPv6Config
	0, // 3: metald.v1.NetworkInterface.mode:type_name -> metald.v1.NetworkMode
	5, // 4: metald.v1.NetworkInterface.rx_rate_limit:type_name -> metald.v1.RateLimit
	5, // 5: metald.v1.NetworkInterface.tx_rate_limit:type_name -> metald.v1.RateLimit
	6, // [6:6] is the sub-list for method output_type
	6, // [6:6] is the sub-list for method input_type
	6, // [6:6] is the sub-list for extension type_name
	6, // [6:6] is the sub-list for extension extendee
	0, // [0:6] is the sub-list for field type_name
}

func init() { file_metald_v1_network_proto_init() }
func file_metald_v1_network_proto_init() {
	if File_metald_v1_network_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_metald_v1_network_proto_rawDesc), len(file_metald_v1_network_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_metald_v1_network_proto_goTypes,
		DependencyIndexes: file_metald_v1_network_proto_depIdxs,
		EnumInfos:         file_metald_v1_network_proto_enumTypes,
		MessageInfos:      file_metald_v1_network_proto_msgTypes,
	}.Build()
	File_metald_v1_network_proto = out.File
	file_metald_v1_network_proto_goTypes = nil
	file_metald_v1_network_proto_depIdxs = nil
}
