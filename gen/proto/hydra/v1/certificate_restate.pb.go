// Code generated by protoc-gen-go-restate. DO NOT EDIT.
// versions:
// - protoc-gen-go-restate v0.1
// - protoc             (unknown)
// source: hydra/v1/certificate.proto

package hydrav1

import (
	fmt "fmt"
	sdk_go "github.com/restatedev/sdk-go"
	encoding "github.com/restatedev/sdk-go/encoding"
	ingress "github.com/restatedev/sdk-go/ingress"
)

// CertificateServiceClient is the client API for hydra.v1.CertificateService service.
//
// CertificateService manages ACME certificate challenges and issuance
type CertificateServiceClient interface {
	// ProcessChallenge handles the complete ACME certificate challenge flow
	// Key: domain name (ensures only one challenge per domain at a time)
	ProcessChallenge(opts ...sdk_go.ClientOption) sdk_go.Client[*ProcessChallengeRequest, *ProcessChallengeResponse]
	// RenewExpiringCertificates checks for certificates expiring soon and renews them.
	// This should be called periodically (e.g., daily via cron).
	// Key: "global" (single instance ensures no duplicate renewal runs)
	RenewExpiringCertificates(opts ...sdk_go.ClientOption) sdk_go.Client[*RenewExpiringCertificatesRequest, *RenewExpiringCertificatesResponse]
	// RefreshExpiringOCSPStaples refreshes OCSP staples for certificates expiring soon.
	// This is a self-scheduling cron job that runs daily.
	// Key: "global" (single instance ensures no duplicate runs)
	RefreshExpiringOCSPStaples(opts ...sdk_go.ClientOption) sdk_go.Client[*RefreshExpiringOCSPStaplesRequest, *RefreshExpiringOCSPStaplesResponse]
}

type certificateServiceClient struct {
	ctx     sdk_go.Context
	key     string
	options []sdk_go.ClientOption
}

func NewCertificateServiceClient(ctx sdk_go.Context, key string, opts ...sdk_go.ClientOption) CertificateServiceClient {
	cOpts := append([]sdk_go.ClientOption{sdk_go.WithProtoJSON}, opts...)
	return &certificateServiceClient{
		ctx,
		key,
		cOpts,
	}
}
func (c *certificateServiceClient) ProcessChallenge(opts ...sdk_go.ClientOption) sdk_go.Client[*ProcessChallengeRequest, *ProcessChallengeResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*ProcessChallengeRequest](sdk_go.Object[*ProcessChallengeResponse](c.ctx, "hydra.v1.CertificateService", c.key, "ProcessChallenge", cOpts...))
}

func (c *certificateServiceClient) RenewExpiringCertificates(opts ...sdk_go.ClientOption) sdk_go.Client[*RenewExpiringCertificatesRequest, *RenewExpiringCertificatesResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*RenewExpiringCertificatesRequest](sdk_go.Object[*RenewExpiringCertificatesResponse](c.ctx, "hydra.v1.CertificateService", c.key, "RenewExpiringCertificates", cOpts...))
}

func (c *certificateServiceClient) RefreshExpiringOCSPStaples(opts ...sdk_go.ClientOption) sdk_go.Client[*RefreshExpiringOCSPStaplesRequest, *RefreshExpiringOCSPStaplesResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*RefreshExpiringOCSPStaplesRequest](sdk_go.Object[*RefreshExpiringOCSPStaplesResponse](c.ctx, "hydra.v1.CertificateService", c.key, "RefreshExpiringOCSPStaples", cOpts...))
}

// CertificateServiceIngressClient is the ingress client API for hydra.v1.CertificateService service.
//
// This client is used to call the service from outside of a Restate context.
type CertificateServiceIngressClient interface {
	// ProcessChallenge handles the complete ACME certificate challenge flow
	// Key: domain name (ensures only one challenge per domain at a time)
	ProcessChallenge() ingress.Requester[*ProcessChallengeRequest, *ProcessChallengeResponse]
	// RenewExpiringCertificates checks for certificates expiring soon and renews them.
	// This should be called periodically (e.g., daily via cron).
	// Key: "global" (single instance ensures no duplicate renewal runs)
	RenewExpiringCertificates() ingress.Requester[*RenewExpiringCertificatesRequest, *RenewExpiringCertificatesResponse]
	// RefreshExpiringOCSPStaples refreshes OCSP staples for certificates expiring soon.
	// This is a self-scheduling cron job that runs daily.
	// Key: "global" (single instance ensures no duplicate runs)
	RefreshExpiringOCSPStaples() ingress.Requester[*RefreshExpiringOCSPStaplesRequest, *RefreshExpiringOCSPStaplesResponse]
}

type certificateServiceIngressClient struct {
	client      *ingress.Client
	serviceName string
	key         string
}

func NewCertificateServiceIngressClient(client *ingress.Client, key string) CertificateServiceIngressClient {
	return &certificateServiceIngressClient{
		client,
		"hydra.v1.CertificateService",
		key,
	}
}

func (c *certificateServiceIngressClient) ProcessChallenge() ingress.Requester[*ProcessChallengeRequest, *ProcessChallengeResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*ProcessChallengeRequest, *ProcessChallengeResponse](c.client, c.serviceName, "ProcessChallenge", &c.key, &codec)
}

func (c *certificateServiceIngressClient) RenewExpiringCertificates() ingress.Requester[*RenewExpiringCertificatesRequest, *RenewExpiringCertificatesResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*RenewExpiringCertificatesRequest, *RenewExpiringCertificatesResponse](c.client, c.serviceName, "RenewExpiringCertificates", &c.key, &codec)
}

func (c *certificateServiceIngressClient) RefreshExpiringOCSPStaples() ingress.Requester[*RefreshExpiringOCSPStaplesRequest, *RefreshExpiringOCSPStaplesResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*RefreshExpiringOCSPStaplesRequest, *RefreshExpiringOCSPStaplesResponse](c.client, c.serviceName, "RefreshExpiringOCSPStaples", &c.key, &codec)
}

// CertificateServiceServer is the server API for hydra.v1.CertificateService service.
// All implementations should embed UnimplementedCertificateServiceServer
// for forward compatibility.
//
// CertificateService manages ACME certificate challenges and issuance
type CertificateServiceServer interface {
	// ProcessChallenge handles the complete ACME certificate challenge flow
	// Key: domain name (ensures only one challenge per domain at a time)
	ProcessChallenge(ctx sdk_go.ObjectContext, req *ProcessChallengeRequest) (*ProcessChallengeResponse, error)
	// RenewExpiringCertificates checks for certificates expiring soon and renews them.
	// This should be called periodically (e.g., daily via cron).
	// Key: "global" (single instance ensures no duplicate renewal runs)
	RenewExpiringCertificates(ctx sdk_go.ObjectContext, req *RenewExpiringCertificatesRequest) (*RenewExpiringCertificatesResponse, error)
	// RefreshExpiringOCSPStaples refreshes OCSP staples for certificates expiring soon.
	// This is a self-scheduling cron job that runs daily.
	// Key: "global" (single instance ensures no duplicate runs)
	RefreshExpiringOCSPStaples(ctx sdk_go.ObjectContext, req *RefreshExpiringOCSPStaplesRequest) (*RefreshExpiringOCSPStaplesResponse, error)
}

// UnimplementedCertificateServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCertificateServiceServer struct{}

func (UnimplementedCertificateServiceServer) ProcessChallenge(ctx sdk_go.ObjectContext, req *ProcessChallengeRequest) (*ProcessChallengeResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method ProcessChallenge not implemented"), 501)
}
func (UnimplementedCertificateServiceServer) RenewExpiringCertificates(ctx sdk_go.ObjectContext, req *RenewExpiringCertificatesRequest) (*RenewExpiringCertificatesResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method RenewExpiringCertificates not implemented"), 501)
}
func (UnimplementedCertificateServiceServer) RefreshExpiringOCSPStaples(ctx sdk_go.ObjectContext, req *RefreshExpiringOCSPStaplesRequest) (*RefreshExpiringOCSPStaplesResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method RefreshExpiringOCSPStaples not implemented"), 501)
}
func (UnimplementedCertificateServiceServer) testEmbeddedByValue() {}

// UnsafeCertificateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CertificateServiceServer will
// result in compilation errors.
type UnsafeCertificateServiceServer interface {
	mustEmbedUnimplementedCertificateServiceServer()
}

func NewCertificateServiceServer(srv CertificateServiceServer, opts ...sdk_go.ServiceDefinitionOption) sdk_go.ServiceDefinition {
	// If the following call panics, it indicates UnimplementedCertificateServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	sOpts := append([]sdk_go.ServiceDefinitionOption{sdk_go.WithProtoJSON}, opts...)
	router := sdk_go.NewObject("hydra.v1.CertificateService", sOpts...)
	router = router.Handler("ProcessChallenge", sdk_go.NewObjectHandler(srv.ProcessChallenge))
	router = router.Handler("RenewExpiringCertificates", sdk_go.NewObjectHandler(srv.RenewExpiringCertificates))
	router = router.Handler("RefreshExpiringOCSPStaples", sdk_go.NewObjectHandler(srv.RefreshExpiringOCSPStaples))
	return router
}
