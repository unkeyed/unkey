// Code generated by protoc-gen-go-restate. DO NOT EDIT.
// versions:
// - protoc-gen-go-restate v0.1
// - protoc             (unknown)
// source: hydra/v1/deployment.proto

package hydrav1

import (
	fmt "fmt"
	sdk_go "github.com/restatedev/sdk-go"
	encoding "github.com/restatedev/sdk-go/encoding"
	ingress "github.com/restatedev/sdk-go/ingress"
)

// DeploymentServiceClient is the client API for hydra.v1.DeploymentService service.
//
// DeploymentService manages desired-state transitions for a single deployment
// as a Restate virtual object keyed by deployment ID. The virtual object key
// guarantees that only one state change operation executes per deployment at a
// time, preventing conflicting concurrent transitions.
//
// State transitions use last-writer-wins semantics: calling
// ScheduleDesiredStateChange while a previous transition is still pending
// overwrites it. This is implemented via a nonce — each schedule generates a
// unique nonce stored in Restate state, and ChangeDesiredState silently no-ops
// if its nonce doesn't match the stored one, meaning the transition was
// superseded by a newer schedule.
//
// Typical flow:
//  1. Caller invokes ScheduleDesiredStateChange with a target state and a
//     relative delay in milliseconds for when the change should take effect.
//  2. The handler stores the transition record and sends a delayed
//     ChangeDesiredState call to itself.
//  3. When the delay elapses, ChangeDesiredState verifies the nonce still
//     matches and persists the new desired state to the database.
type DeploymentServiceClient interface {
	// ScheduleDesiredStateChange registers a future desired-state transition for
	// this deployment. It generates a nonce, stores a transition record in Restate
	// state, and sends a delayed ChangeDesiredState call to itself after the
	// requested delay. Calling this again before the previous transition fires
	// replaces it (last-writer-wins via nonce).
	ScheduleDesiredStateChange(opts ...sdk_go.ClientOption) sdk_go.Client[*ScheduleDesiredStateChangeRequest, *ScheduleDesiredStateChangeResponse]
	// ChangeDesiredState is an internal handler invoked by the delayed call from
	// ScheduleDesiredStateChange. It verifies the nonce matches the stored
	// transition record — if it doesn't, the transition was superseded and the
	// call no-ops. On match, it persists the new desired state to the database.
	// The deployment ID is derived from the virtual object key.
	ChangeDesiredState(opts ...sdk_go.ClientOption) sdk_go.Client[*ChangeDesiredStateRequest, *ChangeDesiredStateResponse]
	// ClearScheduledStateChanges removes the pending transition record from
	// Restate state, effectively cancelling any scheduled ChangeDesiredState
	// call. The delayed call may still fire, but it will no-op because
	// ChangeDesiredState requires a stored transition to exist.
	ClearScheduledStateChanges(opts ...sdk_go.ClientOption) sdk_go.Client[*ClearScheduledStateChangesRequest, *ClearScheduledStateChangesResponse]
}

type deploymentServiceClient struct {
	ctx     sdk_go.Context
	key     string
	options []sdk_go.ClientOption
}

func NewDeploymentServiceClient(ctx sdk_go.Context, key string, opts ...sdk_go.ClientOption) DeploymentServiceClient {
	cOpts := append([]sdk_go.ClientOption{sdk_go.WithProtoJSON}, opts...)
	return &deploymentServiceClient{
		ctx,
		key,
		cOpts,
	}
}
func (c *deploymentServiceClient) ScheduleDesiredStateChange(opts ...sdk_go.ClientOption) sdk_go.Client[*ScheduleDesiredStateChangeRequest, *ScheduleDesiredStateChangeResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*ScheduleDesiredStateChangeRequest](sdk_go.Object[*ScheduleDesiredStateChangeResponse](c.ctx, "hydra.v1.DeploymentService", c.key, "ScheduleDesiredStateChange", cOpts...))
}

func (c *deploymentServiceClient) ChangeDesiredState(opts ...sdk_go.ClientOption) sdk_go.Client[*ChangeDesiredStateRequest, *ChangeDesiredStateResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*ChangeDesiredStateRequest](sdk_go.Object[*ChangeDesiredStateResponse](c.ctx, "hydra.v1.DeploymentService", c.key, "ChangeDesiredState", cOpts...))
}

func (c *deploymentServiceClient) ClearScheduledStateChanges(opts ...sdk_go.ClientOption) sdk_go.Client[*ClearScheduledStateChangesRequest, *ClearScheduledStateChangesResponse] {
	cOpts := c.options
	if len(opts) > 0 {
		cOpts = append(append([]sdk_go.ClientOption{}, cOpts...), opts...)
	}
	return sdk_go.WithRequestType[*ClearScheduledStateChangesRequest](sdk_go.Object[*ClearScheduledStateChangesResponse](c.ctx, "hydra.v1.DeploymentService", c.key, "ClearScheduledStateChanges", cOpts...))
}

// DeploymentServiceIngressClient is the ingress client API for hydra.v1.DeploymentService service.
//
// This client is used to call the service from outside of a Restate context.
type DeploymentServiceIngressClient interface {
	// ScheduleDesiredStateChange registers a future desired-state transition for
	// this deployment. It generates a nonce, stores a transition record in Restate
	// state, and sends a delayed ChangeDesiredState call to itself after the
	// requested delay. Calling this again before the previous transition fires
	// replaces it (last-writer-wins via nonce).
	ScheduleDesiredStateChange() ingress.Requester[*ScheduleDesiredStateChangeRequest, *ScheduleDesiredStateChangeResponse]
	// ChangeDesiredState is an internal handler invoked by the delayed call from
	// ScheduleDesiredStateChange. It verifies the nonce matches the stored
	// transition record — if it doesn't, the transition was superseded and the
	// call no-ops. On match, it persists the new desired state to the database.
	// The deployment ID is derived from the virtual object key.
	ChangeDesiredState() ingress.Requester[*ChangeDesiredStateRequest, *ChangeDesiredStateResponse]
	// ClearScheduledStateChanges removes the pending transition record from
	// Restate state, effectively cancelling any scheduled ChangeDesiredState
	// call. The delayed call may still fire, but it will no-op because
	// ChangeDesiredState requires a stored transition to exist.
	ClearScheduledStateChanges() ingress.Requester[*ClearScheduledStateChangesRequest, *ClearScheduledStateChangesResponse]
}

type deploymentServiceIngressClient struct {
	client      *ingress.Client
	serviceName string
	key         string
}

func NewDeploymentServiceIngressClient(client *ingress.Client, key string) DeploymentServiceIngressClient {
	return &deploymentServiceIngressClient{
		client,
		"hydra.v1.DeploymentService",
		key,
	}
}

func (c *deploymentServiceIngressClient) ScheduleDesiredStateChange() ingress.Requester[*ScheduleDesiredStateChangeRequest, *ScheduleDesiredStateChangeResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*ScheduleDesiredStateChangeRequest, *ScheduleDesiredStateChangeResponse](c.client, c.serviceName, "ScheduleDesiredStateChange", &c.key, &codec)
}

func (c *deploymentServiceIngressClient) ChangeDesiredState() ingress.Requester[*ChangeDesiredStateRequest, *ChangeDesiredStateResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*ChangeDesiredStateRequest, *ChangeDesiredStateResponse](c.client, c.serviceName, "ChangeDesiredState", &c.key, &codec)
}

func (c *deploymentServiceIngressClient) ClearScheduledStateChanges() ingress.Requester[*ClearScheduledStateChangesRequest, *ClearScheduledStateChangesResponse] {
	codec := encoding.ProtoJSONCodec
	return ingress.NewRequester[*ClearScheduledStateChangesRequest, *ClearScheduledStateChangesResponse](c.client, c.serviceName, "ClearScheduledStateChanges", &c.key, &codec)
}

// DeploymentServiceServer is the server API for hydra.v1.DeploymentService service.
// All implementations should embed UnimplementedDeploymentServiceServer
// for forward compatibility.
//
// DeploymentService manages desired-state transitions for a single deployment
// as a Restate virtual object keyed by deployment ID. The virtual object key
// guarantees that only one state change operation executes per deployment at a
// time, preventing conflicting concurrent transitions.
//
// State transitions use last-writer-wins semantics: calling
// ScheduleDesiredStateChange while a previous transition is still pending
// overwrites it. This is implemented via a nonce — each schedule generates a
// unique nonce stored in Restate state, and ChangeDesiredState silently no-ops
// if its nonce doesn't match the stored one, meaning the transition was
// superseded by a newer schedule.
//
// Typical flow:
//  1. Caller invokes ScheduleDesiredStateChange with a target state and a
//     relative delay in milliseconds for when the change should take effect.
//  2. The handler stores the transition record and sends a delayed
//     ChangeDesiredState call to itself.
//  3. When the delay elapses, ChangeDesiredState verifies the nonce still
//     matches and persists the new desired state to the database.
type DeploymentServiceServer interface {
	// ScheduleDesiredStateChange registers a future desired-state transition for
	// this deployment. It generates a nonce, stores a transition record in Restate
	// state, and sends a delayed ChangeDesiredState call to itself after the
	// requested delay. Calling this again before the previous transition fires
	// replaces it (last-writer-wins via nonce).
	ScheduleDesiredStateChange(ctx sdk_go.ObjectContext, req *ScheduleDesiredStateChangeRequest) (*ScheduleDesiredStateChangeResponse, error)
	// ChangeDesiredState is an internal handler invoked by the delayed call from
	// ScheduleDesiredStateChange. It verifies the nonce matches the stored
	// transition record — if it doesn't, the transition was superseded and the
	// call no-ops. On match, it persists the new desired state to the database.
	// The deployment ID is derived from the virtual object key.
	ChangeDesiredState(ctx sdk_go.ObjectContext, req *ChangeDesiredStateRequest) (*ChangeDesiredStateResponse, error)
	// ClearScheduledStateChanges removes the pending transition record from
	// Restate state, effectively cancelling any scheduled ChangeDesiredState
	// call. The delayed call may still fire, but it will no-op because
	// ChangeDesiredState requires a stored transition to exist.
	ClearScheduledStateChanges(ctx sdk_go.ObjectContext, req *ClearScheduledStateChangesRequest) (*ClearScheduledStateChangesResponse, error)
}

// UnimplementedDeploymentServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDeploymentServiceServer struct{}

func (UnimplementedDeploymentServiceServer) ScheduleDesiredStateChange(ctx sdk_go.ObjectContext, req *ScheduleDesiredStateChangeRequest) (*ScheduleDesiredStateChangeResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method ScheduleDesiredStateChange not implemented"), 501)
}
func (UnimplementedDeploymentServiceServer) ChangeDesiredState(ctx sdk_go.ObjectContext, req *ChangeDesiredStateRequest) (*ChangeDesiredStateResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method ChangeDesiredState not implemented"), 501)
}
func (UnimplementedDeploymentServiceServer) ClearScheduledStateChanges(ctx sdk_go.ObjectContext, req *ClearScheduledStateChangesRequest) (*ClearScheduledStateChangesResponse, error) {
	return nil, sdk_go.TerminalError(fmt.Errorf("method ClearScheduledStateChanges not implemented"), 501)
}
func (UnimplementedDeploymentServiceServer) testEmbeddedByValue() {}

// UnsafeDeploymentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeploymentServiceServer will
// result in compilation errors.
type UnsafeDeploymentServiceServer interface {
	mustEmbedUnimplementedDeploymentServiceServer()
}

func NewDeploymentServiceServer(srv DeploymentServiceServer, opts ...sdk_go.ServiceDefinitionOption) sdk_go.ServiceDefinition {
	// If the following call panics, it indicates UnimplementedDeploymentServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	sOpts := append([]sdk_go.ServiceDefinitionOption{sdk_go.WithProtoJSON}, opts...)
	router := sdk_go.NewObject("hydra.v1.DeploymentService", sOpts...)
	router = router.Handler("ScheduleDesiredStateChange", sdk_go.NewObjectHandler(srv.ScheduleDesiredStateChange))
	router = router.Handler("ChangeDesiredState", sdk_go.NewObjectHandler(srv.ChangeDesiredState))
	router = router.Handler("ClearScheduledStateChanges", sdk_go.NewObjectHandler(srv.ClearScheduledStateChanges))
	return router
}
