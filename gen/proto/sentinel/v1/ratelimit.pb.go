// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: middleware/v1/ratelimit.proto

package sentinelv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// RateLimit enforces request rate limits at the gateway, protecting upstream
// services from being overwhelmed by traffic spikes, abusive clients, or
// misconfigured integrations.
//
// Rate limiting at the proxy layer rather than in application code ensures
// consistent enforcement across all endpoints. It also means the upstream
// never sees the excess traffic, which matters for cost-sensitive services
// and APIs with expensive backend operations.
//
// Sentinel delegates rate limit state to Unkey's distributed rate limiting
// service, which provides consistent counts across multiple sentinel
// instances. This is critical for horizontally scaled deployments where
// per-instance counters would allow N times the intended rate.
type RateLimit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Maximum number of requests allowed within the window. When the count
	// within the current window exceeds this value, subsequent requests are
	// rejected with 429 Too Many Requests.
	Limit int64 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
	// The time window in milliseconds over which the limit is enforced.
	// For example, limit=100 with window_ms=60000 means "100 requests per
	// minute".
	WindowMs int64 `protobuf:"varint,2,opt,name=window_ms,json=windowMs,proto3" json:"window_ms,omitempty"`
	// How to derive the rate limit key â€” the identity of "who" is being
	// limited. This determines whether limits are per-IP, per-header-value,
	// per-authenticated-subject, or per-claim. Choosing the right key source
	// is critical: IP-based limiting can be defeated by proxies and NAT,
	// header-based limiting relies on client-supplied values, and subject-based
	// limiting requires an upstream authn policy to have produced a [Principal].
	Key           *RateLimitKey `protobuf:"bytes,3,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RateLimit) Reset() {
	*x = RateLimit{}
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RateLimit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimit) ProtoMessage() {}

func (x *RateLimit) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimit.ProtoReflect.Descriptor instead.
func (*RateLimit) Descriptor() ([]byte, []int) {
	return file_middleware_v1_ratelimit_proto_rawDescGZIP(), []int{0}
}

func (x *RateLimit) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *RateLimit) GetWindowMs() int64 {
	if x != nil {
		return x.WindowMs
	}
	return 0
}

func (x *RateLimit) GetKey() *RateLimitKey {
	if x != nil {
		return x.Key
	}
	return nil
}

// RateLimitKey determines how sentinel identifies the entity being rate
// limited. The choice of key source fundamentally changes the limiting
// behavior, so it should match the threat model and use case.
type RateLimitKey struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Source:
	//
	//	*RateLimitKey_RemoteIp
	//	*RateLimitKey_Header
	//	*RateLimitKey_AuthenticatedSubject
	//	*RateLimitKey_Path
	//	*RateLimitKey_PrincipalClaim
	Source        isRateLimitKey_Source `protobuf_oneof:"source"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RateLimitKey) Reset() {
	*x = RateLimitKey{}
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RateLimitKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RateLimitKey) ProtoMessage() {}

func (x *RateLimitKey) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RateLimitKey.ProtoReflect.Descriptor instead.
func (*RateLimitKey) Descriptor() ([]byte, []int) {
	return file_middleware_v1_ratelimit_proto_rawDescGZIP(), []int{1}
}

func (x *RateLimitKey) GetSource() isRateLimitKey_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *RateLimitKey) GetRemoteIp() *RemoteIpKey {
	if x != nil {
		if x, ok := x.Source.(*RateLimitKey_RemoteIp); ok {
			return x.RemoteIp
		}
	}
	return nil
}

func (x *RateLimitKey) GetHeader() *HeaderKey {
	if x != nil {
		if x, ok := x.Source.(*RateLimitKey_Header); ok {
			return x.Header
		}
	}
	return nil
}

func (x *RateLimitKey) GetAuthenticatedSubject() *AuthenticatedSubjectKey {
	if x != nil {
		if x, ok := x.Source.(*RateLimitKey_AuthenticatedSubject); ok {
			return x.AuthenticatedSubject
		}
	}
	return nil
}

func (x *RateLimitKey) GetPath() *PathKey {
	if x != nil {
		if x, ok := x.Source.(*RateLimitKey_Path); ok {
			return x.Path
		}
	}
	return nil
}

func (x *RateLimitKey) GetPrincipalClaim() *PrincipalClaimKey {
	if x != nil {
		if x, ok := x.Source.(*RateLimitKey_PrincipalClaim); ok {
			return x.PrincipalClaim
		}
	}
	return nil
}

type isRateLimitKey_Source interface {
	isRateLimitKey_Source()
}

type RateLimitKey_RemoteIp struct {
	// Limit by the client's IP address. Effective for anonymous traffic and
	// DDoS protection, but can over-limit legitimate users behind shared
	// NATs or corporate proxies where many clients share a single IP.
	// The client IP is derived using the trusted proxy configuration in
	// [Middleware.trusted_proxy_cidrs].
	RemoteIp *RemoteIpKey `protobuf:"bytes,1,opt,name=remote_ip,json=remoteIp,proto3,oneof"`
}

type RateLimitKey_Header struct {
	// Limit by the value of a specific request header. Useful for
	// pre-authenticated traffic where a trusted upstream has already
	// identified the caller via a header like X-Tenant-Id. Since clients
	// can set arbitrary headers, this should only be used when sentinel is
	// behind a trusted proxy that sets the header.
	Header *HeaderKey `protobuf:"bytes,2,opt,name=header,proto3,oneof"`
}

type RateLimitKey_AuthenticatedSubject struct {
	// Limit by the [Principal] subject produced by an upstream authn policy.
	// This is the most accurate key source for authenticated APIs because
	// it limits each authenticated identity independently, regardless of
	// how many IPs or devices they use. Requires a [KeyAuth], [JWTAuth],
	// or [BasicAuth] policy earlier in the policy list.
	AuthenticatedSubject *AuthenticatedSubjectKey `protobuf:"bytes,3,opt,name=authenticated_subject,json=authenticatedSubject,proto3,oneof"`
}

type RateLimitKey_Path struct {
	// Limit by the request URL path. Creates a separate rate limit bucket
	// per path, useful for protecting specific expensive endpoints without
	// needing a separate policy per route.
	Path *PathKey `protobuf:"bytes,4,opt,name=path,proto3,oneof"`
}

type RateLimitKey_PrincipalClaim struct {
	// Limit by a specific claim from the [Principal]. This enables
	// per-organization or per-tenant rate limiting when the identity claim
	// is more granular than what you want to throttle. For example, using
	// claim_name "org_id" creates a shared rate limit bucket for all users
	// within the same organization, regardless of which individual subject
	// authenticated. Requires a [Principal] with the named claim present
	// in its claims map.
	PrincipalClaim *PrincipalClaimKey `protobuf:"bytes,5,opt,name=principal_claim,json=principalClaim,proto3,oneof"`
}

func (*RateLimitKey_RemoteIp) isRateLimitKey_Source() {}

func (*RateLimitKey_Header) isRateLimitKey_Source() {}

func (*RateLimitKey_AuthenticatedSubject) isRateLimitKey_Source() {}

func (*RateLimitKey_Path) isRateLimitKey_Source() {}

func (*RateLimitKey_PrincipalClaim) isRateLimitKey_Source() {}

// RemoteIpKey derives the rate limit key from the client's IP address.
type RemoteIpKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RemoteIpKey) Reset() {
	*x = RemoteIpKey{}
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RemoteIpKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RemoteIpKey) ProtoMessage() {}

func (x *RemoteIpKey) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RemoteIpKey.ProtoReflect.Descriptor instead.
func (*RemoteIpKey) Descriptor() ([]byte, []int) {
	return file_middleware_v1_ratelimit_proto_rawDescGZIP(), []int{2}
}

// HeaderKey derives the rate limit key from a request header value.
type HeaderKey struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The header name to read, e.g. "X-Tenant-Id". If the header is absent,
	// the request is rate limited under a shared "unknown" bucket.
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeaderKey) Reset() {
	*x = HeaderKey{}
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeaderKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeaderKey) ProtoMessage() {}

func (x *HeaderKey) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeaderKey.ProtoReflect.Descriptor instead.
func (*HeaderKey) Descriptor() ([]byte, []int) {
	return file_middleware_v1_ratelimit_proto_rawDescGZIP(), []int{3}
}

func (x *HeaderKey) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// AuthenticatedSubjectKey derives the rate limit key from the [Principal]
// subject. If no Principal exists (no authn policy matched or all authn
// policies allowed anonymous access), the request is rate limited under a
// shared anonymous bucket.
type AuthenticatedSubjectKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AuthenticatedSubjectKey) Reset() {
	*x = AuthenticatedSubjectKey{}
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthenticatedSubjectKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthenticatedSubjectKey) ProtoMessage() {}

func (x *AuthenticatedSubjectKey) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthenticatedSubjectKey.ProtoReflect.Descriptor instead.
func (*AuthenticatedSubjectKey) Descriptor() ([]byte, []int) {
	return file_middleware_v1_ratelimit_proto_rawDescGZIP(), []int{4}
}

// PathKey derives the rate limit key from the request URL path.
type PathKey struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PathKey) Reset() {
	*x = PathKey{}
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PathKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PathKey) ProtoMessage() {}

func (x *PathKey) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PathKey.ProtoReflect.Descriptor instead.
func (*PathKey) Descriptor() ([]byte, []int) {
	return file_middleware_v1_ratelimit_proto_rawDescGZIP(), []int{5}
}

// PrincipalClaimKey derives the rate limit key from a named claim in the
// [Principal]'s claims map. If the claim is absent or the Principal does
// not exist, the request is rate limited under a shared "unknown" bucket.
type PrincipalClaimKey struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The claim name to read from [Principal].claims, e.g. "org_id" or
	// "plan". The claim value becomes the rate limit bucket key.
	ClaimName     string `protobuf:"bytes,1,opt,name=claim_name,json=claimName,proto3" json:"claim_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PrincipalClaimKey) Reset() {
	*x = PrincipalClaimKey{}
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PrincipalClaimKey) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PrincipalClaimKey) ProtoMessage() {}

func (x *PrincipalClaimKey) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_ratelimit_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PrincipalClaimKey.ProtoReflect.Descriptor instead.
func (*PrincipalClaimKey) Descriptor() ([]byte, []int) {
	return file_middleware_v1_ratelimit_proto_rawDescGZIP(), []int{6}
}

func (x *PrincipalClaimKey) GetClaimName() string {
	if x != nil {
		return x.ClaimName
	}
	return ""
}

var File_middleware_v1_ratelimit_proto protoreflect.FileDescriptor

const file_middleware_v1_ratelimit_proto_rawDesc = "" +
	"\n" +
	"\x1dmiddleware/v1/ratelimit.proto\x12\vsentinel.v1\"k\n" +
	"\tRateLimit\x12\x14\n" +
	"\x05limit\x18\x01 \x01(\x03R\x05limit\x12\x1b\n" +
	"\twindow_ms\x18\x02 \x01(\x03R\bwindowMs\x12+\n" +
	"\x03key\x18\x03 \x01(\v2\x19.sentinel.v1.RateLimitKeyR\x03key\"\xd7\x02\n" +
	"\fRateLimitKey\x127\n" +
	"\tremote_ip\x18\x01 \x01(\v2\x18.sentinel.v1.RemoteIpKeyH\x00R\bremoteIp\x120\n" +
	"\x06header\x18\x02 \x01(\v2\x16.sentinel.v1.HeaderKeyH\x00R\x06header\x12[\n" +
	"\x15authenticated_subject\x18\x03 \x01(\v2$.sentinel.v1.AuthenticatedSubjectKeyH\x00R\x14authenticatedSubject\x12*\n" +
	"\x04path\x18\x04 \x01(\v2\x14.sentinel.v1.PathKeyH\x00R\x04path\x12I\n" +
	"\x0fprincipal_claim\x18\x05 \x01(\v2\x1e.sentinel.v1.PrincipalClaimKeyH\x00R\x0eprincipalClaimB\b\n" +
	"\x06source\"\r\n" +
	"\vRemoteIpKey\"\x1f\n" +
	"\tHeaderKey\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\"\x19\n" +
	"\x17AuthenticatedSubjectKey\"\t\n" +
	"\aPathKey\"2\n" +
	"\x11PrincipalClaimKey\x12\x1d\n" +
	"\n" +
	"claim_name\x18\x01 \x01(\tR\tclaimNameB\xa9\x01\n" +
	"\x0fcom.sentinel.v1B\x0eRatelimitProtoP\x01Z9github.com/unkeyed/unkey/gen/proto/sentinel/v1;sentinelv1\xa2\x02\x03SXX\xaa\x02\vSentinel.V1\xca\x02\vSentinel\\V1\xe2\x02\x17Sentinel\\V1\\GPBMetadata\xea\x02\fSentinel::V1b\x06proto3"

var (
	file_middleware_v1_ratelimit_proto_rawDescOnce sync.Once
	file_middleware_v1_ratelimit_proto_rawDescData []byte
)

func file_middleware_v1_ratelimit_proto_rawDescGZIP() []byte {
	file_middleware_v1_ratelimit_proto_rawDescOnce.Do(func() {
		file_middleware_v1_ratelimit_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_middleware_v1_ratelimit_proto_rawDesc), len(file_middleware_v1_ratelimit_proto_rawDesc)))
	})
	return file_middleware_v1_ratelimit_proto_rawDescData
}

var file_middleware_v1_ratelimit_proto_msgTypes = make([]protoimpl.MessageInfo, 7)
var file_middleware_v1_ratelimit_proto_goTypes = []any{
	(*RateLimit)(nil),               // 0: sentinel.v1.RateLimit
	(*RateLimitKey)(nil),            // 1: sentinel.v1.RateLimitKey
	(*RemoteIpKey)(nil),             // 2: sentinel.v1.RemoteIpKey
	(*HeaderKey)(nil),               // 3: sentinel.v1.HeaderKey
	(*AuthenticatedSubjectKey)(nil), // 4: sentinel.v1.AuthenticatedSubjectKey
	(*PathKey)(nil),                 // 5: sentinel.v1.PathKey
	(*PrincipalClaimKey)(nil),       // 6: sentinel.v1.PrincipalClaimKey
}
var file_middleware_v1_ratelimit_proto_depIdxs = []int32{
	1, // 0: sentinel.v1.RateLimit.key:type_name -> sentinel.v1.RateLimitKey
	2, // 1: sentinel.v1.RateLimitKey.remote_ip:type_name -> sentinel.v1.RemoteIpKey
	3, // 2: sentinel.v1.RateLimitKey.header:type_name -> sentinel.v1.HeaderKey
	4, // 3: sentinel.v1.RateLimitKey.authenticated_subject:type_name -> sentinel.v1.AuthenticatedSubjectKey
	5, // 4: sentinel.v1.RateLimitKey.path:type_name -> sentinel.v1.PathKey
	6, // 5: sentinel.v1.RateLimitKey.principal_claim:type_name -> sentinel.v1.PrincipalClaimKey
	6, // [6:6] is the sub-list for method output_type
	6, // [6:6] is the sub-list for method input_type
	6, // [6:6] is the sub-list for extension type_name
	6, // [6:6] is the sub-list for extension extendee
	0, // [0:6] is the sub-list for field type_name
}

func init() { file_middleware_v1_ratelimit_proto_init() }
func file_middleware_v1_ratelimit_proto_init() {
	if File_middleware_v1_ratelimit_proto != nil {
		return
	}
	file_middleware_v1_ratelimit_proto_msgTypes[1].OneofWrappers = []any{
		(*RateLimitKey_RemoteIp)(nil),
		(*RateLimitKey_Header)(nil),
		(*RateLimitKey_AuthenticatedSubject)(nil),
		(*RateLimitKey_Path)(nil),
		(*RateLimitKey_PrincipalClaim)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_middleware_v1_ratelimit_proto_rawDesc), len(file_middleware_v1_ratelimit_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   7,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_middleware_v1_ratelimit_proto_goTypes,
		DependencyIndexes: file_middleware_v1_ratelimit_proto_depIdxs,
		MessageInfos:      file_middleware_v1_ratelimit_proto_msgTypes,
	}.Build()
	File_middleware_v1_ratelimit_proto = out.File
	file_middleware_v1_ratelimit_proto_goTypes = nil
	file_middleware_v1_ratelimit_proto_depIdxs = nil
}
