// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: policies/v1/policy.proto

package sentinelv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Policy is a single middleware layer in a deployment's configuration. Each policy
// combines a match expression (which requests does it apply to?) with a
// configuration (what does it do?). This separation is what makes the system
// composable: the same rate limiter config can be scoped to POST /api/*
// without the rate limiter needing to know anything about path matching.
//
// Policies carry a stable id for correlation across logs, metrics, and
// debugging. The disabled flag allows operators to disable a policy without
// removing it from config, which is critical for incident response — you can
// turn off a misbehaving policy and re-enable it once the issue is resolved,
// without losing the configuration or triggering a full redeploy.
type Policy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Stable identifier for this policy, used in log entries, metrics labels,
	// and error messages. Should be unique within a deployment's Middleware
	// config. Typically a UUID or a slug like "api-ratelimit".
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Human-friendly label displayed in the dashboard and audit logs.
	// Does not affect policy behavior.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// When false, sentinel skips this policy entirely during evaluation.
	// This allows operators to toggle policies on and off without modifying
	// or removing the underlying configuration, which is useful during
	// incidents, gradual rollouts, and debugging.
	Enabled bool `protobuf:"varint,3,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// Match conditions that determine which requests this policy applies to.
	// All entries must match for the policy to run (implicit AND). An empty
	// list matches all requests — this is the common case for global policies
	// like IP allowlists or rate limiting.
	//
	// For OR semantics, create separate policies with the same config and
	// different match lists.
	Match []*MatchExpr `protobuf:"bytes,4,rep,name=match,proto3" json:"match,omitempty"`
	// The policy configuration. Exactly one must be set.
	//
	// Types that are valid to be assigned to Config:
	//
	//	*Policy_Keyauth
	//	*Policy_Jwtauth
	//	*Policy_Basicauth
	//	*Policy_Ratelimit
	//	*Policy_IpRules
	//	*Policy_Openapi
	Config        isPolicy_Config `protobuf_oneof:"config"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Policy) Reset() {
	*x = Policy{}
	mi := &file_policies_v1_policy_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Policy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Policy) ProtoMessage() {}

func (x *Policy) ProtoReflect() protoreflect.Message {
	mi := &file_policies_v1_policy_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Policy.ProtoReflect.Descriptor instead.
func (*Policy) Descriptor() ([]byte, []int) {
	return file_policies_v1_policy_proto_rawDescGZIP(), []int{0}
}

func (x *Policy) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Policy) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Policy) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *Policy) GetMatch() []*MatchExpr {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *Policy) GetConfig() isPolicy_Config {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *Policy) GetKeyauth() *KeyAuth {
	if x != nil {
		if x, ok := x.Config.(*Policy_Keyauth); ok {
			return x.Keyauth
		}
	}
	return nil
}

func (x *Policy) GetJwtauth() *JWTAuth {
	if x != nil {
		if x, ok := x.Config.(*Policy_Jwtauth); ok {
			return x.Jwtauth
		}
	}
	return nil
}

func (x *Policy) GetBasicauth() *BasicAuth {
	if x != nil {
		if x, ok := x.Config.(*Policy_Basicauth); ok {
			return x.Basicauth
		}
	}
	return nil
}

func (x *Policy) GetRatelimit() *RateLimit {
	if x != nil {
		if x, ok := x.Config.(*Policy_Ratelimit); ok {
			return x.Ratelimit
		}
	}
	return nil
}

func (x *Policy) GetIpRules() *IPRules {
	if x != nil {
		if x, ok := x.Config.(*Policy_IpRules); ok {
			return x.IpRules
		}
	}
	return nil
}

func (x *Policy) GetOpenapi() *OpenApiRequestValidation {
	if x != nil {
		if x, ok := x.Config.(*Policy_Openapi); ok {
			return x.Openapi
		}
	}
	return nil
}

type isPolicy_Config interface {
	isPolicy_Config()
}

type Policy_Keyauth struct {
	Keyauth *KeyAuth `protobuf:"bytes,5,opt,name=keyauth,proto3,oneof"`
}

type Policy_Jwtauth struct {
	Jwtauth *JWTAuth `protobuf:"bytes,6,opt,name=jwtauth,proto3,oneof"`
}

type Policy_Basicauth struct {
	Basicauth *BasicAuth `protobuf:"bytes,7,opt,name=basicauth,proto3,oneof"`
}

type Policy_Ratelimit struct {
	Ratelimit *RateLimit `protobuf:"bytes,8,opt,name=ratelimit,proto3,oneof"`
}

type Policy_IpRules struct {
	IpRules *IPRules `protobuf:"bytes,9,opt,name=ip_rules,json=ipRules,proto3,oneof"`
}

type Policy_Openapi struct {
	Openapi *OpenApiRequestValidation `protobuf:"bytes,10,opt,name=openapi,proto3,oneof"`
}

func (*Policy_Keyauth) isPolicy_Config() {}

func (*Policy_Jwtauth) isPolicy_Config() {}

func (*Policy_Basicauth) isPolicy_Config() {}

func (*Policy_Ratelimit) isPolicy_Config() {}

func (*Policy_IpRules) isPolicy_Config() {}

func (*Policy_Openapi) isPolicy_Config() {}

var File_policies_v1_policy_proto protoreflect.FileDescriptor

const file_policies_v1_policy_proto_rawDesc = "" +
	"\n" +
	"\x18policies/v1/policy.proto\x12\vsentinel.v1\x1a\x1bpolicies/v1/basicauth.proto\x1a\x19policies/v1/iprules.proto\x1a\x19policies/v1/jwtauth.proto\x1a\x19policies/v1/keyauth.proto\x1a\x17policies/v1/match.proto\x1a\x19policies/v1/openapi.proto\x1a\x1bpolicies/v1/ratelimit.proto\"\xc8\x03\n" +
	"\x06Policy\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
	"\aenabled\x18\x03 \x01(\bR\aenabled\x12,\n" +
	"\x05match\x18\x04 \x03(\v2\x16.sentinel.v1.MatchExprR\x05match\x120\n" +
	"\akeyauth\x18\x05 \x01(\v2\x14.sentinel.v1.KeyAuthH\x00R\akeyauth\x120\n" +
	"\ajwtauth\x18\x06 \x01(\v2\x14.sentinel.v1.JWTAuthH\x00R\ajwtauth\x126\n" +
	"\tbasicauth\x18\a \x01(\v2\x16.sentinel.v1.BasicAuthH\x00R\tbasicauth\x126\n" +
	"\tratelimit\x18\b \x01(\v2\x16.sentinel.v1.RateLimitH\x00R\tratelimit\x121\n" +
	"\bip_rules\x18\t \x01(\v2\x14.sentinel.v1.IPRulesH\x00R\aipRules\x12A\n" +
	"\aopenapi\x18\n" +
	" \x01(\v2%.sentinel.v1.OpenApiRequestValidationH\x00R\aopenapiB\b\n" +
	"\x06configB\xa6\x01\n" +
	"\x0fcom.sentinel.v1B\vPolicyProtoP\x01Z9github.com/unkeyed/unkey/gen/proto/sentinel/v1;sentinelv1\xa2\x02\x03SXX\xaa\x02\vSentinel.V1\xca\x02\vSentinel\\V1\xe2\x02\x17Sentinel\\V1\\GPBMetadata\xea\x02\fSentinel::V1b\x06proto3"

var (
	file_policies_v1_policy_proto_rawDescOnce sync.Once
	file_policies_v1_policy_proto_rawDescData []byte
)

func file_policies_v1_policy_proto_rawDescGZIP() []byte {
	file_policies_v1_policy_proto_rawDescOnce.Do(func() {
		file_policies_v1_policy_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_policies_v1_policy_proto_rawDesc), len(file_policies_v1_policy_proto_rawDesc)))
	})
	return file_policies_v1_policy_proto_rawDescData
}

var file_policies_v1_policy_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_policies_v1_policy_proto_goTypes = []any{
	(*Policy)(nil),                   // 0: sentinel.v1.Policy
	(*MatchExpr)(nil),                // 1: sentinel.v1.MatchExpr
	(*KeyAuth)(nil),                  // 2: sentinel.v1.KeyAuth
	(*JWTAuth)(nil),                  // 3: sentinel.v1.JWTAuth
	(*BasicAuth)(nil),                // 4: sentinel.v1.BasicAuth
	(*RateLimit)(nil),                // 5: sentinel.v1.RateLimit
	(*IPRules)(nil),                  // 6: sentinel.v1.IPRules
	(*OpenApiRequestValidation)(nil), // 7: sentinel.v1.OpenApiRequestValidation
}
var file_policies_v1_policy_proto_depIdxs = []int32{
	1, // 0: sentinel.v1.Policy.match:type_name -> sentinel.v1.MatchExpr
	2, // 1: sentinel.v1.Policy.keyauth:type_name -> sentinel.v1.KeyAuth
	3, // 2: sentinel.v1.Policy.jwtauth:type_name -> sentinel.v1.JWTAuth
	4, // 3: sentinel.v1.Policy.basicauth:type_name -> sentinel.v1.BasicAuth
	5, // 4: sentinel.v1.Policy.ratelimit:type_name -> sentinel.v1.RateLimit
	6, // 5: sentinel.v1.Policy.ip_rules:type_name -> sentinel.v1.IPRules
	7, // 6: sentinel.v1.Policy.openapi:type_name -> sentinel.v1.OpenApiRequestValidation
	7, // [7:7] is the sub-list for method output_type
	7, // [7:7] is the sub-list for method input_type
	7, // [7:7] is the sub-list for extension type_name
	7, // [7:7] is the sub-list for extension extendee
	0, // [0:7] is the sub-list for field type_name
}

func init() { file_policies_v1_policy_proto_init() }
func file_policies_v1_policy_proto_init() {
	if File_policies_v1_policy_proto != nil {
		return
	}
	file_policies_v1_basicauth_proto_init()
	file_policies_v1_iprules_proto_init()
	file_policies_v1_jwtauth_proto_init()
	file_policies_v1_keyauth_proto_init()
	file_policies_v1_match_proto_init()
	file_policies_v1_openapi_proto_init()
	file_policies_v1_ratelimit_proto_init()
	file_policies_v1_policy_proto_msgTypes[0].OneofWrappers = []any{
		(*Policy_Keyauth)(nil),
		(*Policy_Jwtauth)(nil),
		(*Policy_Basicauth)(nil),
		(*Policy_Ratelimit)(nil),
		(*Policy_IpRules)(nil),
		(*Policy_Openapi)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_policies_v1_policy_proto_rawDesc), len(file_policies_v1_policy_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_policies_v1_policy_proto_goTypes,
		DependencyIndexes: file_policies_v1_policy_proto_depIdxs,
		MessageInfos:      file_policies_v1_policy_proto_msgTypes,
	}.Build()
	File_policies_v1_policy_proto = out.File
	file_policies_v1_policy_proto_goTypes = nil
	file_policies_v1_policy_proto_depIdxs = nil
}
