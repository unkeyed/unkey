// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: middleware/v1/jwtauth.proto

package sentinelv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// JWTAuth validates Bearer JSON Web Tokens using JWKS (JSON Web Key Sets)
// and produces a [Principal] on success.
//
// Without it, every upstream service must implement
// its own token validation, duplicating JWKS fetching, signature verification,
// claim validation, and key rotation logic. JWTAuth centralizes all of this
// at the proxy layer.
//
// On successful validation, JWTAuth produces a [Principal] with type
// PRINCIPAL_TYPE_JWT. The subject is extracted from a configurable token
// claim (default "sub"), and selected claims are forwarded into
// Principal.claims for use by downstream policies. This means a RateLimit
// policy can throttle per-user or per-organization (via PrincipalClaimKey),
// all without the upstream parsing the JWT itself.
//
// For common identity providers (Auth0, Clerk, Cognito, Okta), use the
// oidc_issuer field instead of jwks_uri — sentinel auto-discovers the
// JWKS endpoint via OpenID Connect discovery.
type JWTAuth struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The source of signing keys for token verification. Exactly one must
	// be set.
	//
	// Types that are valid to be assigned to JwksSource:
	//
	//	*JWTAuth_JwksUri
	//	*JWTAuth_OidcIssuer
	//	*JWTAuth_PublicKeyPem
	JwksSource isJWTAuth_JwksSource `protobuf_oneof:"jwks_source"`
	// Required issuer claim (iss). When set, tokens whose iss claim does not
	// match this value are rejected. This prevents tokens issued by one
	// provider from being accepted by a policy configured for another,
	// which is a critical security boundary in multi-tenant systems.
	Issuer string `protobuf:"bytes,3,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// Required audience claims (aud). The token must contain at least one of
	// these values in its aud claim. Audience validation prevents tokens
	// intended for one service from being used at another, which is especially
	// important when multiple services share the same identity provider.
	Audiences []string `protobuf:"bytes,4,rep,name=audiences,proto3" json:"audiences,omitempty"`
	// Allowed signing algorithms, e.g. ["RS256", "ES256"]. Defaults to
	// ["RS256"] if empty. Explicitly listing allowed algorithms is a security
	// best practice that prevents algorithm confusion attacks, where an
	// attacker crafts a token signed with an unexpected algorithm (like
	// "none" or HS256 with a public key as the HMAC secret).
	Algorithms []string `protobuf:"bytes,5,rep,name=algorithms,proto3" json:"algorithms,omitempty"`
	// Which token claim to use as the [Principal] subject. Defaults to "sub"
	// if empty. Override this when your identity provider uses a non-standard
	// claim for the primary identity (e.g., "uid" for some Okta
	// configurations, or "email" when you want email-based identity).
	SubjectClaim string `protobuf:"bytes,6,opt,name=subject_claim,json=subjectClaim,proto3" json:"subject_claim,omitempty"`
	// Additional token claims to extract into [Principal].claims. These become
	// available to downstream policies — for example, forwarding "org_id"
	// lets a RateLimit policy with a PrincipalClaimKey apply per-organization
	// limits.
	ForwardClaims []string `protobuf:"bytes,7,rep,name=forward_claims,json=forwardClaims,proto3" json:"forward_claims,omitempty"`
	// When true, requests without a Bearer token are allowed through without
	// authentication. No [Principal] is produced for anonymous requests. This
	// enables endpoints that serve both public and authenticated content,
	// where the upstream adjusts behavior based on whether identity headers
	// are present.
	AllowAnonymous bool `protobuf:"varint,8,opt,name=allow_anonymous,json=allowAnonymous,proto3" json:"allow_anonymous,omitempty"`
	// Maximum acceptable clock skew in milliseconds for exp (expiration) and
	// nbf (not before) claim validation. Defaults to 0, meaning no skew
	// tolerance. In distributed systems where clock synchronization is
	// imperfect, a small skew tolerance (e.g., 5000ms) prevents valid tokens
	// from being rejected due to minor clock differences between the token
	// issuer and sentinel.
	ClockSkewMs int64 `protobuf:"varint,9,opt,name=clock_skew_ms,json=clockSkewMs,proto3" json:"clock_skew_ms,omitempty"`
	// How long to cache JWKS responses in milliseconds. Defaults to 3600000
	// (1 hour). Sentinel refetches the JWKS when a token references a key ID
	// not found in the cache, which handles key rotation gracefully. A longer
	// cache duration reduces load on the JWKS endpoint but increases the time
	// before revoked keys are detected.
	JwksCacheMs   int64 `protobuf:"varint,10,opt,name=jwks_cache_ms,json=jwksCacheMs,proto3" json:"jwks_cache_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JWTAuth) Reset() {
	*x = JWTAuth{}
	mi := &file_middleware_v1_jwtauth_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JWTAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JWTAuth) ProtoMessage() {}

func (x *JWTAuth) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_jwtauth_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JWTAuth.ProtoReflect.Descriptor instead.
func (*JWTAuth) Descriptor() ([]byte, []int) {
	return file_middleware_v1_jwtauth_proto_rawDescGZIP(), []int{0}
}

func (x *JWTAuth) GetJwksSource() isJWTAuth_JwksSource {
	if x != nil {
		return x.JwksSource
	}
	return nil
}

func (x *JWTAuth) GetJwksUri() string {
	if x != nil {
		if x, ok := x.JwksSource.(*JWTAuth_JwksUri); ok {
			return x.JwksUri
		}
	}
	return ""
}

func (x *JWTAuth) GetOidcIssuer() string {
	if x != nil {
		if x, ok := x.JwksSource.(*JWTAuth_OidcIssuer); ok {
			return x.OidcIssuer
		}
	}
	return ""
}

func (x *JWTAuth) GetPublicKeyPem() []byte {
	if x != nil {
		if x, ok := x.JwksSource.(*JWTAuth_PublicKeyPem); ok {
			return x.PublicKeyPem
		}
	}
	return nil
}

func (x *JWTAuth) GetIssuer() string {
	if x != nil {
		return x.Issuer
	}
	return ""
}

func (x *JWTAuth) GetAudiences() []string {
	if x != nil {
		return x.Audiences
	}
	return nil
}

func (x *JWTAuth) GetAlgorithms() []string {
	if x != nil {
		return x.Algorithms
	}
	return nil
}

func (x *JWTAuth) GetSubjectClaim() string {
	if x != nil {
		return x.SubjectClaim
	}
	return ""
}

func (x *JWTAuth) GetForwardClaims() []string {
	if x != nil {
		return x.ForwardClaims
	}
	return nil
}

func (x *JWTAuth) GetAllowAnonymous() bool {
	if x != nil {
		return x.AllowAnonymous
	}
	return false
}

func (x *JWTAuth) GetClockSkewMs() int64 {
	if x != nil {
		return x.ClockSkewMs
	}
	return 0
}

func (x *JWTAuth) GetJwksCacheMs() int64 {
	if x != nil {
		return x.JwksCacheMs
	}
	return 0
}

type isJWTAuth_JwksSource interface {
	isJWTAuth_JwksSource()
}

type JWTAuth_JwksUri struct {
	// URI pointing to the JWKS endpoint that serves the signing keys, e.g.
	// "https://example.com/.well-known/jwks.json". Sentinel fetches and
	// caches these keys, using them to verify token signatures.
	//
	// Use this when you know the JWKS endpoint directly.
	JwksUri string `protobuf:"bytes,1,opt,name=jwks_uri,json=jwksUri,proto3,oneof"`
}

type JWTAuth_OidcIssuer struct {
	// OIDC issuer URL. Sentinel appends /.well-known/openid-configuration to
	// discover the JWKS URI automatically. This is the preferred approach for
	// OIDC-compliant providers because it also validates that the issuer claim
	// matches the discovery document.
	OidcIssuer string `protobuf:"bytes,2,opt,name=oidc_issuer,json=oidcIssuer,proto3,oneof"`
}

type JWTAuth_PublicKeyPem struct {
	// PEM-encoded public key for direct signature verification without a
	// JWKS endpoint. Useful for self-signed JWTs or simple setups where
	// key rotation is handled out-of-band and running a JWKS server is
	// unnecessary overhead. Also eliminates the runtime network dependency
	// on a JWKS endpoint.
	//
	// Must be a PEM-encoded RSA or EC public key (PKIX/X.509 format).
	PublicKeyPem []byte `protobuf:"bytes,11,opt,name=public_key_pem,json=publicKeyPem,proto3,oneof"`
}

func (*JWTAuth_JwksUri) isJWTAuth_JwksSource() {}

func (*JWTAuth_OidcIssuer) isJWTAuth_JwksSource() {}

func (*JWTAuth_PublicKeyPem) isJWTAuth_JwksSource() {}

var File_middleware_v1_jwtauth_proto protoreflect.FileDescriptor

const file_middleware_v1_jwtauth_proto_rawDesc = "" +
	"\n" +
	"\x1bmiddleware/v1/jwtauth.proto\x12\vsentinel.v1\"\x93\x03\n" +
	"\aJWTAuth\x12\x1b\n" +
	"\bjwks_uri\x18\x01 \x01(\tH\x00R\ajwksUri\x12!\n" +
	"\voidc_issuer\x18\x02 \x01(\tH\x00R\n" +
	"oidcIssuer\x12&\n" +
	"\x0epublic_key_pem\x18\v \x01(\fH\x00R\fpublicKeyPem\x12\x16\n" +
	"\x06issuer\x18\x03 \x01(\tR\x06issuer\x12\x1c\n" +
	"\taudiences\x18\x04 \x03(\tR\taudiences\x12\x1e\n" +
	"\n" +
	"algorithms\x18\x05 \x03(\tR\n" +
	"algorithms\x12#\n" +
	"\rsubject_claim\x18\x06 \x01(\tR\fsubjectClaim\x12%\n" +
	"\x0eforward_claims\x18\a \x03(\tR\rforwardClaims\x12'\n" +
	"\x0fallow_anonymous\x18\b \x01(\bR\x0eallowAnonymous\x12\"\n" +
	"\rclock_skew_ms\x18\t \x01(\x03R\vclockSkewMs\x12\"\n" +
	"\rjwks_cache_ms\x18\n" +
	" \x01(\x03R\vjwksCacheMsB\r\n" +
	"\vjwks_sourceB\xa7\x01\n" +
	"\x0fcom.sentinel.v1B\fJwtauthProtoP\x01Z9github.com/unkeyed/unkey/gen/proto/sentinel/v1;sentinelv1\xa2\x02\x03SXX\xaa\x02\vSentinel.V1\xca\x02\vSentinel\\V1\xe2\x02\x17Sentinel\\V1\\GPBMetadata\xea\x02\fSentinel::V1b\x06proto3"

var (
	file_middleware_v1_jwtauth_proto_rawDescOnce sync.Once
	file_middleware_v1_jwtauth_proto_rawDescData []byte
)

func file_middleware_v1_jwtauth_proto_rawDescGZIP() []byte {
	file_middleware_v1_jwtauth_proto_rawDescOnce.Do(func() {
		file_middleware_v1_jwtauth_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_middleware_v1_jwtauth_proto_rawDesc), len(file_middleware_v1_jwtauth_proto_rawDesc)))
	})
	return file_middleware_v1_jwtauth_proto_rawDescData
}

var file_middleware_v1_jwtauth_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_middleware_v1_jwtauth_proto_goTypes = []any{
	(*JWTAuth)(nil), // 0: sentinel.v1.JWTAuth
}
var file_middleware_v1_jwtauth_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_middleware_v1_jwtauth_proto_init() }
func file_middleware_v1_jwtauth_proto_init() {
	if File_middleware_v1_jwtauth_proto != nil {
		return
	}
	file_middleware_v1_jwtauth_proto_msgTypes[0].OneofWrappers = []any{
		(*JWTAuth_JwksUri)(nil),
		(*JWTAuth_OidcIssuer)(nil),
		(*JWTAuth_PublicKeyPem)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_middleware_v1_jwtauth_proto_rawDesc), len(file_middleware_v1_jwtauth_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_middleware_v1_jwtauth_proto_goTypes,
		DependencyIndexes: file_middleware_v1_jwtauth_proto_depIdxs,
		MessageInfos:      file_middleware_v1_jwtauth_proto_msgTypes,
	}.Build()
	File_middleware_v1_jwtauth_proto = out.File
	file_middleware_v1_jwtauth_proto_goTypes = nil
	file_middleware_v1_jwtauth_proto_depIdxs = nil
}
