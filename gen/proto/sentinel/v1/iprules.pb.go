// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: middleware/v1/iprules.proto

package sentinelv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// IPRules allows or denies requests based on the client's IP address,
// evaluated against CIDR ranges.
//
// IP-based access control is a fundamental security layer, especially for
// APIs that should only be accessible from known networks (corporate VPNs,
// cloud provider IP ranges, partner infrastructure) or that need to block
// traffic from known-bad sources. This is an adoption blocker for customers
// in regulated industries where network-level access control is a compliance
// requirement.
//
// When both allow and deny lists are configured, deny is evaluated first.
// If the client IP matches a deny CIDR, the request is rejected immediately
// regardless of the allow list. If the allow list is non-empty and the
// client IP does not match any allow CIDR, the request is also rejected.
// This "deny-first" approach ensures that explicitly blocked addresses
// cannot bypass the block by also appearing in an allow range.
//
// When sentinel is behind a load balancer or CDN, it uses the
// X-Forwarded-For header to determine the client IP. The rightmost
// untrusted entry in the chain is used to prevent spoofing.
type IPRules struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Allowed CIDR ranges. When non-empty, the policy operates in allowlist
	// mode: only client IPs matching at least one of these CIDRs are
	// permitted. Use /32 for individual IPv4 addresses and /128 for
	// individual IPv6 addresses.
	//
	// Examples: ["10.0.0.0/8", "192.168.1.0/24", "203.0.113.42/32"]
	Allow []string `protobuf:"bytes,1,rep,name=allow,proto3" json:"allow,omitempty"`
	// Denied CIDR ranges. Client IPs matching any of these CIDRs are
	// rejected, even if they also match an allow entry. The deny list is
	// always evaluated before the allow list.
	Deny          []string `protobuf:"bytes,2,rep,name=deny,proto3" json:"deny,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPRules) Reset() {
	*x = IPRules{}
	mi := &file_middleware_v1_iprules_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPRules) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPRules) ProtoMessage() {}

func (x *IPRules) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_iprules_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPRules.ProtoReflect.Descriptor instead.
func (*IPRules) Descriptor() ([]byte, []int) {
	return file_middleware_v1_iprules_proto_rawDescGZIP(), []int{0}
}

func (x *IPRules) GetAllow() []string {
	if x != nil {
		return x.Allow
	}
	return nil
}

func (x *IPRules) GetDeny() []string {
	if x != nil {
		return x.Deny
	}
	return nil
}

var File_middleware_v1_iprules_proto protoreflect.FileDescriptor

const file_middleware_v1_iprules_proto_rawDesc = "" +
	"\n" +
	"\x1bmiddleware/v1/iprules.proto\x12\vsentinel.v1\"3\n" +
	"\aIPRules\x12\x14\n" +
	"\x05allow\x18\x01 \x03(\tR\x05allow\x12\x12\n" +
	"\x04deny\x18\x02 \x03(\tR\x04denyB\xa7\x01\n" +
	"\x0fcom.sentinel.v1B\fIprulesProtoP\x01Z9github.com/unkeyed/unkey/gen/proto/sentinel/v1;sentinelv1\xa2\x02\x03SXX\xaa\x02\vSentinel.V1\xca\x02\vSentinel\\V1\xe2\x02\x17Sentinel\\V1\\GPBMetadata\xea\x02\fSentinel::V1b\x06proto3"

var (
	file_middleware_v1_iprules_proto_rawDescOnce sync.Once
	file_middleware_v1_iprules_proto_rawDescData []byte
)

func file_middleware_v1_iprules_proto_rawDescGZIP() []byte {
	file_middleware_v1_iprules_proto_rawDescOnce.Do(func() {
		file_middleware_v1_iprules_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_middleware_v1_iprules_proto_rawDesc), len(file_middleware_v1_iprules_proto_rawDesc)))
	})
	return file_middleware_v1_iprules_proto_rawDescData
}

var file_middleware_v1_iprules_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_middleware_v1_iprules_proto_goTypes = []any{
	(*IPRules)(nil), // 0: sentinel.v1.IPRules
}
var file_middleware_v1_iprules_proto_depIdxs = []int32{
	0, // [0:0] is the sub-list for method output_type
	0, // [0:0] is the sub-list for method input_type
	0, // [0:0] is the sub-list for extension type_name
	0, // [0:0] is the sub-list for extension extendee
	0, // [0:0] is the sub-list for field type_name
}

func init() { file_middleware_v1_iprules_proto_init() }
func file_middleware_v1_iprules_proto_init() {
	if File_middleware_v1_iprules_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_middleware_v1_iprules_proto_rawDesc), len(file_middleware_v1_iprules_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   1,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_middleware_v1_iprules_proto_goTypes,
		DependencyIndexes: file_middleware_v1_iprules_proto_depIdxs,
		MessageInfos:      file_middleware_v1_iprules_proto_msgTypes,
	}.Build()
	File_middleware_v1_iprules_proto = out.File
	file_middleware_v1_iprules_proto_goTypes = nil
	file_middleware_v1_iprules_proto_depIdxs = nil
}
