// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: middleware/v1/match.proto

package sentinelv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// MatchExpr tests a single property of an incoming HTTP request.
//
// A Policy carries a repeated list of MatchExpr. All entries must match for
// the policy to run (implicit AND). An empty list matches all requests.
//
// If you need OR semantics, create multiple policies with the same config
// and different match lists. This is simpler to reason about than a recursive
// expression tree, and covers the vast majority of real-world routing needs.
// Combinators (And/Or/Not) can be added later as new oneof branches without
// breaking the wire format.
type MatchExpr struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Expr:
	//
	//	*MatchExpr_Path
	//	*MatchExpr_Method
	//	*MatchExpr_Header
	//	*MatchExpr_QueryParam
	Expr          isMatchExpr_Expr `protobuf_oneof:"expr"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MatchExpr) Reset() {
	*x = MatchExpr{}
	mi := &file_middleware_v1_match_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MatchExpr) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MatchExpr) ProtoMessage() {}

func (x *MatchExpr) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_match_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MatchExpr.ProtoReflect.Descriptor instead.
func (*MatchExpr) Descriptor() ([]byte, []int) {
	return file_middleware_v1_match_proto_rawDescGZIP(), []int{0}
}

func (x *MatchExpr) GetExpr() isMatchExpr_Expr {
	if x != nil {
		return x.Expr
	}
	return nil
}

func (x *MatchExpr) GetPath() *PathMatch {
	if x != nil {
		if x, ok := x.Expr.(*MatchExpr_Path); ok {
			return x.Path
		}
	}
	return nil
}

func (x *MatchExpr) GetMethod() *MethodMatch {
	if x != nil {
		if x, ok := x.Expr.(*MatchExpr_Method); ok {
			return x.Method
		}
	}
	return nil
}

func (x *MatchExpr) GetHeader() *HeaderMatch {
	if x != nil {
		if x, ok := x.Expr.(*MatchExpr_Header); ok {
			return x.Header
		}
	}
	return nil
}

func (x *MatchExpr) GetQueryParam() *QueryParamMatch {
	if x != nil {
		if x, ok := x.Expr.(*MatchExpr_QueryParam); ok {
			return x.QueryParam
		}
	}
	return nil
}

type isMatchExpr_Expr interface {
	isMatchExpr_Expr()
}

type MatchExpr_Path struct {
	Path *PathMatch `protobuf:"bytes,1,opt,name=path,proto3,oneof"`
}

type MatchExpr_Method struct {
	Method *MethodMatch `protobuf:"bytes,2,opt,name=method,proto3,oneof"`
}

type MatchExpr_Header struct {
	Header *HeaderMatch `protobuf:"bytes,3,opt,name=header,proto3,oneof"`
}

type MatchExpr_QueryParam struct {
	QueryParam *QueryParamMatch `protobuf:"bytes,4,opt,name=query_param,json=queryParam,proto3,oneof"`
}

func (*MatchExpr_Path) isMatchExpr_Expr() {}

func (*MatchExpr_Method) isMatchExpr_Expr() {}

func (*MatchExpr_Header) isMatchExpr_Expr() {}

func (*MatchExpr_QueryParam) isMatchExpr_Expr() {}

// StringMatch is the shared string matching primitive used by all leaf
// matchers that compare against string values (paths, header values, query
// parameter values). Centralizing matching logic in one message ensures
// consistent behavior across all matchers and avoids duplicating regex
// validation, case folding, and prefix logic.
//
// Exactly one of exact, prefix, or regex must be set. When ignore_case is
// true, comparison is performed after Unicode case folding for exact and
// prefix matches. For regex matches, ignore_case prepends (?i) to the
// pattern.
type StringMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// When true, matching is case-insensitive. Applied to all match modes.
	IgnoreCase bool `protobuf:"varint,1,opt,name=ignore_case,json=ignoreCase,proto3" json:"ignore_case,omitempty"`
	// Types that are valid to be assigned to Match:
	//
	//	*StringMatch_Exact
	//	*StringMatch_Prefix
	//	*StringMatch_Regex
	Match         isStringMatch_Match `protobuf_oneof:"match"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StringMatch) Reset() {
	*x = StringMatch{}
	mi := &file_middleware_v1_match_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StringMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StringMatch) ProtoMessage() {}

func (x *StringMatch) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_match_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StringMatch.ProtoReflect.Descriptor instead.
func (*StringMatch) Descriptor() ([]byte, []int) {
	return file_middleware_v1_match_proto_rawDescGZIP(), []int{1}
}

func (x *StringMatch) GetIgnoreCase() bool {
	if x != nil {
		return x.IgnoreCase
	}
	return false
}

func (x *StringMatch) GetMatch() isStringMatch_Match {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *StringMatch) GetExact() string {
	if x != nil {
		if x, ok := x.Match.(*StringMatch_Exact); ok {
			return x.Exact
		}
	}
	return ""
}

func (x *StringMatch) GetPrefix() string {
	if x != nil {
		if x, ok := x.Match.(*StringMatch_Prefix); ok {
			return x.Prefix
		}
	}
	return ""
}

func (x *StringMatch) GetRegex() string {
	if x != nil {
		if x, ok := x.Match.(*StringMatch_Regex); ok {
			return x.Regex
		}
	}
	return ""
}

type isStringMatch_Match interface {
	isStringMatch_Match()
}

type StringMatch_Exact struct {
	// The string must equal this value exactly (after optional case folding).
	Exact string `protobuf:"bytes,2,opt,name=exact,proto3,oneof"`
}

type StringMatch_Prefix struct {
	// The string must start with this prefix (after optional case folding).
	Prefix string `protobuf:"bytes,3,opt,name=prefix,proto3,oneof"`
}

type StringMatch_Regex struct {
	// The string must match this RE2-compatible regular expression. RE2 is
	// required (not PCRE) because Go's regexp package uses RE2, which
	// guarantees linear-time matching and is safe for user-provided patterns.
	// See https://github.com/google/re2/wiki/Syntax for the full syntax.
	Regex string `protobuf:"bytes,4,opt,name=regex,proto3,oneof"`
}

func (*StringMatch_Exact) isStringMatch_Match() {}

func (*StringMatch_Prefix) isStringMatch_Match() {}

func (*StringMatch_Regex) isStringMatch_Match() {}

// PathMatch tests the URL path of the incoming request. The path is compared
// without the query string — use [QueryParamMatch] to match query parameters
// separately. Leading slashes are preserved, so patterns should include them
// (e.g., prefix "/api/v1" not "api/v1").
type PathMatch struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          *StringMatch           `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PathMatch) Reset() {
	*x = PathMatch{}
	mi := &file_middleware_v1_match_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PathMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PathMatch) ProtoMessage() {}

func (x *PathMatch) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_match_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PathMatch.ProtoReflect.Descriptor instead.
func (*PathMatch) Descriptor() ([]byte, []int) {
	return file_middleware_v1_match_proto_rawDescGZIP(), []int{2}
}

func (x *PathMatch) GetPath() *StringMatch {
	if x != nil {
		return x.Path
	}
	return nil
}

// MethodMatch tests the HTTP method of the incoming request. Comparison is
// always case-insensitive per the HTTP specification, regardless of the
// StringMatch ignore_case setting. The methods list is an OR — the request
// matches if its method equals any entry.
type MethodMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// HTTP methods to match against, e.g. ["GET", "POST"]. The match succeeds
	// if the request method equals any of these values (case-insensitive).
	Methods       []string `protobuf:"bytes,1,rep,name=methods,proto3" json:"methods,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MethodMatch) Reset() {
	*x = MethodMatch{}
	mi := &file_middleware_v1_match_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MethodMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MethodMatch) ProtoMessage() {}

func (x *MethodMatch) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_match_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MethodMatch.ProtoReflect.Descriptor instead.
func (*MethodMatch) Descriptor() ([]byte, []int) {
	return file_middleware_v1_match_proto_rawDescGZIP(), []int{3}
}

func (x *MethodMatch) GetMethods() []string {
	if x != nil {
		return x.Methods
	}
	return nil
}

// HeaderMatch tests a request header by name and optionally by value. Header
// names are always matched case-insensitively per HTTP semantics (RFC 7230).
//
// When the request contains multiple values for the same header name (either
// via repeated headers or comma-separated values), the match succeeds if any
// single value satisfies the condition. This follows the principle of least
// surprise for operators who may not know whether their clients send headers
// as separate entries or comma-delimited lists.
type HeaderMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The header name to match, e.g. "X-API-Version" or "Content-Type".
	// Matched case-insensitively.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to Match:
	//
	//	*HeaderMatch_Present
	//	*HeaderMatch_Value
	Match         isHeaderMatch_Match `protobuf_oneof:"match"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeaderMatch) Reset() {
	*x = HeaderMatch{}
	mi := &file_middleware_v1_match_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeaderMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeaderMatch) ProtoMessage() {}

func (x *HeaderMatch) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_match_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeaderMatch.ProtoReflect.Descriptor instead.
func (*HeaderMatch) Descriptor() ([]byte, []int) {
	return file_middleware_v1_match_proto_rawDescGZIP(), []int{4}
}

func (x *HeaderMatch) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *HeaderMatch) GetMatch() isHeaderMatch_Match {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *HeaderMatch) GetPresent() bool {
	if x != nil {
		if x, ok := x.Match.(*HeaderMatch_Present); ok {
			return x.Present
		}
	}
	return false
}

func (x *HeaderMatch) GetValue() *StringMatch {
	if x != nil {
		if x, ok := x.Match.(*HeaderMatch_Value); ok {
			return x.Value
		}
	}
	return nil
}

type isHeaderMatch_Match interface {
	isHeaderMatch_Match()
}

type HeaderMatch_Present struct {
	// When set to true, the match succeeds if the header is present in the
	// request, regardless of its value. Useful for policies that should only
	// apply to requests carrying a specific header (e.g., match requests
	// with an Authorization header to apply auth policies).
	Present bool `protobuf:"varint,2,opt,name=present,proto3,oneof"`
}

type HeaderMatch_Value struct {
	// Match against the header value(s) using a [StringMatch]. If the header
	// has multiple values, the match succeeds if any value satisfies the
	// StringMatch condition.
	Value *StringMatch `protobuf:"bytes,3,opt,name=value,proto3,oneof"`
}

func (*HeaderMatch_Present) isHeaderMatch_Match() {}

func (*HeaderMatch_Value) isHeaderMatch_Match() {}

// QueryParamMatch tests a URL query parameter by name and optionally by
// value. Query parameter names are matched case-sensitively (per the URI
// specification), unlike header names.
//
// When the same parameter appears multiple times in the query string (e.g.,
// ?tag=a&tag=b), the match succeeds if any occurrence satisfies the
// condition.
type QueryParamMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The query parameter name to match, e.g. "version" or "debug".
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to Match:
	//
	//	*QueryParamMatch_Present
	//	*QueryParamMatch_Value
	Match         isQueryParamMatch_Match `protobuf_oneof:"match"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryParamMatch) Reset() {
	*x = QueryParamMatch{}
	mi := &file_middleware_v1_match_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryParamMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryParamMatch) ProtoMessage() {}

func (x *QueryParamMatch) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_match_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryParamMatch.ProtoReflect.Descriptor instead.
func (*QueryParamMatch) Descriptor() ([]byte, []int) {
	return file_middleware_v1_match_proto_rawDescGZIP(), []int{5}
}

func (x *QueryParamMatch) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *QueryParamMatch) GetMatch() isQueryParamMatch_Match {
	if x != nil {
		return x.Match
	}
	return nil
}

func (x *QueryParamMatch) GetPresent() bool {
	if x != nil {
		if x, ok := x.Match.(*QueryParamMatch_Present); ok {
			return x.Present
		}
	}
	return false
}

func (x *QueryParamMatch) GetValue() *StringMatch {
	if x != nil {
		if x, ok := x.Match.(*QueryParamMatch_Value); ok {
			return x.Value
		}
	}
	return nil
}

type isQueryParamMatch_Match interface {
	isQueryParamMatch_Match()
}

type QueryParamMatch_Present struct {
	// When set to true, the match succeeds if the query parameter is present,
	// regardless of its value. Useful for feature-flag-style routing (e.g.,
	// match requests with ?debug to apply verbose access logging).
	Present bool `protobuf:"varint,2,opt,name=present,proto3,oneof"`
}

type QueryParamMatch_Value struct {
	// Match against the parameter value(s) using a [StringMatch].
	Value *StringMatch `protobuf:"bytes,3,opt,name=value,proto3,oneof"`
}

func (*QueryParamMatch_Present) isQueryParamMatch_Match() {}

func (*QueryParamMatch_Value) isQueryParamMatch_Match() {}

var File_middleware_v1_match_proto protoreflect.FileDescriptor

const file_middleware_v1_match_proto_rawDesc = "" +
	"\n" +
	"\x19middleware/v1/match.proto\x12\vsentinel.v1\"\xea\x01\n" +
	"\tMatchExpr\x12,\n" +
	"\x04path\x18\x01 \x01(\v2\x16.sentinel.v1.PathMatchH\x00R\x04path\x122\n" +
	"\x06method\x18\x02 \x01(\v2\x18.sentinel.v1.MethodMatchH\x00R\x06method\x122\n" +
	"\x06header\x18\x03 \x01(\v2\x18.sentinel.v1.HeaderMatchH\x00R\x06header\x12?\n" +
	"\vquery_param\x18\x04 \x01(\v2\x1c.sentinel.v1.QueryParamMatchH\x00R\n" +
	"queryParamB\x06\n" +
	"\x04expr\"\x81\x01\n" +
	"\vStringMatch\x12\x1f\n" +
	"\vignore_case\x18\x01 \x01(\bR\n" +
	"ignoreCase\x12\x16\n" +
	"\x05exact\x18\x02 \x01(\tH\x00R\x05exact\x12\x18\n" +
	"\x06prefix\x18\x03 \x01(\tH\x00R\x06prefix\x12\x16\n" +
	"\x05regex\x18\x04 \x01(\tH\x00R\x05regexB\a\n" +
	"\x05match\"9\n" +
	"\tPathMatch\x12,\n" +
	"\x04path\x18\x01 \x01(\v2\x18.sentinel.v1.StringMatchR\x04path\"'\n" +
	"\vMethodMatch\x12\x18\n" +
	"\amethods\x18\x01 \x03(\tR\amethods\"x\n" +
	"\vHeaderMatch\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1a\n" +
	"\apresent\x18\x02 \x01(\bH\x00R\apresent\x120\n" +
	"\x05value\x18\x03 \x01(\v2\x18.sentinel.v1.StringMatchH\x00R\x05valueB\a\n" +
	"\x05match\"|\n" +
	"\x0fQueryParamMatch\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1a\n" +
	"\apresent\x18\x02 \x01(\bH\x00R\apresent\x120\n" +
	"\x05value\x18\x03 \x01(\v2\x18.sentinel.v1.StringMatchH\x00R\x05valueB\a\n" +
	"\x05matchB\xa5\x01\n" +
	"\x0fcom.sentinel.v1B\n" +
	"MatchProtoP\x01Z9github.com/unkeyed/unkey/gen/proto/sentinel/v1;sentinelv1\xa2\x02\x03SXX\xaa\x02\vSentinel.V1\xca\x02\vSentinel\\V1\xe2\x02\x17Sentinel\\V1\\GPBMetadata\xea\x02\fSentinel::V1b\x06proto3"

var (
	file_middleware_v1_match_proto_rawDescOnce sync.Once
	file_middleware_v1_match_proto_rawDescData []byte
)

func file_middleware_v1_match_proto_rawDescGZIP() []byte {
	file_middleware_v1_match_proto_rawDescOnce.Do(func() {
		file_middleware_v1_match_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_middleware_v1_match_proto_rawDesc), len(file_middleware_v1_match_proto_rawDesc)))
	})
	return file_middleware_v1_match_proto_rawDescData
}

var file_middleware_v1_match_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_middleware_v1_match_proto_goTypes = []any{
	(*MatchExpr)(nil),       // 0: sentinel.v1.MatchExpr
	(*StringMatch)(nil),     // 1: sentinel.v1.StringMatch
	(*PathMatch)(nil),       // 2: sentinel.v1.PathMatch
	(*MethodMatch)(nil),     // 3: sentinel.v1.MethodMatch
	(*HeaderMatch)(nil),     // 4: sentinel.v1.HeaderMatch
	(*QueryParamMatch)(nil), // 5: sentinel.v1.QueryParamMatch
}
var file_middleware_v1_match_proto_depIdxs = []int32{
	2, // 0: sentinel.v1.MatchExpr.path:type_name -> sentinel.v1.PathMatch
	3, // 1: sentinel.v1.MatchExpr.method:type_name -> sentinel.v1.MethodMatch
	4, // 2: sentinel.v1.MatchExpr.header:type_name -> sentinel.v1.HeaderMatch
	5, // 3: sentinel.v1.MatchExpr.query_param:type_name -> sentinel.v1.QueryParamMatch
	1, // 4: sentinel.v1.PathMatch.path:type_name -> sentinel.v1.StringMatch
	1, // 5: sentinel.v1.HeaderMatch.value:type_name -> sentinel.v1.StringMatch
	1, // 6: sentinel.v1.QueryParamMatch.value:type_name -> sentinel.v1.StringMatch
	7, // [7:7] is the sub-list for method output_type
	7, // [7:7] is the sub-list for method input_type
	7, // [7:7] is the sub-list for extension type_name
	7, // [7:7] is the sub-list for extension extendee
	0, // [0:7] is the sub-list for field type_name
}

func init() { file_middleware_v1_match_proto_init() }
func file_middleware_v1_match_proto_init() {
	if File_middleware_v1_match_proto != nil {
		return
	}
	file_middleware_v1_match_proto_msgTypes[0].OneofWrappers = []any{
		(*MatchExpr_Path)(nil),
		(*MatchExpr_Method)(nil),
		(*MatchExpr_Header)(nil),
		(*MatchExpr_QueryParam)(nil),
	}
	file_middleware_v1_match_proto_msgTypes[1].OneofWrappers = []any{
		(*StringMatch_Exact)(nil),
		(*StringMatch_Prefix)(nil),
		(*StringMatch_Regex)(nil),
	}
	file_middleware_v1_match_proto_msgTypes[4].OneofWrappers = []any{
		(*HeaderMatch_Present)(nil),
		(*HeaderMatch_Value)(nil),
	}
	file_middleware_v1_match_proto_msgTypes[5].OneofWrappers = []any{
		(*QueryParamMatch_Present)(nil),
		(*QueryParamMatch_Value)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_middleware_v1_match_proto_rawDesc), len(file_middleware_v1_match_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_middleware_v1_match_proto_goTypes,
		DependencyIndexes: file_middleware_v1_match_proto_depIdxs,
		MessageInfos:      file_middleware_v1_match_proto_msgTypes,
	}.Build()
	File_middleware_v1_match_proto = out.File
	file_middleware_v1_match_proto_goTypes = nil
	file_middleware_v1_match_proto_depIdxs = nil
}
