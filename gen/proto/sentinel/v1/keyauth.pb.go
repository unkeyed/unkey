// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        (unknown)
// source: middleware/v1/keyauth.proto

package sentinelv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// KeyAuth authenticates requests using Unkey API keys. This is the primary
// authentication mechanism for sentinel because API key management is Unkey's
// core product. When a request arrives, sentinel extracts the key from the
// configured location, verifies it against the specified Unkey key space, and
// on success produces a [Principal] with type PRINCIPAL_TYPE_API_KEY.
//
// The verification call to Unkey returns rich metadata about the key: its
// owner identity, associated permissions, remaining quota, rate limit state,
// and custom metadata. This information flows into the [Principal] and is
// available to downstream policies. For example, a RateLimit policy can
// throttle by the key's owner rather than by IP, and the permission_query
// field lets you enforce Unkey RBAC permissions at the gateway without a
// separate policy.
//
// KeyAuth pairs naturally with Unkey's key lifecycle features. Keys created
// with expiration dates, remaining usage counts, or rate limits are enforced
// at the gateway level without any application code. This turns sentinel
// into a full API management layer for Unkey customers.
type KeyAuth struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Unkey key space (API) ID to authenticate against. Each key space
	// contains a set of API keys with shared configuration. This determines
	// which keys are valid for this policy.
	KeySpaceId string `protobuf:"bytes,1,opt,name=key_space_id,json=keySpaceId,proto3" json:"key_space_id,omitempty"`
	// Ordered list of locations to extract the API key from. Sentinel tries
	// each location in order and uses the first one that yields a non-empty
	// value. This allows APIs to support multiple key delivery mechanisms
	// simultaneously (e.g., Bearer token for programmatic clients and a query
	// parameter for browser-based debugging).
	//
	// If empty, defaults to extracting from the Authorization header as a
	// Bearer token, which is the most common convention for API authentication.
	Locations []*KeyLocation `protobuf:"bytes,2,rep,name=locations,proto3" json:"locations,omitempty"`
	// When true, requests that do not contain a key in any of the configured
	// locations are allowed through without authentication. No [Principal] is
	// produced for anonymous requests. This enables mixed-auth endpoints where
	// unauthenticated users get a restricted view and authenticated users get
	// full access â€” the application checks for the presence of identity headers
	// to decide.
	AllowAnonymous bool `protobuf:"varint,3,opt,name=allow_anonymous,json=allowAnonymous,proto3" json:"allow_anonymous,omitempty"`
	// Optional permission query evaluated against the key's permissions
	// returned by Unkey's verify API. Uses the same query language as
	// pkg/rbac.ParseQuery: AND and OR operators with parenthesized grouping,
	// where AND has higher precedence than OR.
	//
	// Permission names may contain alphanumeric characters, dots, underscores,
	// hyphens, colons, asterisks, and forward slashes. Asterisks are literal
	// characters, not wildcards.
	//
	// Examples:
	//
	//	"api.keys.create"
	//	"api.keys.read AND api.keys.update"
	//	"billing.read OR billing.admin"
	//	"(api.keys.read OR api.keys.list) AND billing.read"
	//
	// When set, sentinel rejects the request with 403 if the key lacks the
	// required permissions. When empty, no permission check is performed.
	//
	// Limits: maximum 1000 characters, maximum 100 permission terms.
	PermissionQuery string `protobuf:"bytes,5,opt,name=permission_query,json=permissionQuery,proto3" json:"permission_query,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *KeyAuth) Reset() {
	*x = KeyAuth{}
	mi := &file_middleware_v1_keyauth_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyAuth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyAuth) ProtoMessage() {}

func (x *KeyAuth) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_keyauth_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyAuth.ProtoReflect.Descriptor instead.
func (*KeyAuth) Descriptor() ([]byte, []int) {
	return file_middleware_v1_keyauth_proto_rawDescGZIP(), []int{0}
}

func (x *KeyAuth) GetKeySpaceId() string {
	if x != nil {
		return x.KeySpaceId
	}
	return ""
}

func (x *KeyAuth) GetLocations() []*KeyLocation {
	if x != nil {
		return x.Locations
	}
	return nil
}

func (x *KeyAuth) GetAllowAnonymous() bool {
	if x != nil {
		return x.AllowAnonymous
	}
	return false
}

func (x *KeyAuth) GetPermissionQuery() string {
	if x != nil {
		return x.PermissionQuery
	}
	return ""
}

// KeyLocation specifies where in the HTTP request to look for an API key.
// Multiple locations can be configured on a [KeyAuth] policy to support
// different client conventions. Sentinel tries each location in order and
// uses the first one that yields a non-empty value.
type KeyLocation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Location:
	//
	//	*KeyLocation_Bearer
	//	*KeyLocation_Header
	//	*KeyLocation_QueryParam
	Location      isKeyLocation_Location `protobuf_oneof:"location"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyLocation) Reset() {
	*x = KeyLocation{}
	mi := &file_middleware_v1_keyauth_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyLocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyLocation) ProtoMessage() {}

func (x *KeyLocation) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_keyauth_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyLocation.ProtoReflect.Descriptor instead.
func (*KeyLocation) Descriptor() ([]byte, []int) {
	return file_middleware_v1_keyauth_proto_rawDescGZIP(), []int{1}
}

func (x *KeyLocation) GetLocation() isKeyLocation_Location {
	if x != nil {
		return x.Location
	}
	return nil
}

func (x *KeyLocation) GetBearer() *BearerTokenLocation {
	if x != nil {
		if x, ok := x.Location.(*KeyLocation_Bearer); ok {
			return x.Bearer
		}
	}
	return nil
}

func (x *KeyLocation) GetHeader() *HeaderKeyLocation {
	if x != nil {
		if x, ok := x.Location.(*KeyLocation_Header); ok {
			return x.Header
		}
	}
	return nil
}

func (x *KeyLocation) GetQueryParam() *QueryParamKeyLocation {
	if x != nil {
		if x, ok := x.Location.(*KeyLocation_QueryParam); ok {
			return x.QueryParam
		}
	}
	return nil
}

type isKeyLocation_Location interface {
	isKeyLocation_Location()
}

type KeyLocation_Bearer struct {
	// Extract from the standard Authorization: Bearer <token> header. This
	// is the most common API key delivery mechanism and the default when no
	// locations are configured.
	Bearer *BearerTokenLocation `protobuf:"bytes,1,opt,name=bearer,proto3,oneof"`
}

type KeyLocation_Header struct {
	// Extract from a custom request header. Useful for APIs that use
	// non-standard headers like X-API-Key or X-Auth-Token.
	Header *HeaderKeyLocation `protobuf:"bytes,2,opt,name=header,proto3,oneof"`
}

type KeyLocation_QueryParam struct {
	// Extract from a URL query parameter. Useful for webhook callbacks or
	// situations where headers cannot be set, but less secure since query
	// parameters appear in server logs and browser history.
	QueryParam *QueryParamKeyLocation `protobuf:"bytes,3,opt,name=query_param,json=queryParam,proto3,oneof"`
}

func (*KeyLocation_Bearer) isKeyLocation_Location() {}

func (*KeyLocation_Header) isKeyLocation_Location() {}

func (*KeyLocation_QueryParam) isKeyLocation_Location() {}

// BearerTokenLocation extracts the API key from the Authorization header
// using the Bearer scheme (RFC 6750). Sentinel parses the header value,
// strips the "Bearer " prefix, and uses the remainder as the API key.
type BearerTokenLocation struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BearerTokenLocation) Reset() {
	*x = BearerTokenLocation{}
	mi := &file_middleware_v1_keyauth_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BearerTokenLocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BearerTokenLocation) ProtoMessage() {}

func (x *BearerTokenLocation) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_keyauth_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BearerTokenLocation.ProtoReflect.Descriptor instead.
func (*BearerTokenLocation) Descriptor() ([]byte, []int) {
	return file_middleware_v1_keyauth_proto_rawDescGZIP(), []int{2}
}

// HeaderKeyLocation extracts the API key from a named request header. This
// supports APIs that use custom authentication headers instead of the
// standard Authorization header.
type HeaderKeyLocation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The header name to read, e.g. "X-API-Key". Matched case-insensitively
	// per HTTP semantics.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// If set, this prefix is stripped from the header value before the
	// remainder is used as the API key. For example, with name "Authorization"
	// and strip_prefix "ApiKey ", a header value "ApiKey sk_live_abc123"
	// yields key "sk_live_abc123".
	StripPrefix   string `protobuf:"bytes,2,opt,name=strip_prefix,json=stripPrefix,proto3" json:"strip_prefix,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeaderKeyLocation) Reset() {
	*x = HeaderKeyLocation{}
	mi := &file_middleware_v1_keyauth_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeaderKeyLocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeaderKeyLocation) ProtoMessage() {}

func (x *HeaderKeyLocation) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_keyauth_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeaderKeyLocation.ProtoReflect.Descriptor instead.
func (*HeaderKeyLocation) Descriptor() ([]byte, []int) {
	return file_middleware_v1_keyauth_proto_rawDescGZIP(), []int{3}
}

func (x *HeaderKeyLocation) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *HeaderKeyLocation) GetStripPrefix() string {
	if x != nil {
		return x.StripPrefix
	}
	return ""
}

// QueryParamKeyLocation extracts the API key from a URL query parameter.
type QueryParamKeyLocation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The query parameter name, e.g. "api_key" or "token".
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryParamKeyLocation) Reset() {
	*x = QueryParamKeyLocation{}
	mi := &file_middleware_v1_keyauth_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryParamKeyLocation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryParamKeyLocation) ProtoMessage() {}

func (x *QueryParamKeyLocation) ProtoReflect() protoreflect.Message {
	mi := &file_middleware_v1_keyauth_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryParamKeyLocation.ProtoReflect.Descriptor instead.
func (*QueryParamKeyLocation) Descriptor() ([]byte, []int) {
	return file_middleware_v1_keyauth_proto_rawDescGZIP(), []int{4}
}

func (x *QueryParamKeyLocation) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

var File_middleware_v1_keyauth_proto protoreflect.FileDescriptor

const file_middleware_v1_keyauth_proto_rawDesc = "" +
	"\n" +
	"\x1bmiddleware/v1/keyauth.proto\x12\vsentinel.v1\"\xb7\x01\n" +
	"\aKeyAuth\x12 \n" +
	"\fkey_space_id\x18\x01 \x01(\tR\n" +
	"keySpaceId\x126\n" +
	"\tlocations\x18\x02 \x03(\v2\x18.sentinel.v1.KeyLocationR\tlocations\x12'\n" +
	"\x0fallow_anonymous\x18\x03 \x01(\bR\x0eallowAnonymous\x12)\n" +
	"\x10permission_query\x18\x05 \x01(\tR\x0fpermissionQuery\"\xd6\x01\n" +
	"\vKeyLocation\x12:\n" +
	"\x06bearer\x18\x01 \x01(\v2 .sentinel.v1.BearerTokenLocationH\x00R\x06bearer\x128\n" +
	"\x06header\x18\x02 \x01(\v2\x1e.sentinel.v1.HeaderKeyLocationH\x00R\x06header\x12E\n" +
	"\vquery_param\x18\x03 \x01(\v2\".sentinel.v1.QueryParamKeyLocationH\x00R\n" +
	"queryParamB\n" +
	"\n" +
	"\blocation\"\x15\n" +
	"\x13BearerTokenLocation\"J\n" +
	"\x11HeaderKeyLocation\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12!\n" +
	"\fstrip_prefix\x18\x02 \x01(\tR\vstripPrefix\"+\n" +
	"\x15QueryParamKeyLocation\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04nameB\xa7\x01\n" +
	"\x0fcom.sentinel.v1B\fKeyauthProtoP\x01Z9github.com/unkeyed/unkey/gen/proto/sentinel/v1;sentinelv1\xa2\x02\x03SXX\xaa\x02\vSentinel.V1\xca\x02\vSentinel\\V1\xe2\x02\x17Sentinel\\V1\\GPBMetadata\xea\x02\fSentinel::V1b\x06proto3"

var (
	file_middleware_v1_keyauth_proto_rawDescOnce sync.Once
	file_middleware_v1_keyauth_proto_rawDescData []byte
)

func file_middleware_v1_keyauth_proto_rawDescGZIP() []byte {
	file_middleware_v1_keyauth_proto_rawDescOnce.Do(func() {
		file_middleware_v1_keyauth_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_middleware_v1_keyauth_proto_rawDesc), len(file_middleware_v1_keyauth_proto_rawDesc)))
	})
	return file_middleware_v1_keyauth_proto_rawDescData
}

var file_middleware_v1_keyauth_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_middleware_v1_keyauth_proto_goTypes = []any{
	(*KeyAuth)(nil),               // 0: sentinel.v1.KeyAuth
	(*KeyLocation)(nil),           // 1: sentinel.v1.KeyLocation
	(*BearerTokenLocation)(nil),   // 2: sentinel.v1.BearerTokenLocation
	(*HeaderKeyLocation)(nil),     // 3: sentinel.v1.HeaderKeyLocation
	(*QueryParamKeyLocation)(nil), // 4: sentinel.v1.QueryParamKeyLocation
}
var file_middleware_v1_keyauth_proto_depIdxs = []int32{
	1, // 0: sentinel.v1.KeyAuth.locations:type_name -> sentinel.v1.KeyLocation
	2, // 1: sentinel.v1.KeyLocation.bearer:type_name -> sentinel.v1.BearerTokenLocation
	3, // 2: sentinel.v1.KeyLocation.header:type_name -> sentinel.v1.HeaderKeyLocation
	4, // 3: sentinel.v1.KeyLocation.query_param:type_name -> sentinel.v1.QueryParamKeyLocation
	4, // [4:4] is the sub-list for method output_type
	4, // [4:4] is the sub-list for method input_type
	4, // [4:4] is the sub-list for extension type_name
	4, // [4:4] is the sub-list for extension extendee
	0, // [0:4] is the sub-list for field type_name
}

func init() { file_middleware_v1_keyauth_proto_init() }
func file_middleware_v1_keyauth_proto_init() {
	if File_middleware_v1_keyauth_proto != nil {
		return
	}
	file_middleware_v1_keyauth_proto_msgTypes[1].OneofWrappers = []any{
		(*KeyLocation_Bearer)(nil),
		(*KeyLocation_Header)(nil),
		(*KeyLocation_QueryParam)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_middleware_v1_keyauth_proto_rawDesc), len(file_middleware_v1_keyauth_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   5,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_middleware_v1_keyauth_proto_goTypes,
		DependencyIndexes: file_middleware_v1_keyauth_proto_depIdxs,
		MessageInfos:      file_middleware_v1_keyauth_proto_msgTypes,
	}.Build()
	File_middleware_v1_keyauth_proto = out.File
	file_middleware_v1_keyauth_proto_goTypes = nil
	file_middleware_v1_keyauth_proto_depIdxs = nil
}
