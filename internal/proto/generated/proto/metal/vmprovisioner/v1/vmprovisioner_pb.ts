// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file proto/metal/vmprovisioner/v1/vmprovisioner.proto (package metal.vmprovisioner.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * VM lifecycle states
 *
 * @generated from enum metal.vmprovisioner.v1.VmState
 */
export enum VmState {
  /**
   * @generated from enum value: VM_STATE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: VM_STATE_CREATED = 1;
   */
  CREATED = 1,

  /**
   * @generated from enum value: VM_STATE_RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * @generated from enum value: VM_STATE_PAUSED = 3;
   */
  PAUSED = 3,

  /**
   * @generated from enum value: VM_STATE_SHUTDOWN = 4;
   */
  SHUTDOWN = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(VmState)
proto3.util.setEnumType(VmState, "metal.vmprovisioner.v1.VmState", [
  { no: 0, name: "VM_STATE_UNSPECIFIED" },
  { no: 1, name: "VM_STATE_CREATED" },
  { no: 2, name: "VM_STATE_RUNNING" },
  { no: 3, name: "VM_STATE_PAUSED" },
  { no: 4, name: "VM_STATE_SHUTDOWN" },
]);

/**
 * Network mode for the interface
 *
 * @generated from enum metal.vmprovisioner.v1.NetworkMode
 */
export enum NetworkMode {
  /**
   * @generated from enum value: NETWORK_MODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Both IPv4 and IPv6
   *
   * @generated from enum value: NETWORK_MODE_DUAL_STACK = 1;
   */
  DUAL_STACK = 1,

  /**
   * IPv4 only
   *
   * @generated from enum value: NETWORK_MODE_IPV4_ONLY = 2;
   */
  IPV4_ONLY = 2,

  /**
   * IPv6 only
   *
   * @generated from enum value: NETWORK_MODE_IPV6_ONLY = 3;
   */
  IPV6_ONLY = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(NetworkMode)
proto3.util.setEnumType(NetworkMode, "metal.vmprovisioner.v1.NetworkMode", [
  { no: 0, name: "NETWORK_MODE_UNSPECIFIED" },
  { no: 1, name: "NETWORK_MODE_DUAL_STACK" },
  { no: 2, name: "NETWORK_MODE_IPV4_ONLY" },
  { no: 3, name: "NETWORK_MODE_IPV6_ONLY" },
]);

/**
 * Unified VM configuration that works across different hypervisors
 *
 * @generated from message metal.vmprovisioner.v1.VmConfig
 */
export class VmConfig extends Message<VmConfig> {
  /**
   * CPU configuration
   *
   * @generated from field: metal.vmprovisioner.v1.CpuConfig cpu = 1;
   */
  cpu?: CpuConfig;

  /**
   * Memory configuration
   *
   * @generated from field: metal.vmprovisioner.v1.MemoryConfig memory = 2;
   */
  memory?: MemoryConfig;

  /**
   * Boot configuration
   *
   * @generated from field: metal.vmprovisioner.v1.BootConfig boot = 3;
   */
  boot?: BootConfig;

  /**
   * Storage devices
   *
   * @generated from field: repeated metal.vmprovisioner.v1.StorageDevice storage = 4;
   */
  storage: StorageDevice[] = [];

  /**
   * Network interfaces
   *
   * @generated from field: repeated metal.vmprovisioner.v1.NetworkInterface network = 5;
   */
  network: NetworkInterface[] = [];

  /**
   * Console configuration
   *
   * @generated from field: metal.vmprovisioner.v1.ConsoleConfig console = 6;
   */
  console?: ConsoleConfig;

  /**
   * Metadata and labels
   *
   * @generated from field: map<string, string> metadata = 7;
   */
  metadata: { [key: string]: string } = {};

  constructor(data?: PartialMessage<VmConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.VmConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cpu", kind: "message", T: CpuConfig },
    { no: 2, name: "memory", kind: "message", T: MemoryConfig },
    { no: 3, name: "boot", kind: "message", T: BootConfig },
    { no: 4, name: "storage", kind: "message", T: StorageDevice, repeated: true },
    { no: 5, name: "network", kind: "message", T: NetworkInterface, repeated: true },
    { no: 6, name: "console", kind: "message", T: ConsoleConfig },
    {
      no: 7,
      name: "metadata",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VmConfig {
    return new VmConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VmConfig {
    return new VmConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VmConfig {
    return new VmConfig().fromJsonString(jsonString, options);
  }

  static equals(
    a: VmConfig | PlainMessage<VmConfig> | undefined,
    b: VmConfig | PlainMessage<VmConfig> | undefined,
  ): boolean {
    return proto3.util.equals(VmConfig, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.CpuConfig
 */
export class CpuConfig extends Message<CpuConfig> {
  /**
   * Number of virtual CPUs to allocate at boot
   *
   * @generated from field: int32 vcpu_count = 1;
   */
  vcpuCount = 0;

  /**
   * Maximum number of virtual CPUs (for hotplug)
   *
   * @generated from field: int32 max_vcpu_count = 2;
   */
  maxVcpuCount = 0;

  /**
   * CPU topology (optional)
   *
   * @generated from field: metal.vmprovisioner.v1.CpuTopology topology = 3;
   */
  topology?: CpuTopology;

  /**
   * CPU features and model (backend-specific)
   *
   * @generated from field: map<string, string> features = 4;
   */
  features: { [key: string]: string } = {};

  constructor(data?: PartialMessage<CpuConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.CpuConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vcpu_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "max_vcpu_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "topology", kind: "message", T: CpuTopology },
    {
      no: 4,
      name: "features",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CpuConfig {
    return new CpuConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CpuConfig {
    return new CpuConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CpuConfig {
    return new CpuConfig().fromJsonString(jsonString, options);
  }

  static equals(
    a: CpuConfig | PlainMessage<CpuConfig> | undefined,
    b: CpuConfig | PlainMessage<CpuConfig> | undefined,
  ): boolean {
    return proto3.util.equals(CpuConfig, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.CpuTopology
 */
export class CpuTopology extends Message<CpuTopology> {
  /**
   * @generated from field: int32 sockets = 1;
   */
  sockets = 0;

  /**
   * @generated from field: int32 cores_per_socket = 2;
   */
  coresPerSocket = 0;

  /**
   * @generated from field: int32 threads_per_core = 3;
   */
  threadsPerCore = 0;

  constructor(data?: PartialMessage<CpuTopology>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.CpuTopology";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sockets", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "cores_per_socket", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "threads_per_core", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CpuTopology {
    return new CpuTopology().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CpuTopology {
    return new CpuTopology().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CpuTopology {
    return new CpuTopology().fromJsonString(jsonString, options);
  }

  static equals(
    a: CpuTopology | PlainMessage<CpuTopology> | undefined,
    b: CpuTopology | PlainMessage<CpuTopology> | undefined,
  ): boolean {
    return proto3.util.equals(CpuTopology, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.MemoryConfig
 */
export class MemoryConfig extends Message<MemoryConfig> {
  /**
   * Memory size in bytes
   *
   * @generated from field: int64 size_bytes = 1;
   */
  sizeBytes = protoInt64.zero;

  /**
   * Whether memory hotplug is enabled
   *
   * @generated from field: bool hotplug_enabled = 2;
   */
  hotplugEnabled = false;

  /**
   * Maximum memory size for hotplug (bytes)
   *
   * @generated from field: int64 max_size_bytes = 3;
   */
  maxSizeBytes = protoInt64.zero;

  /**
   * Memory backing options (hugepages, etc.)
   *
   * @generated from field: map<string, string> backing = 4;
   */
  backing: { [key: string]: string } = {};

  constructor(data?: PartialMessage<MemoryConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.MemoryConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "size_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "hotplug_enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "max_size_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    {
      no: 4,
      name: "backing",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MemoryConfig {
    return new MemoryConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MemoryConfig {
    return new MemoryConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MemoryConfig {
    return new MemoryConfig().fromJsonString(jsonString, options);
  }

  static equals(
    a: MemoryConfig | PlainMessage<MemoryConfig> | undefined,
    b: MemoryConfig | PlainMessage<MemoryConfig> | undefined,
  ): boolean {
    return proto3.util.equals(MemoryConfig, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.BootConfig
 */
export class BootConfig extends Message<BootConfig> {
  /**
   * Path to kernel image
   *
   * @generated from field: string kernel_path = 1;
   */
  kernelPath = "";

  /**
   * Path to initial ramdisk (optional)
   *
   * @generated from field: string initrd_path = 2;
   */
  initrdPath = "";

  /**
   * Kernel command line arguments
   *
   * @generated from field: string kernel_args = 3;
   */
  kernelArgs = "";

  /**
   * Boot order and options
   *
   * @generated from field: map<string, string> boot_options = 4;
   */
  bootOptions: { [key: string]: string } = {};

  constructor(data?: PartialMessage<BootConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.BootConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "kernel_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "initrd_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "kernel_args", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 4,
      name: "boot_options",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BootConfig {
    return new BootConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BootConfig {
    return new BootConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BootConfig {
    return new BootConfig().fromJsonString(jsonString, options);
  }

  static equals(
    a: BootConfig | PlainMessage<BootConfig> | undefined,
    b: BootConfig | PlainMessage<BootConfig> | undefined,
  ): boolean {
    return proto3.util.equals(BootConfig, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.StorageDevice
 */
export class StorageDevice extends Message<StorageDevice> {
  /**
   * Unique identifier for this storage device
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * Path to the backing file or block device
   *
   * @generated from field: string path = 2;
   */
  path = "";

  /**
   * Whether this device is read-only
   *
   * @generated from field: bool read_only = 3;
   */
  readOnly = false;

  /**
   * Whether this is the root/boot device
   *
   * @generated from field: bool is_root_device = 4;
   */
  isRootDevice = false;

  /**
   * Storage interface type (virtio-blk, nvme, etc.)
   *
   * @generated from field: string interface_type = 5;
   */
  interfaceType = "";

  /**
   * Additional storage options
   *
   * @generated from field: map<string, string> options = 6;
   */
  options: { [key: string]: string } = {};

  constructor(data?: PartialMessage<StorageDevice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.StorageDevice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "read_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "is_root_device", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "interface_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 6,
      name: "options",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StorageDevice {
    return new StorageDevice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StorageDevice {
    return new StorageDevice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StorageDevice {
    return new StorageDevice().fromJsonString(jsonString, options);
  }

  static equals(
    a: StorageDevice | PlainMessage<StorageDevice> | undefined,
    b: StorageDevice | PlainMessage<StorageDevice> | undefined,
  ): boolean {
    return proto3.util.equals(StorageDevice, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.NetworkInterface
 */
export class NetworkInterface extends Message<NetworkInterface> {
  /**
   * Unique identifier for this network interface
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * MAC address (optional, will be generated if not provided)
   *
   * @generated from field: string mac_address = 2;
   */
  macAddress = "";

  /**
   * Host-side TAP device name
   *
   * @generated from field: string tap_device = 3;
   */
  tapDevice = "";

  /**
   * Network interface type (virtio-net, e1000, etc.)
   *
   * @generated from field: string interface_type = 4;
   */
  interfaceType = "";

  /**
   * Additional network options
   *
   * @generated from field: map<string, string> options = 5;
   */
  options: { [key: string]: string } = {};

  /**
   * IPv4 configuration (optional)
   *
   * @generated from field: metal.vmprovisioner.v1.IPv4Config ipv4_config = 6;
   */
  ipv4Config?: IPv4Config;

  /**
   * IPv6 configuration (optional)
   *
   * @generated from field: metal.vmprovisioner.v1.IPv6Config ipv6_config = 7;
   */
  ipv6Config?: IPv6Config;

  /**
   * Network mode
   *
   * @generated from field: metal.vmprovisioner.v1.NetworkMode mode = 8;
   */
  mode = NetworkMode.UNSPECIFIED;

  /**
   * Rate limiting
   *
   * Receive rate limit
   *
   * @generated from field: metal.vmprovisioner.v1.RateLimit rx_rate_limit = 10;
   */
  rxRateLimit?: RateLimit;

  /**
   * Transmit rate limit
   *
   * @generated from field: metal.vmprovisioner.v1.RateLimit tx_rate_limit = 11;
   */
  txRateLimit?: RateLimit;

  constructor(data?: PartialMessage<NetworkInterface>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.NetworkInterface";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mac_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "tap_device", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "interface_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 5,
      name: "options",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
    { no: 6, name: "ipv4_config", kind: "message", T: IPv4Config },
    { no: 7, name: "ipv6_config", kind: "message", T: IPv6Config },
    { no: 8, name: "mode", kind: "enum", T: proto3.getEnumType(NetworkMode) },
    { no: 10, name: "rx_rate_limit", kind: "message", T: RateLimit },
    { no: 11, name: "tx_rate_limit", kind: "message", T: RateLimit },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkInterface {
    return new NetworkInterface().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkInterface {
    return new NetworkInterface().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkInterface {
    return new NetworkInterface().fromJsonString(jsonString, options);
  }

  static equals(
    a: NetworkInterface | PlainMessage<NetworkInterface> | undefined,
    b: NetworkInterface | PlainMessage<NetworkInterface> | undefined,
  ): boolean {
    return proto3.util.equals(NetworkInterface, a, b);
  }
}

/**
 * IPv4 network configuration
 *
 * @generated from message metal.vmprovisioner.v1.IPv4Config
 */
export class IPv4Config extends Message<IPv4Config> {
  /**
   * IPv4 address (e.g., "10.100.1.2")
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * Network mask (e.g., "255.255.255.0")
   *
   * @generated from field: string netmask = 2;
   */
  netmask = "";

  /**
   * Default gateway
   *
   * @generated from field: string gateway = 3;
   */
  gateway = "";

  /**
   * DNS servers
   *
   * @generated from field: repeated string dns_servers = 4;
   */
  dnsServers: string[] = [];

  /**
   * Use DHCP instead of static config
   *
   * @generated from field: bool dhcp = 5;
   */
  dhcp = false;

  constructor(data?: PartialMessage<IPv4Config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.IPv4Config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "netmask", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "gateway", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "dns_servers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "dhcp", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IPv4Config {
    return new IPv4Config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IPv4Config {
    return new IPv4Config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IPv4Config {
    return new IPv4Config().fromJsonString(jsonString, options);
  }

  static equals(
    a: IPv4Config | PlainMessage<IPv4Config> | undefined,
    b: IPv4Config | PlainMessage<IPv4Config> | undefined,
  ): boolean {
    return proto3.util.equals(IPv4Config, a, b);
  }
}

/**
 * IPv6 network configuration
 *
 * @generated from message metal.vmprovisioner.v1.IPv6Config
 */
export class IPv6Config extends Message<IPv6Config> {
  /**
   * IPv6 address (e.g., "fd00::1:2")
   *
   * @generated from field: string address = 1;
   */
  address = "";

  /**
   * Prefix length (e.g., 64)
   *
   * @generated from field: int32 prefix_length = 2;
   */
  prefixLength = 0;

  /**
   * Default gateway
   *
   * @generated from field: string gateway = 3;
   */
  gateway = "";

  /**
   * DNS servers (IPv6 addresses)
   *
   * @generated from field: repeated string dns_servers = 4;
   */
  dnsServers: string[] = [];

  /**
   * Use SLAAC (Stateless Address Autoconfiguration)
   *
   * @generated from field: bool slaac = 5;
   */
  slaac = false;

  /**
   * Enable privacy extensions
   *
   * @generated from field: bool privacy_extensions = 6;
   */
  privacyExtensions = false;

  /**
   * Link-local address (auto-generated if empty)
   *
   * @generated from field: string link_local = 7;
   */
  linkLocal = "";

  constructor(data?: PartialMessage<IPv6Config>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.IPv6Config";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "prefix_length", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "gateway", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "dns_servers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "slaac", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "privacy_extensions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 7, name: "link_local", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): IPv6Config {
    return new IPv6Config().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): IPv6Config {
    return new IPv6Config().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): IPv6Config {
    return new IPv6Config().fromJsonString(jsonString, options);
  }

  static equals(
    a: IPv6Config | PlainMessage<IPv6Config> | undefined,
    b: IPv6Config | PlainMessage<IPv6Config> | undefined,
  ): boolean {
    return proto3.util.equals(IPv6Config, a, b);
  }
}

/**
 * Rate limiting configuration
 *
 * @generated from message metal.vmprovisioner.v1.RateLimit
 */
export class RateLimit extends Message<RateLimit> {
  /**
   * Bandwidth in bytes/second
   *
   * @generated from field: int64 bandwidth = 1;
   */
  bandwidth = protoInt64.zero;

  /**
   * Token bucket refill time in milliseconds
   *
   * @generated from field: int64 refill_time = 2;
   */
  refillTime = protoInt64.zero;

  /**
   * Burst size in bytes
   *
   * @generated from field: int64 burst = 3;
   */
  burst = protoInt64.zero;

  constructor(data?: PartialMessage<RateLimit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.RateLimit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bandwidth", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "refill_time", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "burst", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RateLimit {
    return new RateLimit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RateLimit {
    return new RateLimit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RateLimit {
    return new RateLimit().fromJsonString(jsonString, options);
  }

  static equals(
    a: RateLimit | PlainMessage<RateLimit> | undefined,
    b: RateLimit | PlainMessage<RateLimit> | undefined,
  ): boolean {
    return proto3.util.equals(RateLimit, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.ConsoleConfig
 */
export class ConsoleConfig extends Message<ConsoleConfig> {
  /**
   * Whether console is enabled
   *
   * @generated from field: bool enabled = 1;
   */
  enabled = false;

  /**
   * Console output destination (file path, pty, etc.)
   *
   * @generated from field: string output = 2;
   */
  output = "";

  /**
   * Console input source (optional)
   *
   * @generated from field: string input = 3;
   */
  input = "";

  /**
   * Console type (serial, virtio-console, etc.)
   *
   * @generated from field: string console_type = 4;
   */
  consoleType = "";

  constructor(data?: PartialMessage<ConsoleConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.ConsoleConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "enabled", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "output", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "input", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "console_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConsoleConfig {
    return new ConsoleConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConsoleConfig {
    return new ConsoleConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConsoleConfig {
    return new ConsoleConfig().fromJsonString(jsonString, options);
  }

  static equals(
    a: ConsoleConfig | PlainMessage<ConsoleConfig> | undefined,
    b: ConsoleConfig | PlainMessage<ConsoleConfig> | undefined,
  ): boolean {
    return proto3.util.equals(ConsoleConfig, a, b);
  }
}

/**
 * Request/Response messages
 *
 * @generated from message metal.vmprovisioner.v1.CreateVmRequest
 */
export class CreateVmRequest extends Message<CreateVmRequest> {
  /**
   * Unique identifier for the VM (optional, will be generated if not provided)
   *
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  /**
   * VM configuration
   *
   * @generated from field: metal.vmprovisioner.v1.VmConfig config = 2;
   */
  config?: VmConfig;

  /**
   * Customer identifier for billing and isolation
   *
   * @generated from field: string customer_id = 3;
   */
  customerId = "";

  constructor(data?: PartialMessage<CreateVmRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.CreateVmRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "config", kind: "message", T: VmConfig },
    { no: 3, name: "customer_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateVmRequest {
    return new CreateVmRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateVmRequest {
    return new CreateVmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateVmRequest {
    return new CreateVmRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateVmRequest | PlainMessage<CreateVmRequest> | undefined,
    b: CreateVmRequest | PlainMessage<CreateVmRequest> | undefined,
  ): boolean {
    return proto3.util.equals(CreateVmRequest, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.CreateVmResponse
 */
export class CreateVmResponse extends Message<CreateVmResponse> {
  /**
   * Assigned VM identifier
   *
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  /**
   * Current VM state after creation
   *
   * @generated from field: metal.vmprovisioner.v1.VmState state = 2;
   */
  state = VmState.UNSPECIFIED;

  constructor(data?: PartialMessage<CreateVmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.CreateVmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(VmState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateVmResponse {
    return new CreateVmResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateVmResponse {
    return new CreateVmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateVmResponse {
    return new CreateVmResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: CreateVmResponse | PlainMessage<CreateVmResponse> | undefined,
    b: CreateVmResponse | PlainMessage<CreateVmResponse> | undefined,
  ): boolean {
    return proto3.util.equals(CreateVmResponse, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.DeleteVmRequest
 */
export class DeleteVmRequest extends Message<DeleteVmRequest> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  /**
   * Whether to force deletion even if VM is running
   *
   * @generated from field: bool force = 2;
   */
  force = false;

  constructor(data?: PartialMessage<DeleteVmRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.DeleteVmRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "force", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteVmRequest {
    return new DeleteVmRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteVmRequest {
    return new DeleteVmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteVmRequest {
    return new DeleteVmRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: DeleteVmRequest | PlainMessage<DeleteVmRequest> | undefined,
    b: DeleteVmRequest | PlainMessage<DeleteVmRequest> | undefined,
  ): boolean {
    return proto3.util.equals(DeleteVmRequest, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.DeleteVmResponse
 */
export class DeleteVmResponse extends Message<DeleteVmResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  constructor(data?: PartialMessage<DeleteVmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.DeleteVmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteVmResponse {
    return new DeleteVmResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteVmResponse {
    return new DeleteVmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteVmResponse {
    return new DeleteVmResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: DeleteVmResponse | PlainMessage<DeleteVmResponse> | undefined,
    b: DeleteVmResponse | PlainMessage<DeleteVmResponse> | undefined,
  ): boolean {
    return proto3.util.equals(DeleteVmResponse, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.BootVmRequest
 */
export class BootVmRequest extends Message<BootVmRequest> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  constructor(data?: PartialMessage<BootVmRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.BootVmRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BootVmRequest {
    return new BootVmRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BootVmRequest {
    return new BootVmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BootVmRequest {
    return new BootVmRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: BootVmRequest | PlainMessage<BootVmRequest> | undefined,
    b: BootVmRequest | PlainMessage<BootVmRequest> | undefined,
  ): boolean {
    return proto3.util.equals(BootVmRequest, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.BootVmResponse
 */
export class BootVmResponse extends Message<BootVmResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * @generated from field: metal.vmprovisioner.v1.VmState state = 2;
   */
  state = VmState.UNSPECIFIED;

  constructor(data?: PartialMessage<BootVmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.BootVmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(VmState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BootVmResponse {
    return new BootVmResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BootVmResponse {
    return new BootVmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BootVmResponse {
    return new BootVmResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: BootVmResponse | PlainMessage<BootVmResponse> | undefined,
    b: BootVmResponse | PlainMessage<BootVmResponse> | undefined,
  ): boolean {
    return proto3.util.equals(BootVmResponse, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.ShutdownVmRequest
 */
export class ShutdownVmRequest extends Message<ShutdownVmRequest> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  /**
   * Whether to force shutdown (vs graceful)
   *
   * @generated from field: bool force = 2;
   */
  force = false;

  /**
   * Timeout for graceful shutdown (seconds)
   *
   * @generated from field: int32 timeout_seconds = 3;
   */
  timeoutSeconds = 0;

  constructor(data?: PartialMessage<ShutdownVmRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.ShutdownVmRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "force", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "timeout_seconds", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShutdownVmRequest {
    return new ShutdownVmRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShutdownVmRequest {
    return new ShutdownVmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShutdownVmRequest {
    return new ShutdownVmRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: ShutdownVmRequest | PlainMessage<ShutdownVmRequest> | undefined,
    b: ShutdownVmRequest | PlainMessage<ShutdownVmRequest> | undefined,
  ): boolean {
    return proto3.util.equals(ShutdownVmRequest, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.ShutdownVmResponse
 */
export class ShutdownVmResponse extends Message<ShutdownVmResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * @generated from field: metal.vmprovisioner.v1.VmState state = 2;
   */
  state = VmState.UNSPECIFIED;

  constructor(data?: PartialMessage<ShutdownVmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.ShutdownVmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(VmState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShutdownVmResponse {
    return new ShutdownVmResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShutdownVmResponse {
    return new ShutdownVmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ShutdownVmResponse {
    return new ShutdownVmResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: ShutdownVmResponse | PlainMessage<ShutdownVmResponse> | undefined,
    b: ShutdownVmResponse | PlainMessage<ShutdownVmResponse> | undefined,
  ): boolean {
    return proto3.util.equals(ShutdownVmResponse, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.PauseVmRequest
 */
export class PauseVmRequest extends Message<PauseVmRequest> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  constructor(data?: PartialMessage<PauseVmRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.PauseVmRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PauseVmRequest {
    return new PauseVmRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PauseVmRequest {
    return new PauseVmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PauseVmRequest {
    return new PauseVmRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: PauseVmRequest | PlainMessage<PauseVmRequest> | undefined,
    b: PauseVmRequest | PlainMessage<PauseVmRequest> | undefined,
  ): boolean {
    return proto3.util.equals(PauseVmRequest, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.PauseVmResponse
 */
export class PauseVmResponse extends Message<PauseVmResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * @generated from field: metal.vmprovisioner.v1.VmState state = 2;
   */
  state = VmState.UNSPECIFIED;

  constructor(data?: PartialMessage<PauseVmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.PauseVmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(VmState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PauseVmResponse {
    return new PauseVmResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PauseVmResponse {
    return new PauseVmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PauseVmResponse {
    return new PauseVmResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: PauseVmResponse | PlainMessage<PauseVmResponse> | undefined,
    b: PauseVmResponse | PlainMessage<PauseVmResponse> | undefined,
  ): boolean {
    return proto3.util.equals(PauseVmResponse, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.ResumeVmRequest
 */
export class ResumeVmRequest extends Message<ResumeVmRequest> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  constructor(data?: PartialMessage<ResumeVmRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.ResumeVmRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResumeVmRequest {
    return new ResumeVmRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResumeVmRequest {
    return new ResumeVmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResumeVmRequest {
    return new ResumeVmRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: ResumeVmRequest | PlainMessage<ResumeVmRequest> | undefined,
    b: ResumeVmRequest | PlainMessage<ResumeVmRequest> | undefined,
  ): boolean {
    return proto3.util.equals(ResumeVmRequest, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.ResumeVmResponse
 */
export class ResumeVmResponse extends Message<ResumeVmResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * @generated from field: metal.vmprovisioner.v1.VmState state = 2;
   */
  state = VmState.UNSPECIFIED;

  constructor(data?: PartialMessage<ResumeVmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.ResumeVmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(VmState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ResumeVmResponse {
    return new ResumeVmResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ResumeVmResponse {
    return new ResumeVmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ResumeVmResponse {
    return new ResumeVmResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: ResumeVmResponse | PlainMessage<ResumeVmResponse> | undefined,
    b: ResumeVmResponse | PlainMessage<ResumeVmResponse> | undefined,
  ): boolean {
    return proto3.util.equals(ResumeVmResponse, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.RebootVmRequest
 */
export class RebootVmRequest extends Message<RebootVmRequest> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  /**
   * Whether to force reboot (vs graceful)
   *
   * @generated from field: bool force = 2;
   */
  force = false;

  constructor(data?: PartialMessage<RebootVmRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.RebootVmRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "force", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RebootVmRequest {
    return new RebootVmRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RebootVmRequest {
    return new RebootVmRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RebootVmRequest {
    return new RebootVmRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: RebootVmRequest | PlainMessage<RebootVmRequest> | undefined,
    b: RebootVmRequest | PlainMessage<RebootVmRequest> | undefined,
  ): boolean {
    return proto3.util.equals(RebootVmRequest, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.RebootVmResponse
 */
export class RebootVmResponse extends Message<RebootVmResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * @generated from field: metal.vmprovisioner.v1.VmState state = 2;
   */
  state = VmState.UNSPECIFIED;

  constructor(data?: PartialMessage<RebootVmResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.RebootVmResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(VmState) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RebootVmResponse {
    return new RebootVmResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RebootVmResponse {
    return new RebootVmResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RebootVmResponse {
    return new RebootVmResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: RebootVmResponse | PlainMessage<RebootVmResponse> | undefined,
    b: RebootVmResponse | PlainMessage<RebootVmResponse> | undefined,
  ): boolean {
    return proto3.util.equals(RebootVmResponse, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.GetVmInfoRequest
 */
export class GetVmInfoRequest extends Message<GetVmInfoRequest> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  constructor(data?: PartialMessage<GetVmInfoRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.GetVmInfoRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVmInfoRequest {
    return new GetVmInfoRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVmInfoRequest {
    return new GetVmInfoRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVmInfoRequest {
    return new GetVmInfoRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetVmInfoRequest | PlainMessage<GetVmInfoRequest> | undefined,
    b: GetVmInfoRequest | PlainMessage<GetVmInfoRequest> | undefined,
  ): boolean {
    return proto3.util.equals(GetVmInfoRequest, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.GetVmInfoResponse
 */
export class GetVmInfoResponse extends Message<GetVmInfoResponse> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  /**
   * @generated from field: metal.vmprovisioner.v1.VmConfig config = 2;
   */
  config?: VmConfig;

  /**
   * @generated from field: metal.vmprovisioner.v1.VmState state = 3;
   */
  state = VmState.UNSPECIFIED;

  /**
   * @generated from field: metal.vmprovisioner.v1.VmMetrics metrics = 4;
   */
  metrics?: VmMetrics;

  /**
   * Backend-specific information
   *
   * @generated from field: map<string, string> backend_info = 5;
   */
  backendInfo: { [key: string]: string } = {};

  /**
   * Network information if available
   *
   * @generated from field: metal.vmprovisioner.v1.VmNetworkInfo network_info = 6;
   */
  networkInfo?: VmNetworkInfo;

  constructor(data?: PartialMessage<GetVmInfoResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.GetVmInfoResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "config", kind: "message", T: VmConfig },
    { no: 3, name: "state", kind: "enum", T: proto3.getEnumType(VmState) },
    { no: 4, name: "metrics", kind: "message", T: VmMetrics },
    {
      no: 5,
      name: "backend_info",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
    { no: 6, name: "network_info", kind: "message", T: VmNetworkInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetVmInfoResponse {
    return new GetVmInfoResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetVmInfoResponse {
    return new GetVmInfoResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetVmInfoResponse {
    return new GetVmInfoResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetVmInfoResponse | PlainMessage<GetVmInfoResponse> | undefined,
    b: GetVmInfoResponse | PlainMessage<GetVmInfoResponse> | undefined,
  ): boolean {
    return proto3.util.equals(GetVmInfoResponse, a, b);
  }
}

/**
 * Port mapping for VM network forwarding
 *
 * @generated from message metal.vmprovisioner.v1.PortMapping
 */
export class PortMapping extends Message<PortMapping> {
  /**
   * Port inside the VM
   *
   * @generated from field: int32 container_port = 1;
   */
  containerPort = 0;

  /**
   * Port on the host system
   *
   * @generated from field: int32 host_port = 2;
   */
  hostPort = 0;

  /**
   * Protocol (tcp, udp)
   *
   * @generated from field: string protocol = 3;
   */
  protocol = "";

  constructor(data?: PartialMessage<PortMapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.PortMapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "container_port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "host_port", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "protocol", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PortMapping {
    return new PortMapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PortMapping {
    return new PortMapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PortMapping {
    return new PortMapping().fromJsonString(jsonString, options);
  }

  static equals(
    a: PortMapping | PlainMessage<PortMapping> | undefined,
    b: PortMapping | PlainMessage<PortMapping> | undefined,
  ): boolean {
    return proto3.util.equals(PortMapping, a, b);
  }
}

/**
 * Network information for a VM
 *
 * @generated from message metal.vmprovisioner.v1.VmNetworkInfo
 */
export class VmNetworkInfo extends Message<VmNetworkInfo> {
  /**
   * @generated from field: string ip_address = 1;
   */
  ipAddress = "";

  /**
   * @generated from field: string mac_address = 2;
   */
  macAddress = "";

  /**
   * @generated from field: string tap_device = 3;
   */
  tapDevice = "";

  /**
   * @generated from field: string network_namespace = 4;
   */
  networkNamespace = "";

  /**
   * @generated from field: string gateway = 5;
   */
  gateway = "";

  /**
   * @generated from field: repeated string dns_servers = 6;
   */
  dnsServers: string[] = [];

  /**
   * Port forwards from host to VM
   *
   * @generated from field: repeated metal.vmprovisioner.v1.PortMapping port_mappings = 7;
   */
  portMappings: PortMapping[] = [];

  constructor(data?: PartialMessage<VmNetworkInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.VmNetworkInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ip_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "mac_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "tap_device", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "network_namespace", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "gateway", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "dns_servers", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 7, name: "port_mappings", kind: "message", T: PortMapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VmNetworkInfo {
    return new VmNetworkInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VmNetworkInfo {
    return new VmNetworkInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VmNetworkInfo {
    return new VmNetworkInfo().fromJsonString(jsonString, options);
  }

  static equals(
    a: VmNetworkInfo | PlainMessage<VmNetworkInfo> | undefined,
    b: VmNetworkInfo | PlainMessage<VmNetworkInfo> | undefined,
  ): boolean {
    return proto3.util.equals(VmNetworkInfo, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.VmMetrics
 */
export class VmMetrics extends Message<VmMetrics> {
  /**
   * CPU usage percentage (0-100)
   *
   * @generated from field: double cpu_usage_percent = 1;
   */
  cpuUsagePercent = 0;

  /**
   * Memory usage in bytes
   *
   * @generated from field: int64 memory_usage_bytes = 2;
   */
  memoryUsageBytes = protoInt64.zero;

  /**
   * Network I/O statistics
   *
   * @generated from field: metal.vmprovisioner.v1.NetworkStats network_stats = 3;
   */
  networkStats?: NetworkStats;

  /**
   * Storage I/O statistics
   *
   * @generated from field: metal.vmprovisioner.v1.StorageStats storage_stats = 4;
   */
  storageStats?: StorageStats;

  /**
   * VM uptime in seconds
   *
   * @generated from field: int64 uptime_seconds = 5;
   */
  uptimeSeconds = protoInt64.zero;

  constructor(data?: PartialMessage<VmMetrics>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.VmMetrics";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cpu_usage_percent", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 2, name: "memory_usage_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "network_stats", kind: "message", T: NetworkStats },
    { no: 4, name: "storage_stats", kind: "message", T: StorageStats },
    { no: 5, name: "uptime_seconds", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VmMetrics {
    return new VmMetrics().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VmMetrics {
    return new VmMetrics().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VmMetrics {
    return new VmMetrics().fromJsonString(jsonString, options);
  }

  static equals(
    a: VmMetrics | PlainMessage<VmMetrics> | undefined,
    b: VmMetrics | PlainMessage<VmMetrics> | undefined,
  ): boolean {
    return proto3.util.equals(VmMetrics, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.NetworkStats
 */
export class NetworkStats extends Message<NetworkStats> {
  /**
   * @generated from field: int64 bytes_received = 1;
   */
  bytesReceived = protoInt64.zero;

  /**
   * @generated from field: int64 bytes_transmitted = 2;
   */
  bytesTransmitted = protoInt64.zero;

  /**
   * @generated from field: int64 packets_received = 3;
   */
  packetsReceived = protoInt64.zero;

  /**
   * @generated from field: int64 packets_transmitted = 4;
   */
  packetsTransmitted = protoInt64.zero;

  constructor(data?: PartialMessage<NetworkStats>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.NetworkStats";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bytes_received", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "bytes_transmitted", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "packets_received", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "packets_transmitted", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NetworkStats {
    return new NetworkStats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NetworkStats {
    return new NetworkStats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NetworkStats {
    return new NetworkStats().fromJsonString(jsonString, options);
  }

  static equals(
    a: NetworkStats | PlainMessage<NetworkStats> | undefined,
    b: NetworkStats | PlainMessage<NetworkStats> | undefined,
  ): boolean {
    return proto3.util.equals(NetworkStats, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.StorageStats
 */
export class StorageStats extends Message<StorageStats> {
  /**
   * @generated from field: int64 bytes_read = 1;
   */
  bytesRead = protoInt64.zero;

  /**
   * @generated from field: int64 bytes_written = 2;
   */
  bytesWritten = protoInt64.zero;

  /**
   * @generated from field: int64 read_operations = 3;
   */
  readOperations = protoInt64.zero;

  /**
   * @generated from field: int64 write_operations = 4;
   */
  writeOperations = protoInt64.zero;

  constructor(data?: PartialMessage<StorageStats>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.StorageStats";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bytes_read", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "bytes_written", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "read_operations", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "write_operations", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StorageStats {
    return new StorageStats().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StorageStats {
    return new StorageStats().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StorageStats {
    return new StorageStats().fromJsonString(jsonString, options);
  }

  static equals(
    a: StorageStats | PlainMessage<StorageStats> | undefined,
    b: StorageStats | PlainMessage<StorageStats> | undefined,
  ): boolean {
    return proto3.util.equals(StorageStats, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.ListVmsRequest
 */
export class ListVmsRequest extends Message<ListVmsRequest> {
  /**
   * Optional filter by state
   *
   * @generated from field: repeated metal.vmprovisioner.v1.VmState state_filter = 1;
   */
  stateFilter: VmState[] = [];

  /**
   * Pagination
   *
   * @generated from field: int32 page_size = 2;
   */
  pageSize = 0;

  /**
   * @generated from field: string page_token = 3;
   */
  pageToken = "";

  constructor(data?: PartialMessage<ListVmsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.ListVmsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "state_filter", kind: "enum", T: proto3.getEnumType(VmState), repeated: true },
    { no: 2, name: "page_size", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListVmsRequest {
    return new ListVmsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListVmsRequest {
    return new ListVmsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListVmsRequest {
    return new ListVmsRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: ListVmsRequest | PlainMessage<ListVmsRequest> | undefined,
    b: ListVmsRequest | PlainMessage<ListVmsRequest> | undefined,
  ): boolean {
    return proto3.util.equals(ListVmsRequest, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.ListVmsResponse
 */
export class ListVmsResponse extends Message<ListVmsResponse> {
  /**
   * @generated from field: repeated metal.vmprovisioner.v1.VmInfo vms = 1;
   */
  vms: VmInfo[] = [];

  /**
   * @generated from field: string next_page_token = 2;
   */
  nextPageToken = "";

  /**
   * @generated from field: int32 total_count = 3;
   */
  totalCount = 0;

  constructor(data?: PartialMessage<ListVmsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.ListVmsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vms", kind: "message", T: VmInfo, repeated: true },
    { no: 2, name: "next_page_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "total_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ListVmsResponse {
    return new ListVmsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ListVmsResponse {
    return new ListVmsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ListVmsResponse {
    return new ListVmsResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: ListVmsResponse | PlainMessage<ListVmsResponse> | undefined,
    b: ListVmsResponse | PlainMessage<ListVmsResponse> | undefined,
  ): boolean {
    return proto3.util.equals(ListVmsResponse, a, b);
  }
}

/**
 * @generated from message metal.vmprovisioner.v1.VmInfo
 */
export class VmInfo extends Message<VmInfo> {
  /**
   * @generated from field: string vm_id = 1;
   */
  vmId = "";

  /**
   * @generated from field: metal.vmprovisioner.v1.VmState state = 2;
   */
  state = VmState.UNSPECIFIED;

  /**
   * Basic config info (subset of full config)
   *
   * @generated from field: int32 vcpu_count = 3;
   */
  vcpuCount = 0;

  /**
   * @generated from field: int64 memory_size_bytes = 4;
   */
  memorySizeBytes = protoInt64.zero;

  /**
   * Creation and modification timestamps
   *
   * @generated from field: int64 created_timestamp = 5;
   */
  createdTimestamp = protoInt64.zero;

  /**
   * @generated from field: int64 modified_timestamp = 6;
   */
  modifiedTimestamp = protoInt64.zero;

  /**
   * Metadata
   *
   * @generated from field: map<string, string> metadata = 7;
   */
  metadata: { [key: string]: string } = {};

  /**
   * Customer identifier
   *
   * @generated from field: string customer_id = 8;
   */
  customerId = "";

  constructor(data?: PartialMessage<VmInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "metal.vmprovisioner.v1.VmInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "vm_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "state", kind: "enum", T: proto3.getEnumType(VmState) },
    { no: 3, name: "vcpu_count", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "memory_size_bytes", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "created_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 6, name: "modified_timestamp", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    {
      no: 7,
      name: "metadata",
      kind: "map",
      K: 9 /* ScalarType.STRING */,
      V: { kind: "scalar", T: 9 /* ScalarType.STRING */ },
    },
    { no: 8, name: "customer_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): VmInfo {
    return new VmInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): VmInfo {
    return new VmInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): VmInfo {
    return new VmInfo().fromJsonString(jsonString, options);
  }

  static equals(
    a: VmInfo | PlainMessage<VmInfo> | undefined,
    b: VmInfo | PlainMessage<VmInfo> | undefined,
  ): boolean {
    return proto3.util.equals(VmInfo, a, b);
  }
}
