// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
)

// V1KeysUpdateKeyType - Fast ratelimiting doesn't add latency, while consistent ratelimiting is more accurate.
//
// https://unkey.dev/docs/features/ratelimiting - Learn more
type V1KeysUpdateKeyType string

const (
	V1KeysUpdateKeyTypeFast       V1KeysUpdateKeyType = "fast"
	V1KeysUpdateKeyTypeConsistent V1KeysUpdateKeyType = "consistent"
)

func (e V1KeysUpdateKeyType) ToPointer() *V1KeysUpdateKeyType {
	return &e
}

func (e *V1KeysUpdateKeyType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "fast":
		fallthrough
	case "consistent":
		*e = V1KeysUpdateKeyType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for V1KeysUpdateKeyType: %v", v)
	}
}

// V1KeysUpdateKeyRatelimit - Unkey comes with per-key ratelimiting out of the box. Set `null` to disable.
type V1KeysUpdateKeyRatelimit struct {
	// Fast ratelimiting doesn't add latency, while consistent ratelimiting is more accurate.
	Type V1KeysUpdateKeyType `json:"type"`
	// The total amount of burstable requests.
	Limit int64 `json:"limit"`
	// How many tokens to refill during each refillInterval.
	RefillRate int64 `json:"refillRate"`
	// Determines the speed at which tokens are refilled, in milliseconds.
	RefillInterval int64 `json:"refillInterval"`
}

func (o *V1KeysUpdateKeyRatelimit) GetType() V1KeysUpdateKeyType {
	if o == nil {
		return V1KeysUpdateKeyType("")
	}
	return o.Type
}

func (o *V1KeysUpdateKeyRatelimit) GetLimit() int64 {
	if o == nil {
		return 0
	}
	return o.Limit
}

func (o *V1KeysUpdateKeyRatelimit) GetRefillRate() int64 {
	if o == nil {
		return 0
	}
	return o.RefillRate
}

func (o *V1KeysUpdateKeyRatelimit) GetRefillInterval() int64 {
	if o == nil {
		return 0
	}
	return o.RefillInterval
}

// V1KeysUpdateKeyInterval - Unkey will automatically refill verifications at the set interval. If null is used the refill functionality will be removed from the key.
type V1KeysUpdateKeyInterval string

const (
	V1KeysUpdateKeyIntervalDaily   V1KeysUpdateKeyInterval = "daily"
	V1KeysUpdateKeyIntervalMonthly V1KeysUpdateKeyInterval = "monthly"
)

func (e V1KeysUpdateKeyInterval) ToPointer() *V1KeysUpdateKeyInterval {
	return &e
}

func (e *V1KeysUpdateKeyInterval) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "daily":
		fallthrough
	case "monthly":
		*e = V1KeysUpdateKeyInterval(v)
		return nil
	default:
		return fmt.Errorf("invalid value for V1KeysUpdateKeyInterval: %v", v)
	}
}

// V1KeysUpdateKeyRefill - Unkey enables you to refill verifications for each key at regular intervals.
type V1KeysUpdateKeyRefill struct {
	// Unkey will automatically refill verifications at the set interval. If null is used the refill functionality will be removed from the key.
	Interval V1KeysUpdateKeyInterval `json:"interval"`
	// The amount of verifications to refill for each occurrence is determined individually for each key.
	Amount int64 `json:"amount"`
}

func (o *V1KeysUpdateKeyRefill) GetInterval() V1KeysUpdateKeyInterval {
	if o == nil {
		return V1KeysUpdateKeyInterval("")
	}
	return o.Interval
}

func (o *V1KeysUpdateKeyRefill) GetAmount() int64 {
	if o == nil {
		return 0
	}
	return o.Amount
}

type V1KeysUpdateKeyRequestBody struct {
	// The id of the key you want to modify
	KeyID string `json:"keyId"`
	// The name of the key
	Name *string `json:"name,omitempty"`
	// The id of the tenant associated with this key. Use whatever reference you have in your system to identify the tenant. When verifying the key, we will send this field back to you, so you know who is accessing your API.
	OwnerID *string `json:"ownerId,omitempty"`
	// Any additional metadata you want to store with the key
	Meta map[string]interface{} `json:"meta,omitempty"`
	// The unix timestamp in milliseconds when the key will expire. If this field is null or undefined, the key is not expiring.
	Expires *float64 `json:"expires,omitempty"`
	// Unkey comes with per-key ratelimiting out of the box. Set `null` to disable.
	Ratelimit *V1KeysUpdateKeyRatelimit `json:"ratelimit,omitempty"`
	// The number of requests that can be made with this key before it becomes invalid. Set `null` to disable.
	Remaining *float64 `json:"remaining,omitempty"`
	// Unkey enables you to refill verifications for each key at regular intervals.
	Refill *V1KeysUpdateKeyRefill `json:"refill,omitempty"`
	// Set if key is enabled or disabled. If disabled, the key cannot be used to verify.
	Enabled *bool `json:"enabled,omitempty"`
}

func (o *V1KeysUpdateKeyRequestBody) GetKeyID() string {
	if o == nil {
		return ""
	}
	return o.KeyID
}

func (o *V1KeysUpdateKeyRequestBody) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *V1KeysUpdateKeyRequestBody) GetOwnerID() *string {
	if o == nil {
		return nil
	}
	return o.OwnerID
}

func (o *V1KeysUpdateKeyRequestBody) GetMeta() map[string]interface{} {
	if o == nil {
		return nil
	}
	return o.Meta
}

func (o *V1KeysUpdateKeyRequestBody) GetExpires() *float64 {
	if o == nil {
		return nil
	}
	return o.Expires
}

func (o *V1KeysUpdateKeyRequestBody) GetRatelimit() *V1KeysUpdateKeyRatelimit {
	if o == nil {
		return nil
	}
	return o.Ratelimit
}

func (o *V1KeysUpdateKeyRequestBody) GetRemaining() *float64 {
	if o == nil {
		return nil
	}
	return o.Remaining
}

func (o *V1KeysUpdateKeyRequestBody) GetRefill() *V1KeysUpdateKeyRefill {
	if o == nil {
		return nil
	}
	return o.Refill
}

func (o *V1KeysUpdateKeyRequestBody) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

// V1KeysUpdateKeyResponseBody - The key was successfully updated, it may take up to 30s for this to take effect in all regions
type V1KeysUpdateKeyResponseBody struct {
}
