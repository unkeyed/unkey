// @generated by protoc-gen-es v2.8.0 with parameter "target=ts"
// @generated from file ctrl/v1/cluster.proto (package ctrl.v1, syntax proto3)
/* eslint-disable */

// Package ctrl.v1 provides the Cluster service for multi-cluster deployment orchestration.
//
// The Cluster service enables a central control plane to coordinate deployments and sentinels
// across multiple Kubernetes clusters. Each cluster runs an agent (such as krane) that establishes
// a long-lived watch connection to receive deployment and sentinel configuration events.
//
// This design follows the Kubernetes watch pattern where agents (like kubelet) maintain
// a streaming connection to receive incremental updates, enabling real-time deployment
// orchestration across distributed clusters.

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file ctrl/v1/cluster.proto.
 */
export const file_ctrl_v1_cluster: GenFile = /*@__PURE__*/
  fileDesc("ChVjdHJsL3YxL2NsdXN0ZXIucHJvdG8SB2N0cmwudjEiNQoeR2V0RGVzaXJlZFNlbnRpbmVsU3RhdGVSZXF1ZXN0EhMKC3NlbnRpbmVsX2lkGAEgASgJIsUBCh9HZXREZXNpcmVkU2VudGluZWxTdGF0ZVJlc3BvbnNlEhQKDHdvcmtzcGFjZV9pZBgBIAEoCRISCgpwcm9qZWN0X2lkGAIgASgJEhYKDmVudmlyb25tZW50X2lkGAMgASgJEhMKC3NlbnRpbmVsX2lkGAQgASgJEhAKCHJlcGxpY2FzGAUgASgFEg0KBWltYWdlGAYgASgJEhYKDmNwdV9taWxsaWNvcmVzGAcgASgDEhIKCm1lbW9yeV9taWIYCCABKAMiOQogR2V0RGVzaXJlZERlcGxveW1lbnRTdGF0ZVJlcXVlc3QSFQoNZGVwbG95bWVudF9pZBgBIAEoCSKHAQohR2V0RGVzaXJlZERlcGxveW1lbnRTdGF0ZVJlc3BvbnNlEhUKDWRlcGxveW1lbnRfaWQYASABKAkSEAoIcmVwbGljYXMYAiABKAUSDQoFaW1hZ2UYAyABKAkSFgoOY3B1X21pbGxpY29yZXMYBCABKAMSEgoKbWVtb3J5X21pYhgFIAEoAyLeAwoaVXBkYXRlSW5zdGFuY2VTdGF0ZVJlcXVlc3QSPAoGdXBzZXJ0GAEgASgLMiouY3RybC52MS5VcGRhdGVJbnN0YW5jZVN0YXRlUmVxdWVzdC5VcHNlcnRIABI8CgZkZWxldGUYAiABKAsyKi5jdHJsLnYxLlVwZGF0ZUluc3RhbmNlU3RhdGVSZXF1ZXN0LkRlbGV0ZUgAGqoBCgZVcHNlcnQSFQoNZGVwbG95bWVudF9pZBgBIAEoCRIQCghwb2RfbmFtZRgCIAEoCRIPCgdhZGRyZXNzGAMgASgJEhYKDmNwdV9taWxsaWNvcmVzGAQgASgFEhIKCm1lbW9yeV9taWIYBSABKAUSOgoGc3RhdHVzGAYgASgOMiouY3RybC52MS5VcGRhdGVJbnN0YW5jZVN0YXRlUmVxdWVzdC5TdGF0dXMaMAoGRGVsZXRlEhQKDGs4c19jcmRfbmFtZRgBIAEoCRIQCghwb2RfbmFtZRgCIAEoCSJbCgZTdGF0dXMSFgoSU1RBVFVTX1VOU1BFQ0lGSUVEEAASEgoOU1RBVFVTX1BFTkRJTkcQARISCg5TVEFUVVNfUlVOTklORxACEhEKDVNUQVRVU19GQUlMRUQQA0IICgZjaGFuZ2UiHQobVXBkYXRlSW5zdGFuY2VTdGF0ZVJlc3BvbnNlIkwKGlVwZGF0ZVNlbnRpbmVsU3RhdGVSZXF1ZXN0EhQKDGs4c19jcmRfbmFtZRgBIAEoCRIYChBydW5uaW5nX3JlcGxpY2FzGAIgASgFIh0KG1VwZGF0ZVNlbnRpbmVsU3RhdGVSZXNwb25zZSKtAQoMV2F0Y2hSZXF1ZXN0EhEKCWNsaWVudF9pZBgBIAEoCRI3CglzZWxlY3RvcnMYAiADKAsyJC5jdHJsLnYxLldhdGNoUmVxdWVzdC5TZWxlY3RvcnNFbnRyeRIMCgRsaXZlGAMgASgIEhEKCXN5bnRoZXRpYxgEIAEoCBowCg5TZWxlY3RvcnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBImwKDVNlbnRpbmVsRXZlbnQSJwoFYXBwbHkYASABKAsyFi5jdHJsLnYxLkFwcGx5U2VudGluZWxIABIpCgZkZWxldGUYAiABKAsyFy5jdHJsLnYxLkRlbGV0ZVNlbnRpbmVsSABCBwoFZXZlbnQicgoPRGVwbG95bWVudEV2ZW50EikKBWFwcGx5GAEgASgLMhguY3RybC52MS5BcHBseURlcGxveW1lbnRIABIrCgZkZWxldGUYAiABKAsyGS5jdHJsLnYxLkRlbGV0ZURlcGxveW1lbnRIAEIHCgVldmVudCKdAQoNQXBwbHlTZW50aW5lbBIRCgluYW1lc3BhY2UYASABKAkSFAoMazhzX2NyZF9uYW1lGAIgASgJEhQKDHdvcmtzcGFjZV9pZBgDIAEoCRISCgpwcm9qZWN0X2lkGAQgASgJEhYKDmVudmlyb25tZW50X2lkGAUgASgJEhMKC3NlbnRpbmVsX2lkGAYgASgJEgwKBGhhc2gYByABKAkiJQoORGVsZXRlU2VudGluZWwSEwoLc2VudGluZWxfaWQYASABKAki5QEKD0FwcGx5RGVwbG95bWVudBIRCgluYW1lc3BhY2UYASABKAkSFAoMazhzX2NyZF9uYW1lGAIgASgJEhQKDHdvcmtzcGFjZV9pZBgDIAEoCRISCgpwcm9qZWN0X2lkGAQgASgJEhYKDmVudmlyb25tZW50X2lkGAUgASgJEhUKDWRlcGxveW1lbnRfaWQYBiABKAkSDQoFaW1hZ2UYByABKAkSEAoIcmVwbGljYXMYCCABKA0SFgoOY3B1X21pbGxpY29yZXMYCSABKA0SFwoPbWVtb3J5X3NpemVfbWliGAogASgNIikKEERlbGV0ZURlcGxveW1lbnQSFQoNZGVwbG95bWVudF9pZBgBIAEoCTLABAoOQ2x1c3RlclNlcnZpY2USQQoOV2F0Y2hTZW50aW5lbHMSFS5jdHJsLnYxLldhdGNoUmVxdWVzdBoWLmN0cmwudjEuU2VudGluZWxFdmVudDABEmwKF0dldERlc2lyZWRTZW50aW5lbFN0YXRlEicuY3RybC52MS5HZXREZXNpcmVkU2VudGluZWxTdGF0ZVJlcXVlc3QaKC5jdHJsLnYxLkdldERlc2lyZWRTZW50aW5lbFN0YXRlUmVzcG9uc2USYAoTVXBkYXRlU2VudGluZWxTdGF0ZRIjLmN0cmwudjEuVXBkYXRlU2VudGluZWxTdGF0ZVJlcXVlc3QaJC5jdHJsLnYxLlVwZGF0ZVNlbnRpbmVsU3RhdGVSZXNwb25zZRJFChBXYXRjaERlcGxveW1lbnRzEhUuY3RybC52MS5XYXRjaFJlcXVlc3QaGC5jdHJsLnYxLkRlcGxveW1lbnRFdmVudDABEnIKGUdldERlc2lyZWREZXBsb3ltZW50U3RhdGUSKS5jdHJsLnYxLkdldERlc2lyZWREZXBsb3ltZW50U3RhdGVSZXF1ZXN0GiouY3RybC52MS5HZXREZXNpcmVkRGVwbG95bWVudFN0YXRlUmVzcG9uc2USYAoTVXBkYXRlSW5zdGFuY2VTdGF0ZRIjLmN0cmwudjEuVXBkYXRlSW5zdGFuY2VTdGF0ZVJlcXVlc3QaJC5jdHJsLnYxLlVwZGF0ZUluc3RhbmNlU3RhdGVSZXNwb25zZUKOAQoLY29tLmN0cmwudjFCDENsdXN0ZXJQcm90b1ABWjRnaXRodWIuY29tL3Vua2V5ZWQvdW5rZXkvZ28vZ2VuL3Byb3RvL2N0cmwvdjE7Y3RybHYxogIDQ1hYqgIHQ3RybC5WMcoCB0N0cmxcVjHiAhNDdHJsXFYxXEdQQk1ldGFkYXRh6gIIQ3RybDo6VjFiBnByb3RvMw");

/**
 * @generated from message ctrl.v1.GetDesiredSentinelStateRequest
 */
export type GetDesiredSentinelStateRequest = Message<"ctrl.v1.GetDesiredSentinelStateRequest"> & {
  /**
   * @generated from field: string sentinel_id = 1;
   */
  sentinelId: string;
};

/**
 * Describes the message ctrl.v1.GetDesiredSentinelStateRequest.
 * Use `create(GetDesiredSentinelStateRequestSchema)` to create a new message.
 */
export const GetDesiredSentinelStateRequestSchema: GenMessage<GetDesiredSentinelStateRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 0);

/**
 * @generated from message ctrl.v1.GetDesiredSentinelStateResponse
 */
export type GetDesiredSentinelStateResponse = Message<"ctrl.v1.GetDesiredSentinelStateResponse"> & {
  /**
   * @generated from field: string workspace_id = 1;
   */
  workspaceId: string;

  /**
   * @generated from field: string project_id = 2;
   */
  projectId: string;

  /**
   * @generated from field: string environment_id = 3;
   */
  environmentId: string;

  /**
   * @generated from field: string sentinel_id = 4;
   */
  sentinelId: string;

  /**
   * @generated from field: int32 replicas = 5;
   */
  replicas: number;

  /**
   * @generated from field: string image = 6;
   */
  image: string;

  /**
   * @generated from field: int64 cpu_millicores = 7;
   */
  cpuMillicores: bigint;

  /**
   * @generated from field: int64 memory_mib = 8;
   */
  memoryMib: bigint;
};

/**
 * Describes the message ctrl.v1.GetDesiredSentinelStateResponse.
 * Use `create(GetDesiredSentinelStateResponseSchema)` to create a new message.
 */
export const GetDesiredSentinelStateResponseSchema: GenMessage<GetDesiredSentinelStateResponse> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 1);

/**
 * @generated from message ctrl.v1.GetDesiredDeploymentStateRequest
 */
export type GetDesiredDeploymentStateRequest = Message<"ctrl.v1.GetDesiredDeploymentStateRequest"> & {
  /**
   * @generated from field: string deployment_id = 1;
   */
  deploymentId: string;
};

/**
 * Describes the message ctrl.v1.GetDesiredDeploymentStateRequest.
 * Use `create(GetDesiredDeploymentStateRequestSchema)` to create a new message.
 */
export const GetDesiredDeploymentStateRequestSchema: GenMessage<GetDesiredDeploymentStateRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 2);

/**
 * @generated from message ctrl.v1.GetDesiredDeploymentStateResponse
 */
export type GetDesiredDeploymentStateResponse = Message<"ctrl.v1.GetDesiredDeploymentStateResponse"> & {
  /**
   * @generated from field: string deployment_id = 1;
   */
  deploymentId: string;

  /**
   * @generated from field: int32 replicas = 2;
   */
  replicas: number;

  /**
   * @generated from field: string image = 3;
   */
  image: string;

  /**
   * @generated from field: int64 cpu_millicores = 4;
   */
  cpuMillicores: bigint;

  /**
   * @generated from field: int64 memory_mib = 5;
   */
  memoryMib: bigint;
};

/**
 * Describes the message ctrl.v1.GetDesiredDeploymentStateResponse.
 * Use `create(GetDesiredDeploymentStateResponseSchema)` to create a new message.
 */
export const GetDesiredDeploymentStateResponseSchema: GenMessage<GetDesiredDeploymentStateResponse> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 3);

/**
 * @generated from message ctrl.v1.UpdateInstanceStateRequest
 */
export type UpdateInstanceStateRequest = Message<"ctrl.v1.UpdateInstanceStateRequest"> & {
  /**
   * @generated from oneof ctrl.v1.UpdateInstanceStateRequest.change
   */
  change: {
    /**
     * @generated from field: ctrl.v1.UpdateInstanceStateRequest.Upsert upsert = 1;
     */
    value: UpdateInstanceStateRequest_Upsert;
    case: "upsert";
  } | {
    /**
     * @generated from field: ctrl.v1.UpdateInstanceStateRequest.Delete delete = 2;
     */
    value: UpdateInstanceStateRequest_Delete;
    case: "delete";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ctrl.v1.UpdateInstanceStateRequest.
 * Use `create(UpdateInstanceStateRequestSchema)` to create a new message.
 */
export const UpdateInstanceStateRequestSchema: GenMessage<UpdateInstanceStateRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 4);

/**
 * @generated from message ctrl.v1.UpdateInstanceStateRequest.Upsert
 */
export type UpdateInstanceStateRequest_Upsert = Message<"ctrl.v1.UpdateInstanceStateRequest.Upsert"> & {
  /**
   * @generated from field: string deployment_id = 1;
   */
  deploymentId: string;

  /**
   * @generated from field: string pod_name = 2;
   */
  podName: string;

  /**
   * @generated from field: string address = 3;
   */
  address: string;

  /**
   * @generated from field: int32 cpu_millicores = 4;
   */
  cpuMillicores: number;

  /**
   * @generated from field: int32 memory_mib = 5;
   */
  memoryMib: number;

  /**
   * @generated from field: ctrl.v1.UpdateInstanceStateRequest.Status status = 6;
   */
  status: UpdateInstanceStateRequest_Status;
};

/**
 * Describes the message ctrl.v1.UpdateInstanceStateRequest.Upsert.
 * Use `create(UpdateInstanceStateRequest_UpsertSchema)` to create a new message.
 */
export const UpdateInstanceStateRequest_UpsertSchema: GenMessage<UpdateInstanceStateRequest_Upsert> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 4, 0);

/**
 * @generated from message ctrl.v1.UpdateInstanceStateRequest.Delete
 */
export type UpdateInstanceStateRequest_Delete = Message<"ctrl.v1.UpdateInstanceStateRequest.Delete"> & {
  /**
   * @generated from field: string k8s_crd_name = 1;
   */
  k8sCrdName: string;

  /**
   * @generated from field: string pod_name = 2;
   */
  podName: string;
};

/**
 * Describes the message ctrl.v1.UpdateInstanceStateRequest.Delete.
 * Use `create(UpdateInstanceStateRequest_DeleteSchema)` to create a new message.
 */
export const UpdateInstanceStateRequest_DeleteSchema: GenMessage<UpdateInstanceStateRequest_Delete> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 4, 1);

/**
 * @generated from enum ctrl.v1.UpdateInstanceStateRequest.Status
 */
export enum UpdateInstanceStateRequest_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Deployment request accepted, container/pod creation in progress
   *
   * @generated from enum value: STATUS_PENDING = 1;
   */
  PENDING = 1,

  /**
   * Container/pod is running and healthy
   *
   * @generated from enum value: STATUS_RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * Container/pod failed to start
   *
   * @generated from enum value: STATUS_FAILED = 3;
   */
  FAILED = 3,
}

/**
 * Describes the enum ctrl.v1.UpdateInstanceStateRequest.Status.
 */
export const UpdateInstanceStateRequest_StatusSchema: GenEnum<UpdateInstanceStateRequest_Status> = /*@__PURE__*/
  enumDesc(file_ctrl_v1_cluster, 4, 0);

/**
 * @generated from message ctrl.v1.UpdateInstanceStateResponse
 */
export type UpdateInstanceStateResponse = Message<"ctrl.v1.UpdateInstanceStateResponse"> & {
};

/**
 * Describes the message ctrl.v1.UpdateInstanceStateResponse.
 * Use `create(UpdateInstanceStateResponseSchema)` to create a new message.
 */
export const UpdateInstanceStateResponseSchema: GenMessage<UpdateInstanceStateResponse> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 5);

/**
 * @generated from message ctrl.v1.UpdateSentinelStateRequest
 */
export type UpdateSentinelStateRequest = Message<"ctrl.v1.UpdateSentinelStateRequest"> & {
  /**
   * @generated from field: string k8s_crd_name = 1;
   */
  k8sCrdName: string;

  /**
   * @generated from field: int32 running_replicas = 2;
   */
  runningReplicas: number;
};

/**
 * Describes the message ctrl.v1.UpdateSentinelStateRequest.
 * Use `create(UpdateSentinelStateRequestSchema)` to create a new message.
 */
export const UpdateSentinelStateRequestSchema: GenMessage<UpdateSentinelStateRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 6);

/**
 * @generated from message ctrl.v1.UpdateSentinelStateResponse
 */
export type UpdateSentinelStateResponse = Message<"ctrl.v1.UpdateSentinelStateResponse"> & {
};

/**
 * Describes the message ctrl.v1.UpdateSentinelStateResponse.
 * Use `create(UpdateSentinelStateResponseSchema)` to create a new message.
 */
export const UpdateSentinelStateResponseSchema: GenMessage<UpdateSentinelStateResponse> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 7);

/**
 * WatchRequest identifies the cluster requesting a watch stream.
 *
 * @generated from message ctrl.v1.WatchRequest
 */
export type WatchRequest = Message<"ctrl.v1.WatchRequest"> & {
  /**
   * client_id uniquely identifies the client requesting the watch stream.
   *
   * @generated from field: string client_id = 1;
   */
  clientId: string;

  /**
   * labels to match events for
   * typically regions are used
   * [region]: aws:us-east-1
   *
   * The server must only send events where all labels match the selector.
   *
   * @generated from field: map<string, string> selectors = 2;
   */
  selectors: { [key: string]: string };

  /**
   * live indicates whether the client wants live updates of changes
   * if true, the stream never ends
   *
   * @generated from field: bool live = 3;
   */
  live: boolean;

  /**
   * synthetic indicates whether the client wants synthetic events
   * if true, the server generates synthetic events to replay the full current desired state.
   *
   * @generated from field: bool synthetic = 4;
   */
  synthetic: boolean;
};

/**
 * Describes the message ctrl.v1.WatchRequest.
 * Use `create(WatchRequestSchema)` to create a new message.
 */
export const WatchRequestSchema: GenMessage<WatchRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 8);

/**
 * SentinelEvent represents a lifecycle event for an API sentinel configuration.
 *
 * Sentinels are frontline points for services, typically handling routing, load balancing,
 * and API management. The event follows a declarative model where the cluster agent ensures
 * the cluster state matches the desired configuration.
 *
 * @generated from message ctrl.v1.SentinelEvent
 */
export type SentinelEvent = Message<"ctrl.v1.SentinelEvent"> & {
  /**
   * event contains the specific sentinel operation to perform.
   * Only one event type is set per message, determining the action the agent should take.
   *
   * @generated from oneof ctrl.v1.SentinelEvent.event
   */
  event: {
    /**
     * apply indicates the sentinel should exist with this configuration.
     * The agent will create the sentinel if it doesn't exist or update it if it does.
     * This follows the same semantics as "kubectl apply" - declare desired state
     * and let the agent determine the appropriate action.
     *
     * @generated from field: ctrl.v1.ApplySentinel apply = 1;
     */
    value: ApplySentinel;
    case: "apply";
  } | {
    /**
     * delete indicates the sentinel should be removed from the cluster.
     *
     * @generated from field: ctrl.v1.DeleteSentinel delete = 2;
     */
    value: DeleteSentinel;
    case: "delete";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ctrl.v1.SentinelEvent.
 * Use `create(SentinelEventSchema)` to create a new message.
 */
export const SentinelEventSchema: GenMessage<SentinelEvent> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 9);

/**
 * DeploymentEvent represents a lifecycle event for an application deployment.
 *
 * Deployments are the primary workload type, representing stateless applications
 * that can be scaled horizontally. The event follows a declarative model where
 * the cluster agent ensures the cluster state matches the desired configuration.
 *
 * @generated from message ctrl.v1.DeploymentEvent
 */
export type DeploymentEvent = Message<"ctrl.v1.DeploymentEvent"> & {
  /**
   * event contains the specific deployment operation to perform.
   * Only one event type is set per message, determining the action the agent should take.
   *
   * @generated from oneof ctrl.v1.DeploymentEvent.event
   */
  event: {
    /**
     * apply indicates the deployment should exist with this configuration.
     * The agent will create the deployment if it doesn't exist or update it if it does.
     * This follows the same semantics as "kubectl apply" - declare desired state
     * and let the agent determine the appropriate action.
     *
     * @generated from field: ctrl.v1.ApplyDeployment apply = 1;
     */
    value: ApplyDeployment;
    case: "apply";
  } | {
    /**
     * delete indicates the deployment should be removed from the cluster.
     *
     * @generated from field: ctrl.v1.DeleteDeployment delete = 2;
     */
    value: DeleteDeployment;
    case: "delete";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ctrl.v1.DeploymentEvent.
 * Use `create(DeploymentEventSchema)` to create a new message.
 */
export const DeploymentEventSchema: GenMessage<DeploymentEvent> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 10);

/**
 * ApplySentinel contains the desired configuration for a sentinel.
 *
 * The cluster agent will ensure a sentinel exists with this exact configuration, creating it if
 * it doesn't exist or updating it if it does. All fields except namespace are required.
 * The control plane ensures that sentinel_id is unique within the namespace.
 *
 * @generated from message ctrl.v1.ApplySentinel
 */
export type ApplySentinel = Message<"ctrl.v1.ApplySentinel"> & {
  /**
   * namespace is the Kubernetes namespace in which the sentinel should exist.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string k8s_crd_name = 2;
   */
  k8sCrdName: string;

  /**
   * workspace_id identifies the workspace that owns this sentinel.
   *
   * @generated from field: string workspace_id = 3;
   */
  workspaceId: string;

  /**
   * project_id identifies the project within the workspace.
   *
   * @generated from field: string project_id = 4;
   */
  projectId: string;

  /**
   * environment_id in which the sentinel should exist.
   *
   * @generated from field: string environment_id = 5;
   */
  environmentId: string;

  /**
   * sentinel_id is the unique identifier for this sentinel within the namespace.
   *
   * @generated from field: string sentinel_id = 6;
   */
  sentinelId: string;

  /**
   * hash is a checksum of the sentinel configuration used to detect changes.
   *
   * @generated from field: string hash = 7;
   */
  hash: string;
};

/**
 * Describes the message ctrl.v1.ApplySentinel.
 * Use `create(ApplySentinelSchema)` to create a new message.
 */
export const ApplySentinelSchema: GenMessage<ApplySentinel> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 11);

/**
 * DeleteSentinel identifies a sentinel to remove from the cluster.
 *
 * The sentinel and all its resources (pods, services, frontline) will be deleted.
 * In-flight requests may be disrupted unless proper connection draining is configured.
 *
 * @generated from message ctrl.v1.DeleteSentinel
 */
export type DeleteSentinel = Message<"ctrl.v1.DeleteSentinel"> & {
  /**
   * sentinel_id identifies the sentinel to delete.
   * All resources with this sentinel_id in the namespace will be removed.
   *
   * @generated from field: string sentinel_id = 1;
   */
  sentinelId: string;
};

/**
 * Describes the message ctrl.v1.DeleteSentinel.
 * Use `create(DeleteSentinelSchema)` to create a new message.
 */
export const DeleteSentinelSchema: GenMessage<DeleteSentinel> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 12);

/**
 * ApplyDeployment contains the desired configuration for a deployment.
 *
 * The cluster agent will ensure a deployment exists with this exact configuration, creating it if
 * it doesn't exist or updating it if it does. All fields except namespace are required.
 * The control plane ensures that deployment_id is unique within the namespace.
 *
 * @generated from message ctrl.v1.ApplyDeployment
 */
export type ApplyDeployment = Message<"ctrl.v1.ApplyDeployment"> & {
  /**
   * namespace is the Kubernetes namespace in which the deployment should exist.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string k8s_crd_name = 2;
   */
  k8sCrdName: string;

  /**
   * workspace_id identifies the workspace that owns this deployment.
   * Used for multi-tenancy and access control.
   *
   * @generated from field: string workspace_id = 3;
   */
  workspaceId: string;

  /**
   * project_id identifies the project within the workspace.
   * Deployments are scoped to projects for organizational purposes.
   *
   * @generated from field: string project_id = 4;
   */
  projectId: string;

  /**
   * environment_id specifies the environment .
   * Used for environment-specific configuration and isolation.
   *
   * @generated from field: string environment_id = 5;
   */
  environmentId: string;

  /**
   * deployment_id is the unique identifier for this deployment within the namespace.
   *
   * @generated from field: string deployment_id = 6;
   */
  deploymentId: string;

  /**
   * image is the container image to deploy.
   * Must be a valid container registry URL accessible by the cluster.
   * Example: "gcr.io/myproject/app:v2.1.0"
   *
   * @generated from field: string image = 7;
   */
  image: string;

  /**
   * replicas is the desired number of pod instances.
   * Must be at least 1. Set higher for increased availability and load distribution.
   *
   * @generated from field: uint32 replicas = 8;
   */
  replicas: number;

  /**
   * cpu_millicores is the CPU request/limit in millicores (1000 = 1 CPU core).
   * This ensures each pod has sufficient CPU resources.
   * Example: 250 = 0.25 CPU cores
   *
   * @generated from field: uint32 cpu_millicores = 9;
   */
  cpuMillicores: number;

  /**
   * memory_size_mib is the memory request/limit in mebibytes.
   * This ensures each pod has sufficient memory.
   * Example: 256 = 256 MiB
   *
   * @generated from field: uint32 memory_size_mib = 10;
   */
  memorySizeMib: number;
};

/**
 * Describes the message ctrl.v1.ApplyDeployment.
 * Use `create(ApplyDeploymentSchema)` to create a new message.
 */
export const ApplyDeploymentSchema: GenMessage<ApplyDeployment> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 13);

/**
 * DeleteDeployment identifies a deployment to remove from the cluster.
 *
 * The deployment and all its pods will be terminated gracefully according to
 * the configured termination grace period. All associated resources (services,
 * configmaps specific to this deployment) will also be cleaned up.
 *
 * @generated from message ctrl.v1.DeleteDeployment
 */
export type DeleteDeployment = Message<"ctrl.v1.DeleteDeployment"> & {
  /**
   * deployment_id identifies the deployment to delete.
   * All resources with this deployment_id in the namespace will be removed.
   *
   * @generated from field: string deployment_id = 1;
   */
  deploymentId: string;
};

/**
 * Describes the message ctrl.v1.DeleteDeployment.
 * Use `create(DeleteDeploymentSchema)` to create a new message.
 */
export const DeleteDeploymentSchema: GenMessage<DeleteDeployment> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 14);

/**
 * ClusterService coordinates deployment and sentinel configurations across multiple clusters.
 *
 * Agents in each cluster establish a watch stream to receive configuration events
 * from the control plane. The service streams deployment and sentinel lifecycle events
 * (apply, delete) to the appropriate clusters based on their cluster_id and region.
 *
 * The watch connection is designed to be long-lived with automatic reconnection on failure.
 * When an agent reconnects, it should initiate reconciliation to ensure consistency.
 *
 * @generated from service ctrl.v1.ClusterService
 */
export const ClusterService: GenService<{
  /**
   * @generated from rpc ctrl.v1.ClusterService.WatchSentinels
   */
  watchSentinels: {
    methodKind: "server_streaming";
    input: typeof WatchRequestSchema;
    output: typeof SentinelEventSchema;
  },
  /**
   * @generated from rpc ctrl.v1.ClusterService.GetDesiredSentinelState
   */
  getDesiredSentinelState: {
    methodKind: "unary";
    input: typeof GetDesiredSentinelStateRequestSchema;
    output: typeof GetDesiredSentinelStateResponseSchema;
  },
  /**
   * @generated from rpc ctrl.v1.ClusterService.UpdateSentinelState
   */
  updateSentinelState: {
    methodKind: "unary";
    input: typeof UpdateSentinelStateRequestSchema;
    output: typeof UpdateSentinelStateResponseSchema;
  },
  /**
   * @generated from rpc ctrl.v1.ClusterService.WatchDeployments
   */
  watchDeployments: {
    methodKind: "server_streaming";
    input: typeof WatchRequestSchema;
    output: typeof DeploymentEventSchema;
  },
  /**
   * @generated from rpc ctrl.v1.ClusterService.GetDesiredDeploymentState
   */
  getDesiredDeploymentState: {
    methodKind: "unary";
    input: typeof GetDesiredDeploymentStateRequestSchema;
    output: typeof GetDesiredDeploymentStateResponseSchema;
  },
  /**
   * @generated from rpc ctrl.v1.ClusterService.UpdateInstanceState
   */
  updateInstanceState: {
    methodKind: "unary";
    input: typeof UpdateInstanceStateRequestSchema;
    output: typeof UpdateInstanceStateResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_ctrl_v1_cluster, 0);

