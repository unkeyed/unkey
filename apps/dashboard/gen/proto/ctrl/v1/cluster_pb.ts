// @generated by protoc-gen-es v2.8.0 with parameter "target=ts"
// @generated from file ctrl/v1/cluster.proto (package ctrl.v1, syntax proto3)
/* eslint-disable */

// Package ctrl.v1 provides the Cluster service for multi-cluster deployment orchestration.
//
// The Cluster service enables a central control plane to coordinate deployments and gateways
// across multiple Kubernetes clusters. Each cluster runs an agent (such as krane) that establishes
// a long-lived watch connection to receive deployment and gateway configuration events.
//
// This design follows the Kubernetes watch pattern where agents (like kubelet) maintain
// a streaming connection to receive incremental updates, enabling real-time deployment
// orchestration across distributed clusters.

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file ctrl/v1/cluster.proto.
 */
export const file_ctrl_v1_cluster: GenFile = /*@__PURE__*/
  fileDesc("ChVjdHJsL3YxL2NsdXN0ZXIucHJvdG8SB2N0cmwudjEiMwodR2V0RGVzaXJlZEdhdGV3YXlTdGF0ZVJlcXVlc3QSEgoKZ2F0ZXdheV9pZBgBIAEoCSI5CiBHZXREZXNpcmVkRGVwbG95bWVudFN0YXRlUmVxdWVzdBIVCg1kZXBsb3ltZW50X2lkGAEgASgJIhgKFkRlbGV0ZUluc3RhbmNlUmVzcG9uc2Ui7gQKFVVwZGF0ZUluc3RhbmNlUmVxdWVzdBI3CgZjcmVhdGUYASABKAsyJS5jdHJsLnYxLlVwZGF0ZUluc3RhbmNlUmVxdWVzdC5DcmVhdGVIABI3CgZ1cGRhdGUYAiABKAsyJS5jdHJsLnYxLlVwZGF0ZUluc3RhbmNlUmVxdWVzdC5VcGRhdGVIABI3CgZkZWxldGUYAyABKAsyJS5jdHJsLnYxLlVwZGF0ZUluc3RhbmNlUmVxdWVzdC5EZWxldGVIABqlAQoGQ3JlYXRlEhUKDWRlcGxveW1lbnRfaWQYASABKAkSEAoIcG9kX25hbWUYAiABKAkSDwoHYWRkcmVzcxgDIAEoCRIWCg5jcHVfbWlsbGljb3JlcxgEIAEoBRISCgptZW1vcnlfbWliGAUgASgFEjUKBnN0YXR1cxgGIAEoDjIlLmN0cmwudjEuVXBkYXRlSW5zdGFuY2VSZXF1ZXN0LlN0YXR1cxpoCgZVcGRhdGUSFQoNZGVwbG95bWVudF9pZBgBIAEoCRIQCghwb2RfbmFtZRgCIAEoCRI1CgZzdGF0dXMYAyABKA4yJS5jdHJsLnYxLlVwZGF0ZUluc3RhbmNlUmVxdWVzdC5TdGF0dXMaMQoGRGVsZXRlEhUKDWRlcGxveW1lbnRfaWQYASABKAkSEAoIcG9kX25hbWUYAiABKAkiWwoGU3RhdHVzEhYKElNUQVRVU19VTlNQRUNJRklFRBAAEhIKDlNUQVRVU19QRU5ESU5HEAESEgoOU1RBVFVTX1JVTk5JTkcQAhIRCg1TVEFUVVNfRkFJTEVEEANCCAoGY2hhbmdlIhgKFlVwZGF0ZUluc3RhbmNlUmVzcG9uc2Ui1gIKFFVwZGF0ZUdhdGV3YXlSZXF1ZXN0EjYKBmNyZWF0ZRgBIAEoCzIkLmN0cmwudjEuVXBkYXRlR2F0ZXdheVJlcXVlc3QuQ3JlYXRlSAASNgoGdXBkYXRlGAIgASgLMiQuY3RybC52MS5VcGRhdGVHYXRld2F5UmVxdWVzdC5VcGRhdGVIABI2CgZkZWxldGUYAyABKAsyJC5jdHJsLnYxLlVwZGF0ZUdhdGV3YXlSZXF1ZXN0LkRlbGV0ZUgAGjYKBkNyZWF0ZRISCgpnYXRld2F5X2lkGAEgASgJEhgKEHJ1bm5pbmdfcmVwbGljYXMYAiABKAUaNgoGVXBkYXRlEhIKCmdhdGV3YXlfaWQYASABKAkSGAoQcnVubmluZ19yZXBsaWNhcxgCIAEoBRocCgZEZWxldGUSEgoKZ2F0ZXdheV9pZBgBIAEoCUIICgZjaGFuZ2UiFwoVVXBkYXRlR2F0ZXdheVJlc3BvbnNlIowBCgxXYXRjaFJlcXVlc3QSEQoJY2xpZW50X2lkGAEgASgJEjcKCXNlbGVjdG9ycxgCIAMoCzIkLmN0cmwudjEuV2F0Y2hSZXF1ZXN0LlNlbGVjdG9yc0VudHJ5GjAKDlNlbGVjdG9yc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEioAEKFkdldERlc2lyZWRTdGF0ZVJlcXVlc3QSEQoJY2xpZW50X2lkGAEgASgJEkEKCXNlbGVjdG9ycxgCIAMoCzIuLmN0cmwudjEuR2V0RGVzaXJlZFN0YXRlUmVxdWVzdC5TZWxlY3RvcnNFbnRyeRowCg5TZWxlY3RvcnNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBImkKDEdhdGV3YXlFdmVudBImCgVhcHBseRgBIAEoCzIVLmN0cmwudjEuQXBwbHlHYXRld2F5SAASKAoGZGVsZXRlGAIgASgLMhYuY3RybC52MS5EZWxldGVHYXRld2F5SABCBwoFZXZlbnQicgoPRGVwbG95bWVudEV2ZW50EikKBWFwcGx5GAEgASgLMhguY3RybC52MS5BcHBseURlcGxveW1lbnRIABIrCgZkZWxldGUYAiABKAsyGS5jdHJsLnYxLkRlbGV0ZURlcGxveW1lbnRIAEIHCgVldmVudCLfAQoMQXBwbHlHYXRld2F5EhEKCW5hbWVzcGFjZRgBIAEoCRIUCgxrOHNfY3JkX25hbWUYAiABKAkSFAoMd29ya3NwYWNlX2lkGAMgASgJEhIKCnByb2plY3RfaWQYBCABKAkSFgoOZW52aXJvbm1lbnRfaWQYBSABKAkSEgoKZ2F0ZXdheV9pZBgGIAEoCRINCgVpbWFnZRgHIAEoCRIQCghyZXBsaWNhcxgIIAEoDRIWCg5jcHVfbWlsbGljb3JlcxgJIAEoDRIXCg9tZW1vcnlfc2l6ZV9taWIYCiABKA0iIwoNRGVsZXRlR2F0ZXdheRISCgpnYXRld2F5X2lkGAEgASgJIs8BCg9BcHBseURlcGxveW1lbnQSEQoJbmFtZXNwYWNlGAEgASgJEhQKDHdvcmtzcGFjZV9pZBgCIAEoCRISCgpwcm9qZWN0X2lkGAMgASgJEhYKDmVudmlyb25tZW50X2lkGAQgASgJEhUKDWRlcGxveW1lbnRfaWQYBSABKAkSDQoFaW1hZ2UYBiABKAkSEAoIcmVwbGljYXMYByABKA0SFgoOY3B1X21pbGxpY29yZXMYCCABKA0SFwoPbWVtb3J5X3NpemVfbWliGAkgASgNIikKEERlbGV0ZURlcGxveW1lbnQSFQoNZGVwbG95bWVudF9pZBgBIAEoCSJ7CgpJbmZyYUV2ZW50Ei4KDWdhdGV3YXlfZXZlbnQYAiABKAsyFS5jdHJsLnYxLkdhdGV3YXlFdmVudEgAEjQKEGRlcGxveW1lbnRfZXZlbnQYAyABKAsyGC5jdHJsLnYxLkRlcGxveW1lbnRFdmVudEgAQgcKBWV2ZW50MvADCg5DbHVzdGVyU2VydmljZRI1CgVXYXRjaBIVLmN0cmwudjEuV2F0Y2hSZXF1ZXN0GhMuY3RybC52MS5JbmZyYUV2ZW50MAESSQoPR2V0RGVzaXJlZFN0YXRlEh8uY3RybC52MS5HZXREZXNpcmVkU3RhdGVSZXF1ZXN0GhMuY3RybC52MS5JbmZyYUV2ZW50MAESYAoZR2V0RGVzaXJlZERlcGxveW1lbnRTdGF0ZRIpLmN0cmwudjEuR2V0RGVzaXJlZERlcGxveW1lbnRTdGF0ZVJlcXVlc3QaGC5jdHJsLnYxLkRlcGxveW1lbnRFdmVudBJXChZHZXREZXNpcmVkR2F0ZXdheVN0YXRlEiYuY3RybC52MS5HZXREZXNpcmVkR2F0ZXdheVN0YXRlUmVxdWVzdBoVLmN0cmwudjEuR2F0ZXdheUV2ZW50ElEKDlVwZGF0ZUluc3RhbmNlEh4uY3RybC52MS5VcGRhdGVJbnN0YW5jZVJlcXVlc3QaHy5jdHJsLnYxLlVwZGF0ZUluc3RhbmNlUmVzcG9uc2USTgoNVXBkYXRlR2F0ZXdheRIdLmN0cmwudjEuVXBkYXRlR2F0ZXdheVJlcXVlc3QaHi5jdHJsLnYxLlVwZGF0ZUdhdGV3YXlSZXNwb25zZUKOAQoLY29tLmN0cmwudjFCDENsdXN0ZXJQcm90b1ABWjRnaXRodWIuY29tL3Vua2V5ZWQvdW5rZXkvZ28vZ2VuL3Byb3RvL2N0cmwvdjE7Y3RybHYxogIDQ1hYqgIHQ3RybC5WMcoCB0N0cmxcVjHiAhNDdHJsXFYxXEdQQk1ldGFkYXRh6gIIQ3RybDo6VjFiBnByb3RvMw");

/**
 * @generated from message ctrl.v1.GetDesiredGatewayStateRequest
 */
export type GetDesiredGatewayStateRequest = Message<"ctrl.v1.GetDesiredGatewayStateRequest"> & {
  /**
   * @generated from field: string gateway_id = 1;
   */
  gatewayId: string;
};

/**
 * Describes the message ctrl.v1.GetDesiredGatewayStateRequest.
 * Use `create(GetDesiredGatewayStateRequestSchema)` to create a new message.
 */
export const GetDesiredGatewayStateRequestSchema: GenMessage<GetDesiredGatewayStateRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 0);

/**
 * @generated from message ctrl.v1.GetDesiredDeploymentStateRequest
 */
export type GetDesiredDeploymentStateRequest = Message<"ctrl.v1.GetDesiredDeploymentStateRequest"> & {
  /**
   * @generated from field: string deployment_id = 1;
   */
  deploymentId: string;
};

/**
 * Describes the message ctrl.v1.GetDesiredDeploymentStateRequest.
 * Use `create(GetDesiredDeploymentStateRequestSchema)` to create a new message.
 */
export const GetDesiredDeploymentStateRequestSchema: GenMessage<GetDesiredDeploymentStateRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 1);

/**
 * @generated from message ctrl.v1.DeleteInstanceResponse
 */
export type DeleteInstanceResponse = Message<"ctrl.v1.DeleteInstanceResponse"> & {
};

/**
 * Describes the message ctrl.v1.DeleteInstanceResponse.
 * Use `create(DeleteInstanceResponseSchema)` to create a new message.
 */
export const DeleteInstanceResponseSchema: GenMessage<DeleteInstanceResponse> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 2);

/**
 * @generated from message ctrl.v1.UpdateInstanceRequest
 */
export type UpdateInstanceRequest = Message<"ctrl.v1.UpdateInstanceRequest"> & {
  /**
   * @generated from oneof ctrl.v1.UpdateInstanceRequest.change
   */
  change: {
    /**
     * @generated from field: ctrl.v1.UpdateInstanceRequest.Create create = 1;
     */
    value: UpdateInstanceRequest_Create;
    case: "create";
  } | {
    /**
     * @generated from field: ctrl.v1.UpdateInstanceRequest.Update update = 2;
     */
    value: UpdateInstanceRequest_Update;
    case: "update";
  } | {
    /**
     * @generated from field: ctrl.v1.UpdateInstanceRequest.Delete delete = 3;
     */
    value: UpdateInstanceRequest_Delete;
    case: "delete";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ctrl.v1.UpdateInstanceRequest.
 * Use `create(UpdateInstanceRequestSchema)` to create a new message.
 */
export const UpdateInstanceRequestSchema: GenMessage<UpdateInstanceRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 3);

/**
 * @generated from message ctrl.v1.UpdateInstanceRequest.Create
 */
export type UpdateInstanceRequest_Create = Message<"ctrl.v1.UpdateInstanceRequest.Create"> & {
  /**
   * @generated from field: string deployment_id = 1;
   */
  deploymentId: string;

  /**
   * @generated from field: string pod_name = 2;
   */
  podName: string;

  /**
   * @generated from field: string address = 3;
   */
  address: string;

  /**
   * @generated from field: int32 cpu_millicores = 4;
   */
  cpuMillicores: number;

  /**
   * @generated from field: int32 memory_mib = 5;
   */
  memoryMib: number;

  /**
   * @generated from field: ctrl.v1.UpdateInstanceRequest.Status status = 6;
   */
  status: UpdateInstanceRequest_Status;
};

/**
 * Describes the message ctrl.v1.UpdateInstanceRequest.Create.
 * Use `create(UpdateInstanceRequest_CreateSchema)` to create a new message.
 */
export const UpdateInstanceRequest_CreateSchema: GenMessage<UpdateInstanceRequest_Create> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 3, 0);

/**
 * @generated from message ctrl.v1.UpdateInstanceRequest.Update
 */
export type UpdateInstanceRequest_Update = Message<"ctrl.v1.UpdateInstanceRequest.Update"> & {
  /**
   * @generated from field: string deployment_id = 1;
   */
  deploymentId: string;

  /**
   * @generated from field: string pod_name = 2;
   */
  podName: string;

  /**
   * @generated from field: ctrl.v1.UpdateInstanceRequest.Status status = 3;
   */
  status: UpdateInstanceRequest_Status;
};

/**
 * Describes the message ctrl.v1.UpdateInstanceRequest.Update.
 * Use `create(UpdateInstanceRequest_UpdateSchema)` to create a new message.
 */
export const UpdateInstanceRequest_UpdateSchema: GenMessage<UpdateInstanceRequest_Update> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 3, 1);

/**
 * @generated from message ctrl.v1.UpdateInstanceRequest.Delete
 */
export type UpdateInstanceRequest_Delete = Message<"ctrl.v1.UpdateInstanceRequest.Delete"> & {
  /**
   * @generated from field: string deployment_id = 1;
   */
  deploymentId: string;

  /**
   * @generated from field: string pod_name = 2;
   */
  podName: string;
};

/**
 * Describes the message ctrl.v1.UpdateInstanceRequest.Delete.
 * Use `create(UpdateInstanceRequest_DeleteSchema)` to create a new message.
 */
export const UpdateInstanceRequest_DeleteSchema: GenMessage<UpdateInstanceRequest_Delete> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 3, 2);

/**
 * @generated from enum ctrl.v1.UpdateInstanceRequest.Status
 */
export enum UpdateInstanceRequest_Status {
  /**
   * @generated from enum value: STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Deployment request accepted, container/pod creation in progress
   *
   * @generated from enum value: STATUS_PENDING = 1;
   */
  PENDING = 1,

  /**
   * Container/pod is running and healthy
   *
   * @generated from enum value: STATUS_RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * Container/pod failed to start
   *
   * @generated from enum value: STATUS_FAILED = 3;
   */
  FAILED = 3,
}

/**
 * Describes the enum ctrl.v1.UpdateInstanceRequest.Status.
 */
export const UpdateInstanceRequest_StatusSchema: GenEnum<UpdateInstanceRequest_Status> = /*@__PURE__*/
  enumDesc(file_ctrl_v1_cluster, 3, 0);

/**
 * @generated from message ctrl.v1.UpdateInstanceResponse
 */
export type UpdateInstanceResponse = Message<"ctrl.v1.UpdateInstanceResponse"> & {
};

/**
 * Describes the message ctrl.v1.UpdateInstanceResponse.
 * Use `create(UpdateInstanceResponseSchema)` to create a new message.
 */
export const UpdateInstanceResponseSchema: GenMessage<UpdateInstanceResponse> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 4);

/**
 * @generated from message ctrl.v1.UpdateGatewayRequest
 */
export type UpdateGatewayRequest = Message<"ctrl.v1.UpdateGatewayRequest"> & {
  /**
   * @generated from oneof ctrl.v1.UpdateGatewayRequest.change
   */
  change: {
    /**
     * @generated from field: ctrl.v1.UpdateGatewayRequest.Create create = 1;
     */
    value: UpdateGatewayRequest_Create;
    case: "create";
  } | {
    /**
     * @generated from field: ctrl.v1.UpdateGatewayRequest.Update update = 2;
     */
    value: UpdateGatewayRequest_Update;
    case: "update";
  } | {
    /**
     * @generated from field: ctrl.v1.UpdateGatewayRequest.Delete delete = 3;
     */
    value: UpdateGatewayRequest_Delete;
    case: "delete";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ctrl.v1.UpdateGatewayRequest.
 * Use `create(UpdateGatewayRequestSchema)` to create a new message.
 */
export const UpdateGatewayRequestSchema: GenMessage<UpdateGatewayRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 5);

/**
 * @generated from message ctrl.v1.UpdateGatewayRequest.Create
 */
export type UpdateGatewayRequest_Create = Message<"ctrl.v1.UpdateGatewayRequest.Create"> & {
  /**
   * @generated from field: string gateway_id = 1;
   */
  gatewayId: string;

  /**
   * @generated from field: int32 running_replicas = 2;
   */
  runningReplicas: number;
};

/**
 * Describes the message ctrl.v1.UpdateGatewayRequest.Create.
 * Use `create(UpdateGatewayRequest_CreateSchema)` to create a new message.
 */
export const UpdateGatewayRequest_CreateSchema: GenMessage<UpdateGatewayRequest_Create> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 5, 0);

/**
 * @generated from message ctrl.v1.UpdateGatewayRequest.Update
 */
export type UpdateGatewayRequest_Update = Message<"ctrl.v1.UpdateGatewayRequest.Update"> & {
  /**
   * @generated from field: string gateway_id = 1;
   */
  gatewayId: string;

  /**
   * @generated from field: int32 running_replicas = 2;
   */
  runningReplicas: number;
};

/**
 * Describes the message ctrl.v1.UpdateGatewayRequest.Update.
 * Use `create(UpdateGatewayRequest_UpdateSchema)` to create a new message.
 */
export const UpdateGatewayRequest_UpdateSchema: GenMessage<UpdateGatewayRequest_Update> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 5, 1);

/**
 * @generated from message ctrl.v1.UpdateGatewayRequest.Delete
 */
export type UpdateGatewayRequest_Delete = Message<"ctrl.v1.UpdateGatewayRequest.Delete"> & {
  /**
   * @generated from field: string gateway_id = 1;
   */
  gatewayId: string;
};

/**
 * Describes the message ctrl.v1.UpdateGatewayRequest.Delete.
 * Use `create(UpdateGatewayRequest_DeleteSchema)` to create a new message.
 */
export const UpdateGatewayRequest_DeleteSchema: GenMessage<UpdateGatewayRequest_Delete> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 5, 2);

/**
 * @generated from message ctrl.v1.UpdateGatewayResponse
 */
export type UpdateGatewayResponse = Message<"ctrl.v1.UpdateGatewayResponse"> & {
};

/**
 * Describes the message ctrl.v1.UpdateGatewayResponse.
 * Use `create(UpdateGatewayResponseSchema)` to create a new message.
 */
export const UpdateGatewayResponseSchema: GenMessage<UpdateGatewayResponse> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 6);

/**
 * WatchRequest identifies the cluster requesting a watch stream.
 *
 * @generated from message ctrl.v1.WatchRequest
 */
export type WatchRequest = Message<"ctrl.v1.WatchRequest"> & {
  /**
   * client_id uniquely identifies the client requesting the watch stream.
   *
   * @generated from field: string client_id = 1;
   */
  clientId: string;

  /**
   * labels to match events for
   * typically regions are used
   * [region]: aws:us-east-1
   *
   * The server must only send events where all labels match the selector.
   *
   * @generated from field: map<string, string> selectors = 2;
   */
  selectors: { [key: string]: string };
};

/**
 * Describes the message ctrl.v1.WatchRequest.
 * Use `create(WatchRequestSchema)` to create a new message.
 */
export const WatchRequestSchema: GenMessage<WatchRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 7);

/**
 * GetDesiredStateRequest identifies the cluster requesting a full sync stream.
 *
 * @generated from message ctrl.v1.GetDesiredStateRequest
 */
export type GetDesiredStateRequest = Message<"ctrl.v1.GetDesiredStateRequest"> & {
  /**
   * client_id uniquely identifies the client requesting the sync stream.
   *
   * @generated from field: string client_id = 1;
   */
  clientId: string;

  /**
   * labels to match events for
   * typically regions are used
   * [region]: aws:us-east-1
   *
   * The server must only send infrastructure configs where all labels match the selector.
   *
   * @generated from field: map<string, string> selectors = 2;
   */
  selectors: { [key: string]: string };
};

/**
 * Describes the message ctrl.v1.GetDesiredStateRequest.
 * Use `create(GetDesiredStateRequestSchema)` to create a new message.
 */
export const GetDesiredStateRequestSchema: GenMessage<GetDesiredStateRequest> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 8);

/**
 * GatewayEvent represents a lifecycle event for an API gateway configuration.
 *
 * Gateways are ingress points for services, typically handling routing, load balancing,
 * and API management. The event follows a declarative model where the cluster agent ensures
 * the cluster state matches the desired configuration.
 *
 * @generated from message ctrl.v1.GatewayEvent
 */
export type GatewayEvent = Message<"ctrl.v1.GatewayEvent"> & {
  /**
   * event contains the specific gateway operation to perform.
   * Only one event type is set per message, determining the action the agent should take.
   *
   * @generated from oneof ctrl.v1.GatewayEvent.event
   */
  event: {
    /**
     * apply indicates the gateway should exist with this configuration.
     * The agent will create the gateway if it doesn't exist or update it if it does.
     * This follows the same semantics as "kubectl apply" - declare desired state
     * and let the agent determine the appropriate action.
     *
     * @generated from field: ctrl.v1.ApplyGateway apply = 1;
     */
    value: ApplyGateway;
    case: "apply";
  } | {
    /**
     * delete indicates the gateway should be removed from the cluster.
     *
     * @generated from field: ctrl.v1.DeleteGateway delete = 2;
     */
    value: DeleteGateway;
    case: "delete";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ctrl.v1.GatewayEvent.
 * Use `create(GatewayEventSchema)` to create a new message.
 */
export const GatewayEventSchema: GenMessage<GatewayEvent> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 9);

/**
 * DeploymentEvent represents a lifecycle event for an application deployment.
 *
 * Deployments are the primary workload type, representing stateless applications
 * that can be scaled horizontally. The event follows a declarative model where
 * the cluster agent ensures the cluster state matches the desired configuration.
 *
 * @generated from message ctrl.v1.DeploymentEvent
 */
export type DeploymentEvent = Message<"ctrl.v1.DeploymentEvent"> & {
  /**
   * event contains the specific deployment operation to perform.
   * Only one event type is set per message, determining the action the agent should take.
   *
   * @generated from oneof ctrl.v1.DeploymentEvent.event
   */
  event: {
    /**
     * apply indicates the deployment should exist with this configuration.
     * The agent will create the deployment if it doesn't exist or update it if it does.
     * This follows the same semantics as "kubectl apply" - declare desired state
     * and let the agent determine the appropriate action.
     *
     * @generated from field: ctrl.v1.ApplyDeployment apply = 1;
     */
    value: ApplyDeployment;
    case: "apply";
  } | {
    /**
     * delete indicates the deployment should be removed from the cluster.
     *
     * @generated from field: ctrl.v1.DeleteDeployment delete = 2;
     */
    value: DeleteDeployment;
    case: "delete";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ctrl.v1.DeploymentEvent.
 * Use `create(DeploymentEventSchema)` to create a new message.
 */
export const DeploymentEventSchema: GenMessage<DeploymentEvent> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 10);

/**
 * ApplyGateway contains the desired configuration for a gateway.
 *
 * The cluster agent will ensure a gateway exists with this exact configuration, creating it if
 * it doesn't exist or updating it if it does. All fields except namespace are required.
 * The control plane ensures that gateway_id is unique within the namespace.
 *
 * @generated from message ctrl.v1.ApplyGateway
 */
export type ApplyGateway = Message<"ctrl.v1.ApplyGateway"> & {
  /**
   * namespace is the Kubernetes namespace in which the gateway should exist.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * @generated from field: string k8s_crd_name = 2;
   */
  k8sCrdName: string;

  /**
   * workspace_id identifies the workspace that owns this gateway.
   *
   * @generated from field: string workspace_id = 3;
   */
  workspaceId: string;

  /**
   * project_id identifies the project within the workspace.
   *
   * @generated from field: string project_id = 4;
   */
  projectId: string;

  /**
   * environment_id in which the gateway should exist.
   *
   * @generated from field: string environment_id = 5;
   */
  environmentId: string;

  /**
   * gateway_id is the unique identifier for this gateway within the namespace.
   *
   * @generated from field: string gateway_id = 6;
   */
  gatewayId: string;

  /**
   * image is the container image to deploy for the gateway.
   * Must be a valid container registry URL accessible by the cluster.
   * Example: "ghcr.io/unkeyed/gateway:v1.2.3"
   *
   * @generated from field: string image = 7;
   */
  image: string;

  /**
   * replicas is the desired number of gateway instances.
   * Must be at least 1. For high availability, use 3 or more.
   *
   * @generated from field: uint32 replicas = 8;
   */
  replicas: number;

  /**
   * cpu_millicores is the CPU request/limit in millicores (1000 = 1 CPU core).
   * This ensures the gateway has sufficient CPU resources.
   * Example: 500 = 0.5 CPU cores
   *
   * @generated from field: uint32 cpu_millicores = 9;
   */
  cpuMillicores: number;

  /**
   * memory_size_mib is the memory request/limit in mebibytes.
   * This ensures the gateway has sufficient memory.
   * Example: 512 = 512 MiB
   *
   * @generated from field: uint32 memory_size_mib = 10;
   */
  memorySizeMib: number;
};

/**
 * Describes the message ctrl.v1.ApplyGateway.
 * Use `create(ApplyGatewaySchema)` to create a new message.
 */
export const ApplyGatewaySchema: GenMessage<ApplyGateway> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 11);

/**
 * DeleteGateway identifies a gateway to remove from the cluster.
 *
 * The gateway and all its resources (pods, services, ingress) will be deleted.
 * In-flight requests may be disrupted unless proper connection draining is configured.
 *
 * @generated from message ctrl.v1.DeleteGateway
 */
export type DeleteGateway = Message<"ctrl.v1.DeleteGateway"> & {
  /**
   * gateway_id identifies the gateway to delete.
   * All resources with this gateway_id in the namespace will be removed.
   *
   * @generated from field: string gateway_id = 1;
   */
  gatewayId: string;
};

/**
 * Describes the message ctrl.v1.DeleteGateway.
 * Use `create(DeleteGatewaySchema)` to create a new message.
 */
export const DeleteGatewaySchema: GenMessage<DeleteGateway> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 12);

/**
 * ApplyDeployment contains the desired configuration for a deployment.
 *
 * The cluster agent will ensure a deployment exists with this exact configuration, creating it if
 * it doesn't exist or updating it if it does. All fields except namespace are required.
 * The control plane ensures that deployment_id is unique within the namespace.
 *
 * @generated from message ctrl.v1.ApplyDeployment
 */
export type ApplyDeployment = Message<"ctrl.v1.ApplyDeployment"> & {
  /**
   * namespace is the Kubernetes namespace in which the deployment should exist.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * workspace_id identifies the workspace that owns this deployment.
   * Used for multi-tenancy and access control.
   *
   * @generated from field: string workspace_id = 2;
   */
  workspaceId: string;

  /**
   * project_id identifies the project within the workspace.
   * Deployments are scoped to projects for organizational purposes.
   *
   * @generated from field: string project_id = 3;
   */
  projectId: string;

  /**
   * environment_id specifies the environment .
   * Used for environment-specific configuration and isolation.
   *
   * @generated from field: string environment_id = 4;
   */
  environmentId: string;

  /**
   * deployment_id is the unique identifier for this deployment within the namespace.
   *
   * @generated from field: string deployment_id = 5;
   */
  deploymentId: string;

  /**
   * image is the container image to deploy.
   * Must be a valid container registry URL accessible by the cluster.
   * Example: "gcr.io/myproject/app:v2.1.0"
   *
   * @generated from field: string image = 6;
   */
  image: string;

  /**
   * replicas is the desired number of pod instances.
   * Must be at least 1. Set higher for increased availability and load distribution.
   *
   * @generated from field: uint32 replicas = 7;
   */
  replicas: number;

  /**
   * cpu_millicores is the CPU request/limit in millicores (1000 = 1 CPU core).
   * This ensures each pod has sufficient CPU resources.
   * Example: 250 = 0.25 CPU cores
   *
   * @generated from field: uint32 cpu_millicores = 8;
   */
  cpuMillicores: number;

  /**
   * memory_size_mib is the memory request/limit in mebibytes.
   * This ensures each pod has sufficient memory.
   * Example: 256 = 256 MiB
   *
   * @generated from field: uint32 memory_size_mib = 9;
   */
  memorySizeMib: number;
};

/**
 * Describes the message ctrl.v1.ApplyDeployment.
 * Use `create(ApplyDeploymentSchema)` to create a new message.
 */
export const ApplyDeploymentSchema: GenMessage<ApplyDeployment> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 13);

/**
 * DeleteDeployment identifies a deployment to remove from the cluster.
 *
 * The deployment and all its pods will be terminated gracefully according to
 * the configured termination grace period. All associated resources (services,
 * configmaps specific to this deployment) will also be cleaned up.
 *
 * @generated from message ctrl.v1.DeleteDeployment
 */
export type DeleteDeployment = Message<"ctrl.v1.DeleteDeployment"> & {
  /**
   * deployment_id identifies the deployment to delete.
   * All resources with this deployment_id in the namespace will be removed.
   *
   * @generated from field: string deployment_id = 1;
   */
  deploymentId: string;
};

/**
 * Describes the message ctrl.v1.DeleteDeployment.
 * Use `create(DeleteDeploymentSchema)` to create a new message.
 */
export const DeleteDeploymentSchema: GenMessage<DeleteDeployment> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 14);

/**
 * InfraEvent is streamed from the control plane to cluster agents.
 *
 * Each event contains either a gateway or deployment configuration change that
 * the agent should apply to its cluster. Events are sent in real-time as
 * changes occur in the control plane, enabling immediate propagation of updates
 * across the fleet of clusters.
 *
 * The agent should process events idempotently since the same event may be
 * delivered multiple times during network issues or reconnections.
 *
 * @generated from message ctrl.v1.InfraEvent
 */
export type InfraEvent = Message<"ctrl.v1.InfraEvent"> & {
  /**
   * event contains the specific event to process.
   * Only one event type is set per InfraEvent, allowing the client to
   * handle different resource types with appropriate logic.
   *
   * @generated from oneof ctrl.v1.InfraEvent.event
   */
  event: {
    /**
     * gateway_event contains a gateway lifecycle event (apply or delete).
     * The client should apply this to gateway resources in the cluster.
     *
     * @generated from field: ctrl.v1.GatewayEvent gateway_event = 2;
     */
    value: GatewayEvent;
    case: "gatewayEvent";
  } | {
    /**
     * deployment_event contains a deployment lifecycle event (apply or delete).
     * The client should apply this to deployment resources in the cluster.
     *
     * @generated from field: ctrl.v1.DeploymentEvent deployment_event = 3;
     */
    value: DeploymentEvent;
    case: "deploymentEvent";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message ctrl.v1.InfraEvent.
 * Use `create(InfraEventSchema)` to create a new message.
 */
export const InfraEventSchema: GenMessage<InfraEvent> = /*@__PURE__*/
  messageDesc(file_ctrl_v1_cluster, 15);

/**
 * ClusterService coordinates deployment and gateway configurations across multiple clusters.
 *
 * Agents in each cluster establish a watch stream to receive configuration events
 * from the control plane. The service streams deployment and gateway lifecycle events
 * (apply, delete) to the appropriate clusters based on their cluster_id and region.
 *
 * The watch connection is designed to be long-lived with automatic reconnection on failure.
 * When an agent reconnects, it should initiate reconciliation to ensure consistency.
 *
 * @generated from service ctrl.v1.ClusterService
 */
export const ClusterService: GenService<{
  /**
   * Watch establishes a stream for receiving deployment and gateway events for a specific cluster.
   *
   * The cluster agent initiates this connection and keeps it open to receive real-time updates.
   * Events are filtered server-side based on the cluster_id and region provided in the request.
   *
   * The stream sends events as they occur, eliminating the need for polling. If the connection
   * is lost, the agent should reconnect and use reconciliation mechanisms to catch up
   * on any missed events.
   *
   * @generated from rpc ctrl.v1.ClusterService.Watch
   */
  watch: {
    methodKind: "server_streaming";
    input: typeof WatchRequestSchema;
    output: typeof InfraEventSchema;
  },
  /**
   * returns a watch events for compatibility but will never return a delete event
   * only apply events from currently desired infrastructure are included
   *
   * @generated from rpc ctrl.v1.ClusterService.GetDesiredState
   */
  getDesiredState: {
    methodKind: "server_streaming";
    input: typeof GetDesiredStateRequestSchema;
    output: typeof InfraEventSchema;
  },
  /**
   * request a single deployment and return its desired state
   *
   * @generated from rpc ctrl.v1.ClusterService.GetDesiredDeploymentState
   */
  getDesiredDeploymentState: {
    methodKind: "unary";
    input: typeof GetDesiredDeploymentStateRequestSchema;
    output: typeof DeploymentEventSchema;
  },
  /**
   * request a single gateway and return its desired state
   *
   * @generated from rpc ctrl.v1.ClusterService.GetDesiredGatewayState
   */
  getDesiredGatewayState: {
    methodKind: "unary";
    input: typeof GetDesiredGatewayStateRequestSchema;
    output: typeof GatewayEventSchema;
  },
  /**
   * @generated from rpc ctrl.v1.ClusterService.UpdateInstance
   */
  updateInstance: {
    methodKind: "unary";
    input: typeof UpdateInstanceRequestSchema;
    output: typeof UpdateInstanceResponseSchema;
  },
  /**
   * @generated from rpc ctrl.v1.ClusterService.UpdateGateway
   */
  updateGateway: {
    methodKind: "unary";
    input: typeof UpdateGatewayRequestSchema;
    output: typeof UpdateGatewayResponseSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_ctrl_v1_cluster, 0);

