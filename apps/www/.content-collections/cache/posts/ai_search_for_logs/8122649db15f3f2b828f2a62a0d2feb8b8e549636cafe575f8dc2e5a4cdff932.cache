"var Component=(()=>{var h=Object.create;var i=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},o=(t,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of m(e))!y.call(t,a)&&a!==r&&i(t,a,{get:()=>e[a],enumerable:!(s=d(e,a))||s.enumerable});return t};var b=(t,e,r)=>(r=t!=null?h(g(t)):{},o(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),v=t=>o(i({},\"__esModule\",{value:!0}),t);var u=f((k,l)=>{l.exports=_jsx_runtime});var A={};w(A,{default:()=>p});var n=b(u());function c(t){let e={a:\"a\",blockquote:\"blockquote\",code:\"code\",h2:\"h2\",h3:\"h3\",li:\"li\",p:\"p\",pre:\"pre\",ul:\"ul\",...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Imagine this: You're tracking down an issue in your logs. The traditional approach feels like following a recipe - select the request status, choose the method, navigate to the date-time picker, set it to two hours ago, and keep adding more criteria. Click after click, filter after filter.\"}),`\n`,(0,n.jsx)(e.p,{children:`Now imagine simply typing: \"I need requests with GET methods, success status that happened 2 hours ago.\" That's it. No more menu diving, no more juggling multiple filters - just tell the system what you want, like you're asking a colleague.`}),`\n`,(0,n.jsx)(e.h2,{id:\"implementation-journey\",children:\"Implementation Journey\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"When this feature was first discussed, we thought implementation would be challenging. However, if you're already using \",(0,n.jsx)(e.code,{children:\"zod\"}),\", it's surprisingly straightforward. OpenAI provides a \",(0,n.jsx)(e.code,{children:\"zodResponseFormat\"}),\" helper to generate structured outputs, making the integration super easy.\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"query-parameter-structure\",children:\"Query Parameter Structure\"}),`\n`,(0,n.jsx)(e.p,{children:\"At the heart of our implementation is a query parameter design that bridges natural language and code. We used a syntax that's both powerful and intuitive:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`operator:value,operator:value (e.g., \"is:200,is:404\")\n\nExample -> status=is:200,is:400\n           path=startsWith:foo,endsWith:bar\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This pattern allows for incredible flexibility - you can chain multiple conditions while maintaining readability. To handle these parameters in our Unkey dashboard, we implemented a custom parser for \",(0,n.jsx)(e.a,{href:\"%22https://nuqs.47ng.com/%22\",children:\"nuqs\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`export const parseAsFilterValueArray: Parser<FilterUrlValue[]> = {\n  parse: (str: string | null) => {\n    if (!str) {\n      return [];\n    }\n    try {\n      // Format: operator:value,operator:value (e.g., \"is:200,is:404\")\n      return str.split(\",\").map((item) => {\n        const [operator, val] = item.split(/:(.+)/);\n        if (![\"is\", \"contains\", \"startsWith\", \"endsWith\"].includes(operator)) {\n          throw new Error(\"Invalid operator\");\n        }\n        return {\n          operator: operator as FilterOperator,\n          value: val,\n        };\n      });\n    } catch {\n      return [];\n    }\n  },\n  // In our app we pass a valid type but for brevity it's omitted\n  serialize: (value: any[]) => {\n    if (!value?.length) {\n      return \"\";\n    }\n    return value.map((v) => \\`\\${v.operator}:\\${v.value}\\`).join(\",\");\n  },\n};\n\nexport const queryParamsPayload = {\n  requestId: parseAsFilterValueArray,\n  host: parseAsFilterValueArray,\n  methods: parseAsFilterValueArray,\n  paths: parseAsFilterValueArray,\n  status: parseAsFilterValueArray,\n  startTime: parseAsInteger,\n  endTime: parseAsInteger,\n  since: parseAsRelativeTime,\n} as const;\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Our parser handles edge cases gracefully - from null inputs to invalid operators - while maintaining a clean, predictable output format. The type-safe payload configuration ensures consistency across different parameter types.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"defining-the-schema\",children:\"Defining the Schema\"}),`\n`,(0,n.jsx)(e.p,{children:\"With our parameter structure in place, we needed a way to ensure the AI's responses would map perfectly to our system. Enter Zod - our schema validation powerhouse:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`export const filterOutputSchema = z.object({\n  filters: z.array(\n    z.object({\n      field: z.enum([\n        \"host\",\n        \"requestId\",\n        \"methods\",\n        \"paths\",\n        \"status\",\n        \"startTime\",\n        \"endTime\",\n        \"since\",\n      ]),\n      filters: z.array(\n        z.object({\n          operator: z.enum([\"is\", \"contains\", \"startsWith\", \"endsWith\"]),\n          value: z.union([z.string(), z.number()]),\n        })\n      ),\n    })\n  ),\n});\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"This schema acts as a contract between natural language and our application's expectations. It ensures that every AI response will be structured in a way our system can understand and process. The nested array structure allows for complex queries while maintaining strict type safety.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"system-prompt-and-openai-integration\",children:\"System Prompt and OpenAI Integration\"}),`\n`,(0,n.jsx)(e.p,{children:\"The magic happens in how we instruct the AI. Our system prompt is carefully crafted to ensure consistent, reliable outputs:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`You are an expert at converting natural language queries into filters. For queries with multiple conditions, output all relevant filters. We will process them in sequence to build the complete filter. For status codes, always return one for each variant like 200,400 or 500 instead of 200,201, etc... - the application will handle status code grouping internally. Always use this \\${usersReferenceMS} timestamp when dealing with time related queries.\n\nQuery: \"path should start with /api/oz and method should be POST\"\nResult: [\n  {\n    \"field\": \"paths\",\n    \"filters\": [\n      {\n        \"operator\": \"startsWith\",\n        \"value\": \"/api/oz\"\n      }\n    ]\n  },\n  {\n    \"field\": \"methods\",\n    \"filters\": [\n      {\n        \"operator\": \"is\",\n        \"value\": \"POST\"\n      }\n    ]\n  }\n]\n`})}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"In our prompt there are lots of examples for each search variation, but in here it's omitted for brevity. For the best result make sure your prompt is as detailed as possible.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{id:\"openai-configuration\",children:\"OpenAI Configuration\"}),`\n`,(0,n.jsx)(e.p,{children:\"Tuning the AI's behavior is crucial for reliable results. Here's our optimized configuration:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`const completion = await openai.beta.chat.completions.parse({\n  model: \"gpt-4o-mini\",\n  temperature: 0.2, // Lower temperature for more deterministic outputs\n  top_p: 0.1, // Focus on highest probability tokens\n  frequency_penalty: 0.5, // Maintain natural language variety\n  presence_penalty: 0.5, // Encourage diverse responses\n  n: 1, // Single, confident response\n  messages: [\n    {\n      role: \"system\",\n      content: systemPrompt,\n    },\n    {\n      role: \"user\",\n      content: userQuery,\n    },\n  ],\n  response_format: zodResponseFormat(filterOutputSchema, \"searchQuery\"),\n});\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The low \",(0,n.jsx)(e.code,{children:\"temperature\"}),\" and \",(0,n.jsx)(e.code,{children:\"top_p\"}),\" values ensure predictable outputs, while the penalty parameters help maintain natural-sounding responses.\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"process-flow\",children:\"Process Flow\"}),`\n`,(0,n.jsx)(e.p,{children:\"Here's how the entire process works:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`User\n  |\n  | \"Show me failed requests from last hour\"\n  v\nFrontend\n  |\n  | {query: \"show me failed requests from last hour\"}\n  v\ntRPC Route\n  |\n  | {model, messages with system prompt, schema}\n  v\nOpenAI\n  |\n  | {structured JSON matching our schema}\n  v\ntRPC Route\n  |\n  | status=is:400,since:1h\n  v\nFrontend\n  |\n  | /logs?status=is:400&since=is:1h\n  v\nURL\n  |\n  | trigger fetch with new params\n  v\nLogs tRPC Query\n  |\n  | return filtered logs\n  v\nFrontend\n  |\n  | display filtered results\n  v\nUser\n`})}),`\n`,(0,n.jsx)(e.h2,{id:\"important-considerations\",children:\"Important Considerations\"}),`\n`,(0,n.jsx)(e.p,{children:\"Before implementing this feature in your own application, here are some crucial factors to consider:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Integrating LLMs into your application requires robust error handling. The OpenAI API might experience downtime or rate limiting, so implement fallback mechanisms or meaningful error message to show to user.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Each query consumes OpenAI API tokens - More AI search burns more money\"}),`\n`,(0,n.jsx)(e.li,{children:\"Implement rate limiting - Without ratelimit users can abuse your AI-powered search\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{id:\"conclusion\",children:\"Conclusion\"}),`\n`,(0,n.jsx)(e.p,{children:\"While traditional filter-based UIs work well, the ability to express search criteria in plain English makes log exploration more intuitive and efficient.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The integration with OpenAI's structured output feature and zod makes the implementation surprisingly straightforward. The key to success lies in:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Crafting a clear system prompt\"}),`\n`,(0,n.jsx)(e.li,{children:\"Defining a robust schema for your use case\"}),`\n`,(0,n.jsx)(e.li,{children:\"Implementing proper error handling and fallbacks\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Remember that while AI-powered features can enhance your application, they should complement rather than completely replace traditional interfaces. This hybrid approach ensures the best experience for all users while maintaining reliability and accessibility.\"})]})}function p(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(c,{...t})}):c(t)}return v(A);})();\n;return Component;"