"var Component=(()=>{var u=Object.create;var r=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var w=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),f=(i,e)=>{for(var t in e)r(i,t,{get:e[t],enumerable:!0})},s=(i,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!y.call(i,a)&&a!==t&&r(i,a,{get:()=>e[a],enumerable:!(o=g(e,a))||o.enumerable});return i};var b=(i,e,t)=>(t=i!=null?u(m(i)):{},s(e||!i||!i.__esModule?r(t,\"default\",{value:i,enumerable:!0}):t,i)),v=i=>s(r({},\"__esModule\",{value:!0}),i);var d=w((_,l)=>{l.exports=_jsx_runtime});var I={};f(I,{default:()=>h});var n=b(d());function c(i){let e={a:\"a\",code:\"code\",h2:\"h2\",h3:\"h3\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...i.components},{Image:t}=e;return t||k(\"Image\",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[`Usage billing is nothing new anymore. A lot of developers don't want to spend a large fixed amount\nof money each month regardless of what they actually use. Especially when building out new unproven projects, it's essential to meet the developer where they are at: `,(0,n.jsx)(e.strong,{children:\"zero users\"})]}),`\n`,(0,n.jsx)(e.p,{children:`As long as your customer is too small to generate revenue, they don't want to pay for your service and that's okay.\nGenerous free tiers are a good solution to attract users, but even after they upgrade, you shouldn't send them an enormous bill for resources they're not even using. Pricing that scales with usage is preferrable for many, but not all, products.`}),`\n`,(0,n.jsx)(e.p,{children:`Some companies have different billing tiers, where you'd pay for example: $10 for 10k, $20 for 30k, $50 for 100k. The issue with that is paying the next higher tier just because you have exceeded the previous tier by a small margin, ie: paying $50 for 31k.\nThis system is very easy to implement, but at Unkey we do prorated usaged based billing, which means you pay for your exact usage, not whatever billing tier your usage fits in.`}),`\n`,(0,n.jsx)(e.h2,{id:\"challenges\",children:\"Challenges\"}),`\n`,(0,n.jsx)(e.h3,{id:\"tracking-usage\",children:\"Tracking usage\"}),`\n`,(0,n.jsx)(e.p,{children:`Before charging your customers, you obviously need to know how much and what they used. Tracking this data is the easy part, but where do you store it?\nIf you only produce <100/s billing events and use Stripe, then you could just use subscriptions and update the usage through their API directly. Depending on what you charge for, this can be enough for a long long time. Other billing providers might have similar systems and higher limits, but they probably have a limit too, so we needed to look elsewhere.`}),`\n`,(0,n.jsx)(e.p,{children:\"If we can't directly ingest the usage to our billing provider, we need to store it somewhere first and there are a lot of options, depending on your requirements.\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Redis:\"}),`\nIf you just need to count usage per month, redis would be a great way and can be as simple a using `,(0,n.jsx)(e.code,{children:\"INCR {user}:{year}:{month}\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Your database:\"}),`\nI don't know how far you can scale increments in your database of choice, but it might get you far enough.`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time series database:\"}),`\nIf you care about more than just the total value, a database optimized for storing time series would be ideal.\nThere are a ton available for many platforms, or you can selfhost them.`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Dedicated usage-billing SaaS:\"}),`\nThese days there are even some SaaS, that focus on this problem specifically and allow you to ingest usage records at any rate.`]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{id:\"sending-usage-to-our-billing-provider\",children:\"Sending usage to our billing provider\"}),`\n`,(0,n.jsxs)(e.p,{children:[`Initially we were using Stripe subscriptions and updating usage in Stripe every hour for every workspace.\nThis worked pretty well and Stripe takes care of a lot of things, such as proration when subscriptions change.\nHowever we also ran into a few issues because Stripe's `,(0,n.jsx)(e.code,{children:\"billing_anchor\"}),\" would not line up perfectly with our own data aggregations, resulting in some missed usage records.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This could be fixed in theory and Stripe subscriptions are great overall, but we decided to build a more agnostic system, in case we ever want to move off of stripe.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"using-tinybird-for-analytics\",children:\"Using Tinybird for analytics\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We are building all of our analytics and metrics on top of \",(0,n.jsx)(e.a,{href:\"https://tinybird.co\",children:\"Tinybird\"}),`, a modern real-time data platform, so we reused the existing data to power our billing.\nEvery event is ingested into Tinybird and we can run aggregations against that data later or in real time.`]}),`\n`,(0,n.jsx)(e.p,{children:\"A vertification event at Unkey looks like this, I'll omit unnecessary fields:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-json\",children:`{\n    /**\n    * The workspace that gets billed later\n    */\n    \"workspaceId\": \"ws_123\",\n\n    /**\n    * A unique identifier for the key being verified\n    */\n    \"keyId\": \"key_123\",\n\n    /**\n    * When the verification happened\n    */\n    \"time\": 1709119218743,\n\n    /**\n    * If the verification was denied, we log the reason why\n    * when a key is denied for any reason, we will not charge the customer\n    */\n    \"deniedReason\": null | \"RATE_LIMITED\" | \"USAGE_EXCEEDED\"\n    \n    ... more\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:`During operation, whenever a key is getting verified, we emit one of these events straight to Tinybird.\nThese events are used throughout our dashboard to power analytics charts, and we also make it available to our customers, to build their own dashboards or charge their users.`}),`\n`,(0,n.jsx)(e.h2,{id:\"implementation-details\",children:\"Implementation details\"}),`\n`,(0,n.jsx)(e.p,{children:\"For billing we'll look at extracting two different values for a specific timeframe:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Total usage:\"}),\"  How many events per workspace?\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Distinct usage:\"}),`  How many distinct ids in all the events?\nThis is quite common in the auth space where you charge for \"unique active users\" but is not limited to authentication.\nI've seen some SaaS move from traditional seat-based pricing to active-seat-based, where they only charge you if a user was actually active, rather than just having access.`]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{id:\"total-successful-verifications\",children:\"Total successful verifications\"}),`\n`,(0,n.jsx)(t,{src:\"/images/blog-images/usage-based-billing/monthly_verifications.png\",alt:\"monthly verifications pipes\",width:\"1920\",height:\"1080\"}),`\n`,(0,n.jsx)(e.p,{children:`To figure out the total usage per workspace, per month, we can simply query the original datasource and write the aggregated data to a materilized view:\nWe filter out all verifications that were denied and then count all verifications per workspace and per month.`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-sql\",children:`SELECT\n    workspaceId,\n    apiId,\n    keyId,\n    countState(*) AS total,\n    toStartOfMonth(fromUnixTimestamp64Milli(time)) AS time\nFROM key_verifications__v2\nWHERE deniedReason IS NULL\nGROUP BY\n    workspaceId,\n    apiId,\n    keyId,\n    time\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[`Then we can write a second pipe that reads data from the materialized view. The beauty of Tinybird is that they expose an HTTP endpoint for you to query this pipe.\nYou can even define query parameters like this: `,(0,n.jsx)(e.code,{children:\"{{ String(workspaceId, required=True) }}\"})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-sql\",children:`SELECT\n    countMerge(total) as total\nFROM mv__monthly_verifications__v2\nWHERE\n    workspaceId = {{ String(workspaceId, required=True) }}\n    AND time = makeDate({{ Int64(year) }}, {{ Int64(month) }}, 1)\nGROUP BY time\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"We can now query this endpoint like this:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-bash\",children:`curl .../endpoint?workspaceId=ws_123&year=2024&month=2\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"And we will get back the total number of successful verifications for workspace \",(0,n.jsx)(e.code,{children:\"ws_123\"}),\" in february 2024.\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"active-keys\",children:\"Active keys\"}),`\n`,(0,n.jsx)(t,{src:\"/images/blog-images/usage-based-billing/monthly_active_keys.png\",alt:\"monthly active keys pipes\",width:\"1920\",height:\"1080\"}),`\n`,(0,n.jsx)(e.p,{children:`Again we create an intermediate materialized view first. We could've reused the previous one, but it's nice to have them separated in case we want to change things later.\nThis results in a materialized view, where there's at most one row per keyId and month, making it super cheap to query later.`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-sql\",children:`SELECT\n    workspaceId,\n    apiId,\n    keyId,\n    toStartOfMonth(fromUnixTimestamp64Milli(time)) AS time\nFROM key_verifications__v2\nGROUP BY\n    workspaceId,\n    apiId,\n    keyId,\n    time\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The query uses \",(0,n.jsx)(e.code,{children:\"count(DISTINCT keyId)\"}),\" to return how many unique keyIds have been observed in the given month.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-sql\",children:`SELECT count(DISTINCT keyId) as keys\nFROM mv__monthly_active_keys__v1\nWHERE\n    workspaceId = {{ String(workspaceId, required=True) }}\n    AND time = makeDate({{ Int64(year) }}, {{ Int64(month) }}, 1)\nGROUP BY time\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"When querying the endpoint, we'll get back how many keys had at least 1 verification in a specific workspace and month.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"invoicing\",children:\"Invoicing\"}),`\n`,(0,n.jsxs)(e.p,{children:[`Now that we know how to find out what to charge, let's figure out how to charge our customers.\nWe're still using Stripe to create the invoice and `,(0,n.jsx)(e.a,{href:\"https://trigger.dev\",children:\"trigger.dev\"}),` for durable workflow execution.\nOnce a month, a workflow starts to load all billable workspaces, load their usage and create an invoice.`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We simply store a \",(0,n.jsx)(e.code,{children:\"stripeCustomerId\"}),\" and \",(0,n.jsx)(e.code,{children:\"subscription\"}),\"column in our database and can query all workspaces easily:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-typescript\",children:`const workspaces = await io.runTask(\"list workspaces\", async () =>\n    db.query.workspaces.findMany({\n    where: (table, { isNotNull, isNull, not, eq, and }) =>\n        and(\n            isNotNull(table.stripeCustomerId),\n            isNotNull(table.subscriptions),\n            not(eq(table.plan, \"free\")),\n            isNull(table.deletedAtM),\n        ),\n    }),\n);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Afterwards we fetch the usage for both keys and verifications and finalize the invoice. The code is all open source, if you're interested: \",(0,n.jsx)(e.a,{href:\"https://github.com/unkeyed/unkey/blob/main/apps/workflows/jobs/create-invoice.ts\",children:\"create-invoice.ts\"})]}),`\n`,(0,n.jsx)(e.h2,{id:\"results\",children:\"Results\"}),`\n`,(0,n.jsx)(e.p,{children:`Doing invoicing ourselves made it easier to customize its behaviour. That being said, it definitely took longer to implement than sitting down and fixing subscription timing issues properly.\nEspecially prorations are pretty annoying to handle.`}),`\n`,(0,n.jsx)(e.p,{children:\"We're still happy with the result, as it allows us to edit and tweak things as we go, whereas Stripe makes a ton of options non-editable. We can also switch providers at any time as we own the entire billing flow.\"})]})}function h(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,{...i,children:(0,n.jsx)(c,{...i})}):c(i)}function k(i,e){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+i+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return v(I);})();\n;return Component;"