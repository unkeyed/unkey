"var Component=(()=>{var u=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},o=(t,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!f.call(t,i)&&i!==r&&a(t,i,{get:()=>e[i],enumerable:!(s=p(e,i))||s.enumerable});return t};var v=(t,e,r)=>(r=t!=null?u(g(t)):{},o(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),b=t=>o(a({},\"__esModule\",{value:!0}),t);var d=w((I,l)=>{l.exports=_jsx_runtime});var T={};y(T,{default:()=>h});var n=v(d());function c(t){let e={a:\"a\",code:\"code\",em:\"em\",h2:\"h2\",h3:\"h3\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"When we started migrating our API services from TypeScript to Go, we were looking for an HTTP framework that would provide a clean developer experience, offer precise control over middleware execution, and integrate seamlessly with OpenAPI for our SDK generation. After evaluating the popular frameworks in the Go ecosystem, we found that none quite matched our specific requirements.\"}),`\n`,(0,n.jsx)(e.p,{children:\"So, we did what engineers do: we built our own. Enter Zen, a lightweight HTTP framework built directly on top of Go's standard library.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"the-pain-points-with-existing-frameworks\",children:\"The Pain Points with Existing Frameworks\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Our journey began with our TypeScript API using Hono, which offered a fantastic developer experience with \",(0,n.jsx)(e.a,{href:\"https://github.com/samchungy/zod-openapi\",children:\"Zod validations\"}),\" and first-class OpenAPI support. When migrating to Go, we faced several challenges with existing frameworks:\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"complex-middleware-execution-order\",children:\"Complex Middleware Execution Order\"}),`\n`,(0,n.jsx)(e.p,{children:\"Most frameworks enforce a rigid middleware execution pattern that didn't allow for our specific needs. The critical limitation we encountered was the inability to capture post-error-handling response details\\u2014a fundamental requirement not just for our internal monitoring but also for our customer-facing analytics dashboard.\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"We needed an error handling middleware that could parse returned errors and construct properly typed problem+json responses\"}),`\n`,(0,n.jsx)(e.li,{children:\"OpenAPI validation needed to run before our handler code but after error handling, to return nice validation responses\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Most importantly, we needed logging middleware that could run \",(0,n.jsx)(e.em,{children:\"after\"}),\" error handling was complete, to capture the final HTTP status code and response body that was actually sent to the client\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"This last point is crucial for both debugging and customer visibility. We store these responses and make them available to our customers in our dashboard, allowing them to inspect exactly what their API clients received. When an error occurs, customers need to see the precise HTTP status code and response payload their systems encountered, not just that an error happened somewhere in the pipeline.\"}),`\n`,(0,n.jsx)(e.p,{children:\"While we could have potentially achieved this with existing frameworks, doing so would have required embedding error handling and response logging logic directly into every handler function. This would mean handlers couldn't simply return Go errors\\u2014they would need to know how to translate those errors into HTTP responses and also handle logging those responses. This approach would:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Duplicate error handling logic across every endpoint\"}),`\n`,(0,n.jsx)(e.li,{children:\"Make handlers responsible for concerns beyond their core business logic\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Our goal was to keep handlers simple, allowing them to focus on business logic and return domain errors without worrying about HTTP status codes, response formatting, or logging..\"}),`\n`,(0,n.jsx)(e.p,{children:\"By building Zen, we could ensure handlers remained clean and focused while still providing our customers with complete visibility into their API requests\\u2014including the exact error responses their systems encountered.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"poor-openapi-integration\",children:\"Poor OpenAPI Integration\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"While frameworks like \",(0,n.jsx)(e.a,{href:\"https://huma.rocks\",children:\"huma.rocks\"}),\" offered OpenAPI generation from Go code, we preferred a schema-first approach. This approach gives us complete control over the spec quality and annotations. With our SDKs generated via \",(0,n.jsx)(e.a,{href:\"https://www.speakeasy.com/\",children:\"Speakeasy\"}),\" from this spec, we need to set the bar high to let them deliver the best SDK possible.\"]}),`\n`,(0,n.jsx)(e.h3,{id:\"dependency-bloat\",children:\"Dependency Bloat\"}),`\n`,(0,n.jsx)(e.p,{children:\"Many frameworks pull in dozens of dependencies, which adds maintenance, potential security risks and the possibility of supply chain attacks. We wanted something minimal that relied primarily on Go's standard library.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"inflexible-error-handling\",children:\"Inflexible Error Handling\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Go's error model is simple, but translating errors into HTTP responses (especially \",(0,n.jsx)(e.a,{href:\"https://datatracker.ietf.org/doc/html/rfc7807\",children:\"RFC 7807\"}),\" problem+json ones) requires special handling. Existing frameworks made it surprisingly difficult to map our domain errors to appropriate HTTP responses.\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"the-zen-philosophy\",children:\"The Zen Philosophy\"}),`\n`,(0,n.jsx)(e.p,{children:\"Rather than forcing an existing framework to fit our needs, we decided to build Zen with three core principles in mind:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Simplicity\"}),\": Focus on core HTTP handling with minimal abstractions\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Clarity\"}),\": Maintain Go's idioms and stay close to net/http's mental model\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Efficiency\"}),\": No unnecessary dependencies, with low overhead\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Put simply, Zen is a thin wrapper around Go's standard library that makes common HTTP tasks more ergonomic while providing precise control over request handling.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"the-core-components-of-zen\",children:\"The Core Components of Zen\"}),`\n`,(0,n.jsx)(e.p,{children:\"Zen consists of four primary components, each serving a specific purpose in the request lifecycle:\"}),`\n`,(0,n.jsx)(e.h3,{id:\"sessions\",children:\"Sessions\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"Session\"}),\" type encapsulates the HTTP request and response context, providing utility methods for common operations:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-go\",children:`route := zen.NewRoute(\"GET\", \"/v2/liveness\",\n\tfunc(ctx context.Context, s *zen.Session) error {\n\t\tres := Response{\n\t\t\tMessage: \"we're cooking\",\n\t\t}\n\t\treturn s.JSON(http.StatusOK, res)\n\t},\n)\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Sessions are pooled and reused between requests to reduce memory allocations and GC pressure, a common performance concern in high-throughput API servers.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"routes\",children:\"Routes\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"Route\"}),\" interface represents an HTTP endpoint with its method, path, and handler function. Routes can be decorated with middleware chains:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-go\",children:`func main(){\n\t// ...\n\n\t// Create a route\n\troute := zen.NewRoute(\"POST\", \"/v2/ratelimit.limit\", handler)\n\n\t// Register with middleware\n\tserver.RegisterRoute(\n\t    []zen.Middleware{\n\t      zen.WithTracing(),\n\t      zen.WithMetrics(eventBuffer),\n\t      zen.WithLogging(logger),\n\t      zen.WithErrorHandling(logger),\n\t      zen.WithValidation(validator),\n\t    },\n\t    route,\n\t)\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{id:\"middleware\",children:\"Middleware\"}),`\n`,(0,n.jsx)(e.p,{children:\"At the core of Zen, middleware is just a function:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-go\",children:`type Middleware func(handler HandleFunc) HandleFunc\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"But this simple definition makes it so powerful. Each middleware gets a handler and returns a wrapped handler - that's it. No complex interfaces or lifecycle hooks to learn.\"}),`\n`,(0,n.jsx)(e.p,{children:\"What's special about this approach is that it lets us control exactly when each piece of middleware runs. For example, our logging middleware captures the final status code and response body:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-go\",children:`func WithLogging(logger logging.Logger) Middleware {\n    return func(next HandleFunc) HandleFunc {\n        return func(ctx context.Context, s *Session) error {\n            start := time.Now()\n\n            // Call the next handler in the chain\n            err := next(ctx, s)\n\n            // Log after handling is complete\n            logger.InfoContext(ctx, \"request\",\n                slog.String(\"method\", s.r.Method),\n                slog.String(\"path\", s.r.URL.Path),\n                slog.Int(\"status\", s.responseStatus), // Captured from response\n                slog.String(\"latency\", time.Since(start).String()),\n            )\n\n            return err\n        }\n    }\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"To understand our error handling middleware, it's important to first know how we tag errors in our application. We use a custom \",(0,n.jsx)(e.code,{children:\"fault\"}),\" package that enables adding metadata to errors, including tags that categorize the error type and separate internal details from user-facing messages.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"In our handlers or services, we can return tagged errors like this:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-go\",children:`// When a database query returns no results\nif errors.Is(err, sql.ErrNoRows) {\n    return fault.Wrap(err,\n        fault.WithTag(fault.NOT_FOUND),\n        fault.WithDesc(\n            fmt.Sprintf(\"namespace '%s' not found in database\", namespaceName),  // Internal details for logs\n            \"This namespace does not exist\"                                      // User-facing message\n        )\n    )\n}\n\n// When handling permission checks\nif !permissions.Valid {\n    return fault.New(\"insufficient permissions\",\n        \tfault.WithCode(codes.Auth.Authorization.InsufficientPermissions.URN()),\n        fault.WithDesc(\n            fmt.Sprintf(\"key '%s' lacks permission on resource '%s'\", auth.KeyID, namespace.ID),\n            permissions.Message  // User-friendly message from the permission system\n        )\n    )\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"WithDesc\"}),\" function is crucial here - it maintains two separate messages:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"An internal message with technical details for logging and debugging\"}),`\n`,(0,n.jsx)(e.li,{children:\"A user-facing message that's safe to expose in API responses\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"This separation lets us provide detailed context for troubleshooting while ensuring we never leak sensitive implementation details to users.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Our error handling middleware then examines these tags to determine the appropriate HTTP response:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-go\",children:`func WithErrorHandling(logger logging.Logger) Middleware {\n    return func(next HandleFunc) HandleFunc {\n        return func(ctx context.Context, s *Session) error {\n            err := next(ctx, s)\n            if err == nil {\n                return nil\n            }\n\n            // Convert domain errors to HTTP responses\n            switch fault.GetTag(err) {\n            case fault.NOT_FOUND:\n                return s.JSON(http.StatusNotFound, api.NotFoundError{\n                    Title:     \"Not Found\",\n                    Type:      \"https://unkey.com/docs/errors/not_found\",\n                    Detail:    fault.UserFacingMessage(err),\n                    RequestId: s.requestID,\n                    Status:    http.StatusNotFound,\n                    Instance:  nil,\n                })\n            case fault.BAD_REQUEST:\n                return s.JSON(http.StatusBadRequest, api.BadRequestError{\n                    Title:     \"Bad Request\",\n                    Type:      \"https://unkey.com/docs/api-reference/errors-v2/unkey/application/invalid_input\",\n                    Detail:    fault.UserFacingMessage(err),\n                    RequestId: s.requestID,\n                    Status:    http.StatusBadRequest,\n                    Instance:  nil,\n                    Errors:    []api.ValidationError{...},\n                })\n            // Additional cases...\n            }\n\n            // Default to 500 Internal Server Error\n            return s.JSON(http.StatusInternalServerError, api.InternalServerError{\n                Title:     \"Internal Server Error\",\n                Type:      \"https://unkey.com/docs/errors/internal_server_error\",\n                Detail:    fault.UserFacingMessage(err),\n                RequestId: s.requestID,\n                Status:    http.StatusInternalServerError,\n                Instance:  nil,\n            })\n        }\n    }\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{id:\"server\",children:\"Server\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"Server\"}),\" type manages HTTP server configuration, lifecycle, and route registration:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-go\",children:`// Initialize a server\nserver, err := zen.New(zen.Config{\n    Logger: logger,\n    // ...\n})\nif err != nil {\n    log.Fatalf(\"failed to create server: %v\", err)\n}\n\n// Register routes\nserver.RegisterRoute([]zen.Middleware{...}, route)\n\n// Start the server\nerr = server.Listen(ctx, \":8080\")\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"The server handles graceful shutdown, goroutine management, and session pooling automatically.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"openapi-integration-the-right-way\",children:\"OpenAPI Integration the Right Way\"}),`\n`,(0,n.jsx)(e.p,{children:\"Unlike frameworks that generate OpenAPI specs from code, we take a schema-first approach. Our OpenAPI spec is hand-crafted for precision and then used to generate Go types and validation logic:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-go\",children:`// OpenAPI validation middleware\nfunc WithValidation(validator *validation.Validator) Middleware {\n    return func(next HandleFunc) HandleFunc {\n        return func(ctx context.Context, s *Session) error {\n            err, valid := validator.Validate(s.r)\n            if !valid {\n                err.RequestId = s.requestID\n                return s.JSON(err.Status, err)\n            }\n            return next(ctx, s)\n        }\n    }\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Our validation package uses \",(0,n.jsx)(e.a,{href:\"https://github.com/pb33f/libopenapi-validator\",children:(0,n.jsx)(e.code,{children:\"pb33f/libopenapi-validator\"})}),\" which provides structural and semantic validation based on our OpenAPI spec. In an ideal world we wouldn't use a dependency for this, but it's way too much and too error prone to implement ourselves at this stage.\"]}),`\n`,(0,n.jsx)(e.h2,{id:\"the-benefits-of-building-zen\",children:\"The Benefits of Building Zen\"}),`\n`,(0,n.jsx)(e.p,{children:\"Creating Zen has provided us with several key advantages:\"}),`\n`,(0,n.jsx)(e.h3,{id:\"complete-middleware-control\",children:\"Complete Middleware Control\"}),`\n`,(0,n.jsx)(e.p,{children:\"We now have granular control over middleware execution, allowing us to capture metrics, logs, and errors exactly as needed. The middleware is simple to understand and compose, making it easy to add new functionality or modify existing behavior.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"schema-first-api-design\",children:\"Schema-First API Design\"}),`\n`,(0,n.jsx)(e.p,{children:\"By taking a schema-first approach to OpenAPI, we maintain full control over our API contract while still getting Go type safety through generated types. This ensures consistency across our SDKs and reduces the likelihood of API-breaking changes.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"minimal-dependencies\",children:\"Minimal Dependencies\"}),`\n`,(0,n.jsx)(e.p,{children:\"Zen relies almost entirely on the standard library, with only a few external dependencies for OpenAPI validation. This reduces our dependency footprint and makes the codebase easier to understand and maintain.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"idiomatic-go\",children:\"Idiomatic Go\"}),`\n`,(0,n.jsx)(e.p,{children:\"Zen follows Go conventions and idioms, making it feel natural to Go developers. Handler functions receive a context as the first parameter and return an error, following common Go patterns.\"}),`\n`,(0,n.jsx)(e.h3,{id:\"type-safety-with-ergonomics\",children:\"Type Safety with Ergonomics\"}),`\n`,(0,n.jsx)(e.p,{children:\"The Session methods for binding request bodies and query parameters into Go structs provide type safety without boilerplate. The error handling middleware gives structured, consistent error responses.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"real-world-example-rate-limiting-api\",children:\"Real-World Example: Rate Limiting API\"}),`\n`,(0,n.jsx)(e.p,{children:\"Here's a complete handler from our rate-limiting API that shows how all these components work together:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-go\",children:`package handler\n\nimport (...)\n\n// Reexporting to reuse in tests\ntype Request = spec.V2RatelimitSetOverrideRequestBody\ntype Response = spec.V2RatelimitSetOverrideResponseBody\n\n\n// Define the dependencies for this route. These are injected during route registration\ntype Services struct {\n\tLogger      logging.Logger\n\tDB          db.Database\n\tKeys        keys.KeyService\n\tPermissions permissions.PermissionService\n}\n\nfunc New(svc Services) zen.Route {\n\treturn zen.NewRoute(\"POST\", \"/v2/ratelimit.setOverride\", func(ctx context.Context, s *zen.Session) error {\n\n\t\tauth, err := svc.Keys.VerifyRootKey(ctx, s)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treq := Request{}\n\t\terr = s.BindBody(&req)\n\t\tif err != nil {\n\t\t\treturn err // already tagged\n\t\t}\n\n\t\tnamespace, err := getNamespace(ctx, svc, auth.AuthorizedWorkspaceID, req)\n\t\tif err != nil {\n\t\t\tif errors.Is(err, sql.ErrNoRows) {\n\t\t\t\treturn fault.Wrap(err,\n\t\t\t\t\tfault.WithTag(fault.NOT_FOUND),\n\t\t\t\t\tfault.WithDesc(\"namespace not found\", \"This namespace does not exist.\"),\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tif namespace.WorkspaceID != auth.AuthorizedWorkspaceID {\n\t\t\treturn fault.New(\"namespace not found\",\n\t\t\t\tfault.WithTag(fault.NOT_FOUND),\n\t\t\t\tfault.WithDesc(\"wrong workspace, masking as 404\", \"This namespace does not exist.\"),\n\t\t\t)\n\t\t}\n\n\t\tpermissions, err := svc.Permissions.Check(\n\t\t\tctx,\n\t\t\tauth.KeyID,\n\t\t\trbac.Or(\n\t\t\t\trbac.T(rbac.Tuple{\n\t\t\t\t\tResourceType: rbac.Ratelimit,\n\t\t\t\t\tResourceID:   namespace.ID,\n\t\t\t\t\tAction:       rbac.SetOverride,\n\t\t\t\t}),\n\t\t\t\trbac.T(rbac.Tuple{\n\t\t\t\t\tResourceType: rbac.Ratelimit,\n\t\t\t\t\tResourceID:   \"*\",\n\t\t\t\t\tAction:       rbac.SetOverride,\n\t\t\t\t}),\n\t\t\t),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fault.Wrap(err,\n\t\t\t\tfault.WithTag(fault.INTERNAL_SERVER_ERROR),\n\t\t\t\tfault.WithDesc(\"unable to check permissions\", \"We're unable to check the permissions of your key.\"),\n\t\t\t)\n\t\t}\n\n\t\tif !permissions.Valid {\n\t\t\treturn fault.New(\"insufficient permissions\",\n\t\t\t\t\tfault.WithCode(codes.Auth.Authorization.InsufficientPermissions.URN()),\n\t\t\t\tfault.WithDesc(permissions.Message, permissions.Message),\n\t\t\t)\n\t\t}\n\n\t\toverrideID := uid.New(uid.RatelimitOverridePrefix)\n\t\terr = db.Query.InsertRatelimitOverride(ctx, svc.DB.RW(), db.InsertRatelimitOverrideParams{\n\t\t\tID:          overrideID,\n\t\t\tWorkspaceID: auth.AuthorizedWorkspaceID,\n\t\t\tNamespaceID: namespace.ID,\n\t\t\tIdentifier:  req.Identifier,\n\t\t\tLimit:       int32(req.Limit),    // nolint:gosec\n\t\t\tDuration:    int32(req.Duration), //nolint:gosec\n\t\t\tCreatedAt:   time.Now().UnixMilli(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn fault.Wrap(err,\n\t\t\t\tfault.WithTag(fault.DATABASE_ERROR),\n\t\t\t\tfault.WithDesc(\"database failed\", \"The database is unavailable.\"),\n\t\t\t)\n\t\t}\n\n\t\treturn s.JSON(http.StatusOK, Response{\n\t\t\tOverrideId: overrideID,\n\t\t})\n\t})\n}\n\nfunc getNamespace(ctx context.Context, svc Services, workspaceID string, req Request) (db.RatelimitNamespace, error) {\n\n\tswitch {\n\tcase req.NamespaceId != nil:\n\t\t{\n\t\t\treturn db.Query.FindRatelimitNamespaceByID(ctx, svc.DB.RO(), *req.NamespaceId)\n\t\t}\n\tcase req.NamespaceName != nil:\n\t\t{\n\t\t\treturn db.Query.FindRatelimitNamespaceByName(ctx, svc.DB.RO(), db.FindRatelimitNamespaceByNameParams{\n\t\t\t\tWorkspaceID: workspaceID,\n\t\t\t\tName:        *req.NamespaceName,\n\t\t\t})\n\t\t}\n\t}\n\n\treturn db.RatelimitNamespace{}, fault.New(\"missing namespace id or name\",\n\t\tfault.WithTag(fault.BAD_REQUEST),\n\t\tfault.WithDesc(\"missing namespace id or name\", \"You must provide either a namespace ID or name.\"),\n\t)\n\n}\n\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"The handler is just a function that returns an error, making it easy to test and reason about. All the HTTP-specific logic (authentication, validation, error handling, response formatting) is handled by middleware or injected services.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"testing-made-easy\",children:\"Testing Made Easy\"}),`\n`,(0,n.jsx)(e.p,{children:\"Zen's simple design makes testing very easy, even our CEO loves it. Because routes are just functions that accept a context and session and return an error, they're easy to unit test:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-go\",children:`package handler_test\n\nimport (...)\n\nfunc TestRatelimitEndpoint(t *testing.T) {\n    h := testutil.NewHarness(t)\n\n    route := handler.New(handler.Services{\n        DB:          h.DB,\n        Keys:        h.Keys,\n        Logger:      h.Logger,\n        Permissions: h.Permissions,\n    })\n\n    h.Register(route)\n\n    rootKey := h.CreateRootKey(h.Resources.UserWorkspace.ID)\n\n    headers := http.Header{\n        \"Content-Type\":  {\"application/json\"},\n        \"Authorization\": {fmt.Sprintf(\"Bearer %s\", rootKey)},\n    }\n\n    req := handler.Request{\n        Namespace:  \"test_namespace\",\n        Identifier: \"user_123\",\n        Limit:      100,\n        Duration:   60000,\n    }\n\n    res := testutil.CallRoute[handler.Request, handler.Response](h, route, headers, req)\n    require.Equal(t, 200, res.Status)\n    require.NotNil(t, res.Body)\n    require.True(t, res.Body.Success)\n    require.Equal(t, int64(100), res.Body.Limit)\n    require.Equal(t, int64(99), res.Body.Remaining)\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"We've built test utilities that make it easy to set up a test harness with database dependencies, register routes, and call them with typed requests and responses.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"zen-is-open-source\",children:\"Zen is Open Source\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Zen lives in our open source mono repo, so you can explore or even use it in your own projects. The full source code is available in our GitHub repository at \",(0,n.jsx)(e.a,{href:\"https://github.com/unkeyed/unkey/tree/main/go/pkg/zen\",children:\"github.com/unkeyed/unkey/tree/main/go/pkg/zen\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"While we built Zen specifically for our needs, we recognize that other teams might face similar challenges with Go HTTP frameworks. You're welcome to:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Read through the implementation to understand our approach\"}),`\n`,(0,n.jsx)(e.li,{children:\"Fork the code and adapt it to your own requirements\"}),`\n`,(0,n.jsx)(e.li,{children:\"Use it directly in your projects if it fits your needs\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{id:\"conclusion\",children:\"Conclusion\"}),`\n`,(0,n.jsx)(e.p,{children:\"While the Go ecosystem offers many excellent HTTP frameworks, sometimes the best solution is a custom one tailored to your specific needs. A thin layer on top of Go's standard library can provide significant ergonomic benefits without sacrificing control or performance.\"}),`\n`,(0,n.jsx)(e.p,{children:\"As our API continues to grow, the simplicity and extensibility of Zen will allow us to add new features and functionality without compromising on performance or developer experience. The best abstractions are those that solve real problems without introducing new ones, and by starting with Go's solid foundation and carefully adding only what we needed, we've created a framework that enables our team to build with confidence.\"})]})}function h(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(c,{...t})}):c(t)}return b(T);})();\n;return Component;"